b'N92-22\nSOFTWARE\n\nDeputy\n\n708\n\nREENGINEERING\n\nErnest\nM. Fridge III\nChief,\nSoftware\nTechnology\nBranch/PT4\nNASA/Johnson\nSpace\nCenter\nHouston,\nTexas\n77058\n(713)\n483-8109\nNasamail:\nEFRIDGE\n\nABSTRACT\nToday\'s\nsoftware\nsystems\ngenerally\nuse obsolete\ntechnology,\nare not integrated\nproperly\nwith other software\nsystems,\nand are difficult\nand costly to maintain.\nThe discipline\nof\nreverse\nengineering\nis becoming\nprominent\nas organizations\ntry to move their systems\nup to\nmore modem\nand maintainable\ntechnology\nin a cost effective\nmanner.\nThe Johnson\nSpace\nCenter created\na significant\nset of tools to develpop\nand maintain\nFORTRAN\nand C code\nduring\ndevelopment\nof the space shuttle.\nThis tool set forms\nthe basis tbr an integrated\nenvironment\nto reengineer\nexisting\ncode into modem\nsoftware\nengineering\nstructures\nwhich\nare then easier and less costly\nto maintain\nand which\nallow a fairly straightforward\ntranslation\ninto other target languages.\nThe environment\nwill support\nthese structures\nand\npractices\neven in areas where\nthe language\ndefinition\nand compilers\ndo not enforce\ngood\nsoftware\nengineering.\nThe knowledge\nand data captured\nusing the reverse\nengineering\ntools\nis passed\nto standard\nforward\nengineering\ntools to redesign\nor perform\nmajor upgrades\nto\nsoftware\nsystems\nin a much more cost effective\nmanner\nthan using older technologies.\nA\nbeta version\nof the environment\nwas released\nin March,\n1991. The commercial\npotential\nfor\nsuch reengineering\ntools is very great. CASE TRENDS\nmagazine\nreported\nit to be the\nprimary\nconcern\nof over four hundred\nof the top MIS executives.\nINTRODUCTION\n\nPrograms in use today generally have all of the functional and information processing capabilities\nrequired\nto do their specified job. However, older programs usually use obsolete technology,\nare not integrated\nproperly with other programs,\nand are difficult to maintain.\nReengineering\nis becoming\na prominent\ncliscipline\nas organizations\ntry to move their systems to more modern and maintainable\ntechnologies.\nJohnson Space Center\'s (JSC) Software Technology\nBranch (STB) is researching\nand developing\na system\nto support reengineering\nolder FORTRAN\nprograms into more maintainable\nforms that can also be more\nreadily translated to a modern language such as FORTRAN\n8x, Ada, or C. This activity has Icd to the\ndevelopment\nof maintenance\nstrategies for design recovery and reengineering.\nThese strategies include a set\nof standards, methodologies,\nand the concepts for a software environment\nto support design recovery and\nmcngineering.\nThis document provides a brief description of the problem being addressed and the approach that is being\ntaken by the STB toward providing an economic solution to the problem.\nA statement of the maintenance\nproblems,the\nbenefits and drawbacks\nof three alternative\nsolutions,\nand a brief history of the STB\'s\nexperience\nin software reengineering\nare followed by the STB\'s new FORTRAN\nstandards, methodology,\nand the concepts for a software environment.\nSTATEMENT\n\nOF\n\nTHE\n\nPROBLEM\n\nBased on trends in the computer industry over the last few years, it is clear that computer\nhardware,\nlanguages,\nand procedures\nare not static. The software industry recognizes\nthat a large existing software\nbase must be dealt with as new software engineering\nconcepts and software technologies\nemerge.\nThe o1(1\nsystems use outdated technology and are costly to maintain.\nAt JSC, as in industry at large, there is a large\ninvestment\nin existing FORTRAN\nsoftware.\nThese FORTRAN\nsystems do not consistently\nuse modern\n\n277\n\nPRECEDli_K;I\n\nPAf\'_\n\nBI.ANK\n\nNOT\n\nFILMED\n\nsc_ftware practices that can increase maintainability.\nYet these systems must be maintained\nnext 20 years. Management\nis seeking ways to reduce maintenance\ncosts.\n\nfor perhaps\n\nthe\n\nIn the 1960s-70s many FORTRAN\nprograms were developed\nat JSC, each with its own sizeable software\ndevelopment\nteam, and its own input/output\nformat. These programs could not communicate\nreadily and\neventually were "wired" together in a very crude semblance of integration.\nStandards could not be enforced\nbecause FORTRAN\ndid not enforce them and some were not visible by just looking at the code. The\nproblem was aggravated\nby the lack of training of new developers\nplus a 50 percent turnover in the very\nlarge development\nstaff every two years.\nIn addition,\nthe user organizations\nhad more people doing\ndevelopment\nthan the development\ngroup, and these other organizations\nwere not always aware of the\nstandards and support tools available.\nThis history has left JSC with the following problems:\nMany programs are large and difficult to understand, resulting\nThe problems in maintenance\ntremendous duplication.\n\nled to users keeping\n\nin maintenance\n\ntheir own versions\n\nproblems.\n\nof programs,\n\nresulting\n\nin\n\nMany of the FORTRAN\nprograms have already been converted from their original dialect of FORTRAN to\nthe FORTRAN\n77 standard.\nAdditional\nconversions\nwill periodically\nbe required even if only to new\nFORTRAN standards.\nIt is necessary to consider the question, where will that code have to be in five or ten\nyears? Three possible answers come to mind:\nFORTRAN\n77 is the current standard,\nvendors\nstop supporting\nFORTRAN\nstandard or to another language.\n\nbut this will be replaced\n77, existing FORTRAN\n\nMuch of the code may move to the Ada language.\nFreedom work.\nWith C being the language\n\nof choice\n\nfor Unix,\n\nALTERNATIVE\n\nby newer Fortran standards.\nAs\nwill have to move to the ._ew\n\nThis will be particularly\n\nsome of the code might\n\ntrue on Space Station\n\nmove to the C language.\n\nSOLUTIONS\n\nThree alternative solutions to the problems identified above have been identified:\ncomplete redevelopment\nof the program, code translation\nto a more modern language or version of a language, and reengineering.\nEach of these is illustrated in figure 1 and discussed briefly in the following paragraphs.\nRedevelopment\nof a system from scratch is very expensive.\nRedevelopment\nincludes all of the same phases\nof the life cycle as new development,\nfrom requirements\nthrough integration and testing. Extensive domain\nanalysis is required, and there is a risk of incomplete\nrequirements.\nAll too often it is reported that a large\nprogram will be redeveloped\nfrom scratch to a more modern style only to find out that the new developers\ndid not understand all of the functions and necessary information requirements\nof the existing system.\nCode translation,\nespecially automatic code translation, costs much less. Some might then ask, why worry\nabout all of this now? We can use a translator when the time comes that we are forced to move the code for-\n\n278\n\nTranslation\n\nFigure\n\n1. Alternative\n\nward. Although this would be a nice solution,\ndue to several major reasons:\nPoor existing\n\ncontrol flow is translated\n\nPoor existing\n\ndata structures\n\nInput/output translation\n\nSolutions\n\nthe truth is that code translators\n\nhave proven\n\nunsuccessful\n\ninto poor control flow.\n\nremain poor data structures.\n\nusually produces hard to read "unnatural"code\n\nin the new language.\n\nTranslation does not take advantage of the code and data packaging techniques available in the\nnewer languages.\nAttempts\nto automatically\ntranslate some FORTRAN\nprograms to Ada have\nfailed.\nReengineering\n\nis the\n\ncombination\n\nof\n\n"reverse\n\nengineering"\n\na working\n\nsoftware\n\nsystem\n\nand\n\nthen\n\n"forward\n\nengineering"\na new system based on the results of the reverse engineering.\nForward engineering\nis the\nstandard process of generating\nsoftware from "scratch." It is composed\nof the life cycle phases such as\nrequirements,\narchitectural\ndesign, detailed design, code development,\ntesting, etc. In each phase, certain\nproducts are required and the activities which produce them are defined.\nEach product is required to be\ncomplete and consistent.\nTo progress forward to a new phase normally requires a new representation\nof the\nproducts which involve more detail such as new derived requirements,\ndesign decisions, trade off evaluation\nbetween alternative approaches, etc. Finally, code is developed which is the most complete, consistent, and\ndetailed representation\nof the required product.\nReverse engineering is the reverse of forward engineering.\nIt is the process of starting with existing code\nand going backward through the software develowaent\nlife cycle. Life cycle products are, therefore, obtained\nby abstracting from more detailed representations\nto more abstract ones. This process should proceed much\nfaster than forward engineering since all of the details required are available. Reverse engineering starts with\nthe most detailed representation, which has also proven to be complete and consistent since it can currently\ndo the job required. Developing products in reverse involves abstracting out only the essential information\nand hiding the non-essential details at each reverse step.\nHow far to go backward in the reverse engineering process before\nbegins is a critical question and involves trade offs. It is important\n\n279\n\nit is stopped and forward engineering\nto understand all of what the program\n\ndoes, all of the information it handles, and the control flow since these are probably required to get the job\ndone. This implies taking the reverse process far enough to understand what the "as is" program is. This is\nusually more significant than how the program does its job since the how is usually the part that will be\nchanged in any following forward engineering process.\nWhat a program does is called its requirements. How it meets those requirements is its design. For a\nreverse engineered program it is the design that will be updated more often than what the program will do.\nModern software engineering techniques and technologies such as user interfaces, database management,\nmemory utilization, data structuring, packages, objects, etc. will affect the design, not what the program\ndoes. Therefore, once it is understood what the program does and what is obsolete, then the forward\nengineering process can begin with confidence.\nReverse engineering is referred to as "design recovery" when the reverse engineering process stops at the\nrecovery of the design of the implementation, rather than proceeding on to a higher level of abstraction to\ninclude the recovery of the requirements. The basic process of this level of design recovery involves\nrecovery of information about the code modules and the data structures in an existing program. This\ninformation will support the programmer/analyst who is maintaining an unfamiliar large FORTRAN\nprogram, upgrading it for maintainability, or converting it to another target language.\nHowever, a better job of redesigning a program can be accomplished with requirements recovery than with\ndesign recovery. To carry the reverse engineering process beyond design recovery to requirements recovery\nis difficult and requires higher levels of domain knowledge to do the abstractions.\nThe whys of the\nrequirements, design, and implementation can only be provided by someone very familiar with the program\nand the domain. This level of expertise is often very difficult to find and have dedicated to the reengineefing\nprocess. For this reason, the methods and tools that the STB has developed initially assume reverse\nengineering only to the design recovery stage. Future development will be based on feedback from the JSC\nsoftware engineering community. The current standards, methods, tools, and environment are all designed\nto be sufficiently flexible and extendible to enable the strategies to be extended to cover the full spectrum of\nreverse engineering.\nThe overriding philosophy of this planned reverse engineering process is to capture the total software\nimplementation in an electronic form. This includes source code, documentation, databases, etc. Figure 2\nillustrates the progression of data structures from COMGEN-compatible\ncode (see section "Software\nTechnology Branch\'s Reengineering History") to reengineered code. This progression in electronic form\nensures that the total consistent and complete requirements representation is available. Software tools are\nprovided to support the generation of the more abstract products required for engineering in reverse as well\nas capturing rationale and decisions of the engineer. By the continuing process of abstracting the\ninformation about the program into the different representations, the engineer can remain more confident\nthat information is not being lost or inadvertently "falling through the cracks."\n\n280\n\nFigure 2. Data Structure Progression\nSOFTWARE\n\nTECHNOLOGY\n\nBRANCH\'S\n\nREENGINEERING\n\nHISTORY\n\nIn the early 1970\'s, the Mission Planning and Analysis Division\'s (MPAD) Software Development\nBranch\nand TRW/Houston\ndeveloped\na tool, called COMGEN, that began as a COMMON\nblock specification\nstatement generator.\nIt grew to include many other functions as new techniques\nwere developed.\nLater\nCOMGEN\nwas broken up into a continually evolving set of tools with common data interface structures.\nThis tool set supports the maintenance\nof FORTRAN\nprograms\ntoday on Unisys and multiple\nUnix\nsystems.\nPeople still refer to this tool set as COMGEN\ntools, and a program that complies\nwith the\nMPAD standard COMMON concept as a COMGEN-compatible\nprogram.\n[1,2,3]\nIn the 1970\'s, MPAD performed a lot of software re,engineering\nto meet the goal of combining many of the\nindependently\ndeveloped\nengineering\nprograms,\neach with its own input/output\nformats.\nMany of the\nmodern concepts\nsuch as separation\nof input/output\nprocessing from the applications,\ndatabases,\ndata\nstructures, packages, generics, objects, etc. were recognized and simulated to some degree. They were not\ncalled by the modern names, of course, but the design engineers\nwere trying to do good engineering,\nmodularization,\nand data handling.\nEven though these techniques were known in the 1970\'s, they are just\nnow really becoming popular because of newer technologies\nsuch as database management\nsystems, user\ninterface\ntools sets, and modern languages\nthat actually embed and enforce good software engineering\npractices.\nIn the late 1980\'s, some of the personnel\nand the functions\nof the Software Development\nBranch were\nreorganized\ninto the newly created Software Technology\nBranch (STB).\nThe STB\'s reengineering\nhistory\nhas put JSC in a better position with respect to the maintainability\nof its older software than many other\norganizations.\nThe positive results of this experience include the following:\nMost of the software\n\nis reasonably modular.\n\nThe data has some structure.\nMost of the software\ndocumentation.\n\nat JSC is reasonably\n\ncompatible\n\nwith the STB\'s tools,\n\nThe large complex programs that support many simulations\ninformation\nsharing.\n\n281\n\nhave considerable\n\nincluding\n\nsoftware\n\nthe in-line\n\nreuse and\n\nMAINTENANCE\n\nSTRATEGIES\n\nThe strategies presented in this document\nare intended to help with design recovery\nin support of\nprogrammer/analysts\nwho are required to maintain large FORTRAN programs that they did not develop. In\naddition, these strategies are intended to support reengineering of existing FORTRAN code into modern\nsoftware engineering\nstructures, which are then easier to maintain and which allow a fairly straight forward\ntranslation into other target languages.\nThe STB is proposing standards, methods, and an integrated\nsoftware environment based upon the significant set of tools built to develop and maintain FORTRAN code\nfor the Space Shuttle. [4,5,6,7,8]\nThe environment\nwill support these slruclnres and practices even in areas\nwhere the language definition and compilers do not enforce good software engineering\npractices.\nNew FORTRAN\n\nStandards\n\nNew standards, which allow modem software engineering constructs to be used in FORTRAN\n77, have\nbeen defined by the STB. [5] These standards are added to existing standards defined by the former MPAD\nand still in use in the mission planning and analysis domain. The goal of the new standards is to improve\nmaintainability\nand permit relatively automated translations to newer languages.\nIn table I, the standards\nand their benefits are summarized. These standards address documentation, longer variable names, modem\ncontrol\nflow structures,\ngrouping subprograms\ntogether as virtual packages,\ndata structuring,\nand\ninput/output encapsulation\nin separate subprograms. Where FORTRAN 77 does not provide the constructs,\nvirtual constructs\nare provided\nalong with a tool environment\nto support their development\nand\nmaintenance.\nThe existing core of FORTRAN programmers should have little problem with the standards\nand new FORTRAN code should adhere to them from the start.\n\nTable 1. Standards Summary\n\nStandard\n\nBenefit\n\nDocumentation\nHeader statement before code blocks\n\nUnderstandability\nUnderstandability and traceability\nDesign knowledge capture\nMaintenance\n\nRequirements\nin CD1 statements\nRationale in CD7 statements\nVirtual package identification\nLonger_ more meaningful variable\nModem control flow structures\nBlock DO\nDO WHILE\n\nnames\n\nUnderstandability\nMaintenance and understandability\n\nGrouping subprograms into virtual packages\nData structuring\nPreferred use of calling parameters\nControlled use of COMMON\nblocks\n\nPreferably encapsulate\nseparate subprograms\n\nDesign Recovery\n\ninput/output\n\nand Reen_ineering\n\nHigher level of abstraction t understandability\nMaintenance\nMaintenance\nINCLUDE\nCOMMON database concept\nMaintenance and support to future\nconversions\n\nin\n\nMethodology\n\nThe reengineering\nmethodology\ndefines the steps, the skills required,\nengineer\nbefore deciding\nto rebuild.\nThe key goal is to update\nengineering\nconcepts\nwithout losing required functions\nand data.\nflexibility\nto meet multiple\nlevels of conversion,\neach of which\n\n282\n\nand guidelines on how far to reverse\nto modem\ntechnology\nand software\nMethods are provided that have the\nimproves\nmaintainability.\nFigure 3\n\nillustrates methods.\nfive\n[6]Method 1 converts arbimn\'yORTRAN programtoCOMGEN-compatible\nan\nF\nFORTRAN, which provides\nin-lineocumentation,\nd\ndatastructure, uniquedatanames withina\nand\nCOMMON\nstructure.\nMethod2 convertsoftwarelreadynthis ormat\ns\na\ni\nf\ntothenew "standard"\nFORTRAN\nwitha more Aria-like\nstructure isreadyfora mostlyautomated\nthat\ntranslation Method 3 toa target\nby\nlanguage embeds softwarengineering\nthat\ne\nprinciples.\nAlternatively,\nCOMGEN-compatible programs\ncan\nbc converted\ndirectly a target\nto\nlanguage\nlike\nAriaby Method 4. Althoughitiseasier convert\nto\na\nFORTRAN programwhen thecodealready eetsthestandard\nm\nCOMMON\nconcept,ommonly known as\nc\nCOMGEN-compatible,\narbitrary\nFORTRAN canbe directly\nconvezted target\ntoa\nlanguagey Method 5.\nb\n\nOther\nTargel\nLanguage\n(e.g., C,\nAda,\n0r\nFORTR8x)\n\nProcess\ncanterminate anyof thestates\nat\nFigure 3. Reengineering Methods\nE/wironment to Sungor_ Design Recovery and Reengineerin_\nThe STB\'s reengineering environment [7] is being built around three components: standards, methods, and\ntools that support the standards and the methods. It contains modified versions of the tools used to support\nthe current JSC FORTRAN programs plus commercial off-the-shelf (COTS) tools and additional custombuilt tools. The intent is to get an environment out into use in ]SC\'s maintenance community to provide\nsupport for upgrading FORTRAN programs in terms of maintainability in the near-term, then to extend the\nfunctionality of the tool set and environment in response to feedback from the programmers/analysts.\nCurrently about eight groups at ]SC are using the tools. Some support for the C language exists and a\ncooperative agreement with the Microelectronic and Computer Technology Corporation (MCC) is\nevaluating researchintodesignrecovery of C programs.\nThe environment has been designed with stable interfaces defined to provide for the maximum degree of\nseamlessness that is desirable. It is doubtful that COTS tools can be integrated seamlessly into the\nenvironment as no standard interfaces have yet been established for either user interface or data interface (as\nopposed to dam exchange). The tools are integrated at the front end by a user interface and behind the screen\nby two logical databases, one containing data passed to and from the tools and the other containing the\noriginal and modified source code as shown in figure 4. CASE framework tools are being evaluated as\npossible integration mechanisms.\n\n283\n\nTool\n\nFigure 4. Conceptual Architecture of the Design Recovery and Reengineering Environment\nThe environment will not be a completely automated environment since much work will still have to be\ndone by a programmer/analyst. A person must be in the loop to provide the required puzzle-solving skills\nthat are beyond the capabilities of state-of-the-practice tools. However, as an experience base is accrued in\ndesign recovery and rcengineering, knowledge-based capabilities can be added to the environment.\nVersion 1 of the environment called REengineering APplications 0rEAP) was delivered in June, 1991. This\nintegrated all existing JSC supported tools listed above, behind a common user interface built on the\nMOTIF standard. It contains major elements of all subsystems and encapsulates the capabilities that have\nbeen developed and used at JSC during the last fifteen years. A version with improved tool integration, user\ninterface enhancements, and the commercial LOGISCOPE tool was delivered in October, 1991. The Fortran\ndesign recovery version should be available in February, 1992. MCC should also have delivered an\nevaluation prototype of a design recovery capability for the C language by that time. In parallel, the study\nof using CASE framework standards and tools to better integrate and manage this environment should be\ncompleted early in 1992 and the version 2 series will be delivered on one of these platforms. The plans and\ndesign of REAP are such, that all deliveries containing COTS products will be tailorable so that users can\ndelete the COTS tools that they do not want to liscense. This policy even includes the framework\nintegration tools. In most cases, similar functions might still be available but they would have less\ncapability.\nCONCLUSIONS\nJSC has a large amount of exsting code in FORTRAN that embodies domain knowledge and required\nfunctionality. This code must be maintained and eventually translated to more modern languages. Three\nprimary alternative solutions have been identified to address the maintenance problems of these old\nFORTRAN programs: complete redevelopment of the programs, code translation to a more modern\nlanguage or version of a language, and reengineering. Complete redevelopment is effective but very costly.\nSimple code translation is cheap, but usually ineffective since seldom do the old systems incorporate\nmodern software engineering concepts such as good data structuring, good control structuring, packages,\nobjects, etc., that should be present in the new system. Modern languages such as Ada have constructs for\nrepresenting these features, but translators cannot determine these features in the original code to map them\ninto the new system. Reengineering is being recognized as a viable option because the old systems, in\n\n284\n\nspite of obsolete technology, do contain all of the required functionality\nand can get the job done. However,\nat the present time there are only a few expensive Computer Aided Software Engineering\n(CASE) tools and\nno total system environment\navailable in the COTS market to support reengineering\nFORTRAN\nprograms.\nThe STB maintenance strategies provide standards, methods, and a tool environment\nfor upgrading current\nFORTRAN systems without losing the embedded\nengineering\nknowledge\nand at a lower cost than for\ncomplete redevelopment\nof the program. A useful environment\nfor reengineering\nFORTRAN\nsoftware can\nbe built fairly quickly by building upon the existing FORTRAN\ndevelopment\nand maintenance\ntools,\nCOTS products, new software and hardware technologies,\nplus current research into reuse, design recovery,\nand reengineering.\nThis environment\nwill support reengineering\nexisting FORTRAN\ncode into more\nmaintainable\nforms that can also be readily translated into a modern language including newer versions of\nFORTRAN.\nTwo versions of the environment\nwere delivered in 1991 which integrate the existing JSC tools plus the\ncommercial\nLOGISCOPE\ntool behind a common\nMOTIF user interface.\nA Fortran design recovery\ncapability should be available in February, 1992 and the MCC should deliver a design recovery prototype\nfor the evaluation\nof design recovery in the C language by that time. Plans are to integrate this capability\non a CASE framework tool during 1992.\nGLOSSARY\narbitrary\n\nFORTRAN\n\nFORTRAN program that is not compatible\nwith the COMGEN\nin place for JSC\'s mission planning and analysis domain.\n\nstandards\n\nCOMGEN-compatible\n\nFORTRAN program that is compatible with the COMGEN\nplace for JSC\'s mission planning and analysis domain. [1]\n\nCOTS\n\nCommercial-Off-The-Shelf\n\ndesign recovery\n\nReverse\n\nenvironment\n\nInstantiation of a framework,\ni.e., an integrated\ncollection\nof tools.\nsupport one or more methodologies\nand may also provide a framework\nparty tools.\n\nframework\n\nSoftware system to integrate both the data and the control of new and existing\ntools; usual components\ninclude a user interface, object management\nsystem, and\na tool set.\n\nengineering,\n\nthe first step for maintenance\n\nstandards for FORTRAN\n\nstandards\n\nlong\n\nlong in\n\nor reengineering.\nIt may\nfor third\n\nFORTRAN\n\n77\n\nANSI\n\nin effect in June 1990.\n\nFORTRAN\n\n8x\n\nFuture ANSI standards for FORTRAN;\nexpected to be approved\nand released\nsoon; draft standards have been circulated; unofficially called FORTRAN 90.\n\nforward engineering\n\nProcess\nof\nrequirements,\n\ndeveloping\nsoftware\ndesign, and coding.\n\nfrom\n\n"scratch,"\n\nthrough\n\npack_e\n\n"A collection\n\nof logically\n\nreengineering\n\n"The examination\nand alteration of a subject system to reconstitute\nit in a new\nform and the subsequent implementation\nof the new form" (Chikofsky\nand Cross\n[10]); combination\nof reverse engineering and forward engineering.\n\nreverse engineering\n\n"The process of analyzing a subject system to identify the system\'s components\nand their interrelationships\nand create representations\nof the system in another\nform or at a higher level of abstraction"\n(Chikofsky\nand Cross [10]); the first\nstep of maintenance\nor reengineering;\nreverse of forward engineering;\nprocess of\n\nrelated entities or computational\n\n285\n\nthe\n\nresources"\n\nphases\n\nof\n\n(Beech[9]).\n\nstarting\nwith existing\ndevelopment life cycle.\nsoftware\n\nmaintenance\n\ncode\n\nProcess of modifying existing\nfunctions intact (Boehm [ 11]).\n\nand\n\ngoing\n\nbackward\n\noperational\n\nsoftware\n\nthrough\n\nwhile\n\nthe\n\nleaving\n\nsoftware\n\nits primary\n\nsubject program\n\nProgram that is being maintained or reengine_xed.\n\nvirtual package\n\nPackage concept as defined by Booch [9], but implemented either in Ada, which\nenforces the concept, or in a language in which the concept must be supported\nprocedttrally.\nREFERENCES\n\n[ 11\n\nBraley, Dennis:\nNASA Johnson\n\nComputer Program Development and Maintenance\nSpace Center (Houston, TX), November\n1980.\n\n[21\n\nBraley, Dennis: Automated\n(Houston, TX), April 1986.\n\n131\n\nBraley, Dennis: Software Development\nand Maintenance\nJohnson Space Center (Houston, TX), October 1986.\n\nI41\n\nFridge III, Ernest: Maintenance\nStrategies\nSummary\nand Problem Statement.\nVolume\n1990.\n\nI5]\n\nBraley, Dennis: Maintenance\nStrategies\nfor Design Recovery\nand Reengineering:\nStandards.\nVolume 2. NASA Johnson Space Center (Houston, TX), June 1990.\n\n[6]\n\nBraley, Dennis; and Plumb,\nMethods. Volume 3. NASA\n\n[71\n\nBraley, Dennis; and Plumb, Allan: Maintenance\nStrategies for Design Recovery and Reengineering:\nConcepts for an Environment.\nVolume 4. NASA Johnson Space Center (Houston, TX), June 1990.\n\nI81\n\nGeorge,\nVivian; and Plumb, Allan: A Method\nTechnology,\nInc. (Houston, TX), March 1990.\n\n191\n\nBooch, G.: Software\nCA), 1983.\n\nSoftware\n\nDocumentation\n\nNASA\n\nAids Catalog.\n\nJohnson\n\nfor\n\nConversion\n\nwith Ada. Benjamin/Cummings\n\nEngineering\n\nIN 80-FM-55,\n\nSpace\n\nCenter\n\nIN 86-FM-27,\n\nNASA\n\nAllan: Maintenance Strategies for Design Recovery\nJohnson Space Center (Houston, TX), June 1990.\n\nEngineering\n\nB. W.: Software\n\nTechniques.\n\nNASA\n\nNASA\n\nfor Design Recovery\nand Reengineering:\n1. NASA Johnson Space Center (Houston,\n\n1101 Chikofsky, E. J.; and Cross II, J. H.: "Reverse\nIEEE Software, January 1990.\n11 I] Boehm,\n\nTechniques.\n\nEngineering\n\nEconomics.\n\n286\n\nPrentice-Hall\n\nof FORTRAN\n\nPublishing\n\nand Design\n\n(Englewood\n\nExecutive\nTX), June\n\nFORTRAN\n\nand Reengineering"\n\nPrograms.\n\nBarrios\n\nCo., Inc. (Menlo\n\nRecovery:\n\nPark,\n\nA Taxonomy."\n\nCliffs, NJ), 1981.\n\n'