b'N93-3215,\nSOFTWARE\n\nDeputy\n\nREENGINEERING\n\nErnest\nM. Fridge\nHI\nChief,\nSoftware\nTechnology\nBranch/PT4\nNASA/Johnson\nSpace\nCenter\nHouston,\nTexas\n77058\nCo-Authors:\n\nJim Hiott\nSenior\nSoftware\nEngineer\nParamax\nSystems\nCorporation\nM/C\nU08A,\n600 Gemini\nHouston,\nTexas\n77058\nJim Golej\nGroup\nLeader\nThe Mitre Corporation\n1120 NASA\nRoad\n1\nHouston,\nTexas,\n77058\nAllan\nPlumb\nProject\nEngineer\nBarrios\nTechnology,\nInc.\n1331\nGemini\nHouston,\nTexas\n77058\n\nABSTRACT\n\neffective\nmanner\nthan using older technologies.\nThe latest release\nof the environment\nwas in\nFebruary 1992.\n\nToday\'s software systems\ngenerally\nuse obsolete\ntechnology,\nare not integrated properly with other\nsoftware\nsystems,\nand axe difficult and costly to\nmaintain.\nThe discipline\nof reverse engineering\nis\nbecoming\nprominent\nas organizations\ntry to move\ntheir systems up to more modem and maintainable\ntechnology\nin a cost effective\nmanner.\nThe\nJohnson Space Center created a significant\nset of\ntools to develop\nand maintain FORTRAN\nand C\ncode during development\nof the space shuttle. This\ntool\nset forms\nthe basis\nfor an integrated\nenvironment\nto reengineer\nexisting\ncode into\nmodem\nsoftware engineering\nstructures which are\nthen easier and less costly to maintain and which\nallow a fairly straightforward\ntranslation into other\ntarget languages.\nThe environment\nwill support\nthese structures and practices even in areas where\nthe language\ndefinition\nand compilers\ndo not\nenforce\ngood\nsoftware\nengineering.\nThe\nknowledge\nand data captured\nusing the reverse\nengineering\ntools is passed to standard forward\nengineering\ntools to redesign\nor perform major\nupgrades\nto software systems in a much more cost\n\nINTRODUCTION\n\nPrograms\nin use today generally\nhave all of the\nfunctional and information\nprocessing\ncapabilities\nrequired\nto do their specified job. However,\nolder\nprograms usually use obsolete technology,\nare not\nintegrated\nproperly with other programs,\nand are\ndifficult to maintain.\nReengineering\nis becoming a\nprominent discipline\nas organizations\ntry to move\ntheir systems\nto more modem\nand maintainable\ntechnologies.\nJohnson\nSpace\nCenter\'s\n(JSC)\nSoftware Technology\nBranch (STB) is researching\nand developing\na system to support reengineering\nolder FORTRAN\nprograms into more maintainable\nforms that can also be more readily translated\nto a\nmodem language such as FORTRAN\n90, Ada, or\nC. This activity has led to the development\nof\nmaintenance\nstrategies\nfor design\nrecovery\nand\nreengineering.\nThese strategies\ninclude a set of\nstandards, methodologies,\nand the concepts\nfor a\n\n427\n\n\xe2\x80\xa2\n\nx\n\nsoftwareenvironment\n\nto support\n\ndesign\n\nrecovery\n\nand reengineering.\nThis document\nprovides a brief description\nof the\nproblem being addressed and the approach that is\nbeing taken by the STB toward providing\nan\neconomic\nsolution to the problem.\nA statement of\nthe maintenance\nproblems,the\nbenefits\nand\ndrawbacks\nof three alternative\nsolutions,\nand a\nbrief history\nof the STB\'s experience\nin software\nreengineering\nare followed\nby the STB\'s new\nFORTRAN\nstandards,\nmethodology,\nand the\nconcepts\nfor a software environment.\n\nSTATEMENT\n\nOF THE\n\nand these other organizations\nwere not always\naware of the standards and support tools available.\nThis history\nhas left JSC with the following\nproblems:\nMany programs\nare large, and difficult\nto\nunderstand,\nresulting\nm maintenance\nproblems.\nThe problems\nin maintenance\nled to users\nkeeping\ntheir own versions\nof programs,\nresulting\nin tremendous\nduplication.\nMany of the FORTRAN\nprograms\nhave already\nbeen converted\nfrom\ntheir original\ndialect\not\nFORTRAN\nto the FORTRAN\n77 standard.\nAdditional\nconversions\nwill\nperiodically\nbe\n\nPROBLEM\n\nrequired\neven\nif only\nto new\nFORTRAN\nstandards.\nIt is necessary to consider the question,\nwhere will that code have to be in five or ten\n\nBased on trends in the computer industry over the\nlast few years, it is clear that computer hardware,\nlanguages,\nand procedures\nare not static.\nThe\nsoftware industry recognizes\nthat a large existing\nsoftware base must be dealt with as new software\nengineering\nconcepts\nand software technologies\nemerge.\nThe old systems use outdated technology\nand are costly to maintain.\nAt JSC, as in industry\nat large, there is a large investment\nin existing\nFORTRAN\nsoftware.\nThese FORTRAN\nsystems\ndo not consistently\nuse modern\nsoftware practices\nthat can increase\nmaintainability.\nYet these\nsystems must be maintained\nfor perhaps the next\n20 years. Management\nis seeking ways to reduce\nmaintenance\ncosts.\n\nyears?\n\nThree\n\npossible\n\nFORTRAN\n\nanswers\n\ncome\n\n77 is the current\n\nto mind:\nstandard,\n\nbut\n\nthis will be replaced\nby FORTRAN\n90. As\nvendors\nstop supporting\nFORTRAN\n77,\nexisting FORTRAN\nwill have to move to\nthe new standard or to another language.\nMuch of the code may move to the Ada\nlanguage.\nThis will be particularly true on\nSpace Station Freedom\nwork.\nWith" C being the language\nof choice for\nUnix and the X Window\nSystem, some of\nthe code might move to the C language.\n\nIn the 1960s-70s\nmany FORTRAN\nprograms\nwere\ndeveloped\nat JSC, each with its own sizeable\nsoftware\ndevelopment\nteam,\nand\nits\nown\ninput/output\nformat.\nThese programs\ncould not\ncommunicate\nreadily and eventually\nwere "wired"\ntogether\nin a very crude semblance\nof integration.\nStandards\ncould\nnot be enforced\nbecause\nFORTRAN\ndid not enforce them and some were\n\nALTERNATIVE\n\nThree\nalternative\nidentified\nabove\n\nSOLUTIONS\n\nsolutions\nto the\nhave been identified:\n\nproblems\ncomplete\n\nredevelopment\nof the program,\ncode translation\nto\na more modern language\nor version of a language,\nand reengineering.\nEach of these is illustrated\nin\nfigure\n1 and discussed\nbriefly\nin the following\nparagraphs.\n\nnot visible\nby just looking\nat the code.\nThe\nproblem\nwas aggravated\nby the lack of training of\nnew developers\nplus a 50 percent\nturnover\nin the\nvery large development\nstaff every two years. In\naddition,\nthe user organizations\nhad more people\ndoing development\nthan the development\ngroup,\n\n428\n\nFigure\n\n1. Alternative\n\nRedevelopment\nof a system from scratch is very\nexpensive.\nRedevelopment\nincludes\nall of the\nsame phases of the life cyclz as new developm.ent,\nfrom requirements\nthrough integra.uon and testing.\nExtensive domain analysis is r_luircd, and there is\na risk of incomplete\nreq "uirements. _All too often it\nis claimed that a large pmgrmn willbe redeveloped\nfrom scratch to a more modern\nstyle only to find\nout that the new developers\ndid not understand all\nof the functions\nand necessary\ninformation\nrequirements\nof the existing system.\n\nTranslation does not take advantage of the\ncode\nand data packaging\ntechniques\navailable in the newer languages,\nAttempts\nto automatically\ntranslate some FORTRAN\nprograms to Ada have failed.\nReengineering:\nis the combination\nof "reverse\nengineering"\na working software system and then\n"forward\nengineering"\na new system based on the\nresults\nof the reverse\nengineering.\nForward\nengineering\nis the standard process of generating\nsoftware from "scratch."\nIt is composed\nof the life\ncycle phases\nsuch as requirements,\narchitectural\ndesign,\ndetailed\ndesign,\ncode\ndevelopment,\ntesting,\netc. In each phase, certain\nproducts\nare\nrequired and the activities\nwhich produce them are\ndefined.\nEach product\nis required\nto be complete\nand consistent.\nTo progress\nforward\nto a new\nphase normally\nrequires\na new representation\nof\nthe products\nwhich involve\nmore detail such as\nnew derived requirements,\ndesign decisions,\ntrade\noff evaluation\nbetween\nalternative\napproaches,\netc.\nFinally,\ncode is developed\nwhich\nis the most\ncomplete,\nconsistent,\nand detailed representation\nof\nthe required product.\n\nCode\ntranslation,\nespecially\nautomatic\ncode\ntranslation,\ncosts much less.\nSome\nmight then\nask, why worry about all of this now? We can use\na translator when the time comes that we are forced\nto move the code forward.\nAlthough\nthis would\nbe a nice solution,\nthe truth is that code translators\nhave proven\nunsuccessful\ndue to several\nmajor\nreasons:\nPoor existing control\npoor control flow.\nPoor existing\ndata\ndata structures.\nInput/output\nhard to read\n\nflow is translated\n\nstructures\n\nremain\n\nSolutions\n\ninto\n\npoor\n\ntranslation\nusually produces\n"unnatural"code\nin the new\n\nReverse\nengineering\nis the opposite\nof forward\nengineering.\nIt is the process\nof starting with\nexisting\ncode and going backward\nthrough\nthe\n\nlanguage.\n429\n\nstructures\nin an existing\nprogram.\nThis\ninformation\nwill support the programmer/analyst\nwho is maintaining\nan unfamiliar\nlarge FORTRAN\nprogram,\nupgrading\nit for maintainability,\nor\nconverting it to another target language.\n\nsoftware\n\ndevelopment\nlife cycle.\nLife cycle\nproducts\nare, therefore,\nobtained\nby abstracting\nfrom more detailed representations\nto more abstract\nones.\nThis process should proceed\nmuch faster\nthan forward engineering\nsince all of the details\nrequired are available.\nReverse engineenng\nstarts\nwith the most detailed representation,\nwhich has\nalso proven to be complete\nand consistent\nsince it\ncan currently\ndo the job required.\nDeveloping\nproducts in reverse involves\nabstracting\nout only\nthe essential\ninformation\nand hiding the nonessential details at each reverse step.\n\nHowever,\na better job of redesigning\na program\ncan be accomplished\nwith requirements\nrecovery\nthan with design recovery.\nTo carry the reverse\nengineering\nprocess\nbeyond\ndesign\nrecovery\nto\nrequirements\nrecovery\nis difficult\nand requires\nhigher\nlevels\nof domain\nknowledge\nto do the\nabstractions.\nThe whys\nof the requirements,\ndesign, and implementation\ncan only be provided\nby someone very familiar with the pro. gram and the\ndomain.\nThis level Of expertise\nis often very\ndifficult\nto find\nand have\ndedicated\nto the\nreengineering\nprocess.\nFor this reason,\nthe\nmethods\nand tools that the STB has developed\ninitially\nassume\nreverse\nengineering\nonly to the\ndesign recovery\nstage. Future development\nwill be\nbased\non feedback\nfrom\nthe JSC\nsoftware\n\nHow far to go backward in the reverse engineering\nprocess\nbefore\nit is stopped\nand\nforward\nengineering\nbegins is a critical\nquestion\nand\ninvolves trade offs. It is important\nto understand\nall of what theprogram\ndoes, all of the information\nit handles,\nand the control\nflow since these are\nprobably\nrequired\nto get the job done.\nThis\nimplies taking the reverse\nprocess\nfar enough to\nunderstand\nwhat the "as is program\nis. This is\nusually\nmore significant\nthan how the program\ndoes its job since the how is usually the part that\n_vill be changed\nin any following\nforward\nengineering\nprocess.\n\nengineering\ncommunity:\nThe current standards,\nmethods,\ntools, and environment\nare all designed\nto be sufficiently\nflexible\nand extendible\nto enable\nthe strategies\nto be extended\nto cover the full\nspectrum of reverse engineering.\n\nWhat a program does is called its requirements.\nHow it meets those requirements\nis its design.\nFor\na reverse engineered program\nit is the design that\nwill be updated more often than what the program\nwill do. Modem\nsoftware engineering\ntechniques\nand technologies\nsuch as user interfaces,\ndatabase\nmanagement,\nmemory utilization,\ndata structuring,\npackages,\nobjects, etc. will affect the design, not\nwhat\nthe program\ndoes.\nTherefore,\nonce it is\nunderstood\nwhat the program\ndoes and what is\nobsolete, then the forward engineering\nprocess can\nbegin\n\nThe overriding\nphilosophy\nof this planned reverse\nengineering\nprocess is to capture the total software\nimplementation\nin an electronic\nform.\nThis\nincludes\nsource code, documentation,\ndatabases,\netc.\nFigure 2 illustrates\nthe progression\nstructures\nfrom COMGEN-compatible\nsection\n"Software\nTechnology\n\nof data\ncode (see\nBranch\'s\n\nReengineering\nHistory")\nto reengineered\ncode.\nThis progression\nin electronic\nform ensures\nthat\nthe total consistent\nand complete\nrequirements\nrepresentation\nis available.\nSoftware\ntools are\nprovided\nto support\nthe generation\nof the more\nabstract\nproducts\nrequired\nfor engineering\nin\nreverse as well as capturing rationale\nand decisions\nof the engineer.\nBy the continuing\nprocess\nof\nabstracting\nthe information\nabout the pro.gram into\nthe different\nrepresentations,\nthe eng.meer\ncan\nremain\nmore confident\nthat informauon\nis not\n\nwith confidence.\n\nReverse\n_ngineedng\nis referred\nto as "design\nrecovery"\nwhen the reverse\nengineering\nprocess\nstops\nat the recovery\nof the design\nof the\nimplementation,\nrather than proceeding\non to a\nhigher level of abstraction\nto include the recovery\nof the requirements.\nThe basic process\nof this\nlevel of design\nrecovery\ninvolves\nrecovery\nof\ninformation\nabout the code modules\nand the data\n\nbeing lost\ncracks."\n\n430\n\nor inadvertently\n\n"falling\n\nthrough\n\nthe\n\nFigure2. Data Structure\nProgression\n\nSOFTWARE\nTECHNOLOGY\nREENGINEERING\nHISTORY\n\nBRANCH\'S\n\ntrying to do good engineering, modularization, and\ndata handling. Even though these techniques were\nknown in the 1970\'s, they are just now really\nbecoming popular because of newer technologies\nsuch as database management\nsystems, user\ninterface tools sets, and modern languages that\nactually\nembed and enforce\ngood software\nengineering practices.\n\nIn the early 1970\'s, the Mission Planning and\nAnalysis\nDivision\'s\n(MPAD)\nSoftware\nDevelopment\nBranch\nand TRW/Houston\ndeveloped a tool, called COMGEN, that began as a\nCOMMON\nblock\nspecification\nstatement\ngenerator. It grew to include many other functions\nas new techniques\nwere developed.\nLater\nCOMGEN was broken up into a continually\nevolving set of tools with common data interface\nstructures. This tool set supports the maintenance\nof FORTRAN programs today on Unisys and\nmultiple Unix systems. People still refer to this\ntool set as COMGEN tools, and a program that\ncomplies with the M_PAD standard COMMON\nconcept as a COMGEN-compatible\nprogram.\n[1,2,3]\n\nIn the late 1980\'s, some of the personnel and the\nfunctions of the Software Development\nBranch\nwere reorganized into the newly created Software\nTechnology\nBranch\n(STB).\nThe STB\'s\nreengineering\nhistory has put JSC in a better\nposition with respect to the maintainability of its\nolder software than many other organizations. The\npositive results of this experience\ninclude the\nfollowing:\n-\n\nIn the1970\'s,\nMPAD\nperformeda lotof software\nreengineering\ntomeet thegoalofcombiningmany\nof the independently developed engineering\nprograms, each with its own input/output formats.\nMany of the modern concepts such as separation\nof input/output\nprocessing from the applications,\ndatabases,data structures,\npackages,generics,\nobjects,\netc.were recognizedand simulatedto\nsome degree.They were notcalled themodem\nby\nnames, of course,but thedesignengineers\nwere\n431\n\nMost of\nmodular.\n\nthe\n\nsoftware\n\nis\n\n-\n\nreasonably\n\nThe data has some structure.\nMost of the software at JSC is reasonably\ncompatible with the STB\'s tools, including\nthe in-line documentation.\nThe large complex programs that support\nmany simulations\nhave considerable\nsoftware reuse and information sharing.\n\nMAINTENANCE\n\nSTRATEGIES\n\nNew\n\nFORTRAN\n\nNew\n\nstandards,\n\nThe strategies\npresented\nin this document\nare\nintended to help with design recovery in support of\nprogrammer/analysts\nwho are required to maintain\nlarge FORTRAN\nprograms\nthat they did not\ndevelop.\nIn addition, these strategies are intended\nto support\nreengineering\nof existing\nFORTRAN\ncode into modem software engineering\nstructures,\nwhich are then easier to maintain\nand which allow\na fairly straight forward translation\ninto other target\nlanguages.\nThe STB is proposing\nstandards,\nmethods,\nand an integrated\nsoftware environment\nbased upon the significant\nset of tools built to\ndevelop\nand maintain\nFORTRAN\ncode for the\nSpace Shuttle. [4,5,6,7,8]\nThe environment\nwill\nsupport these structures and practices even in areas\nwhere the language definition and compilers do not\nenforce good software engineering\npractices.\n\nTable\n\nmodem\n\nsoftware\n\ntogether\nas virtual packages,\ndata s.tl"ucturing, and\ninput/output\nencapsulation\nin\nseparate\nsubprograms.\nWhere\nFORTRAN\n77 does not\nprovide\nthe constructs,\nvirtual\nconstructs\nare\nprovided\nalong with a tool environment\nto support\ntheir development\nand maintenance.\nThe existing\ncore of FORTRAN\nprogrammers\nshould have little\nproblem\nwith the standards\nand new FORTRAN\ncode should adhere to them from the start.\nSummary\n\nBenefit\n\nbefore\n\ncode blocks\n\nVirtual p_ka8e\nidentification\nLonger, more meartin_ul\nvariable\nModem control flow structures\nBlock I30\nDO WtmJE\n\nnames\n\nGrouping\nsubprograms\ninto virtual packages\nData structunng\nPreferred\nuse of calling parameters\nControlled\nuse of COMMON\nblocks\n\nDesign\nRecovery\nMethodology\n\nallow\n\nby the former MPAD and still in use in the mission\nplanning\nand analysis\ndomain.\nThe goal of the\nnew standards\nis to improve\nmaintainability\nand\npermit relatively\nautomated\ntranslations\nto newer\nlanguages.\nIn table\n1, the standards\nand their\nbenefits are summarized.\nThese standards address\ndocumentation,\nlonger\nvariable\nnames,\nmodem\ncontrol\nflow structures,\ngrouping\nsubprograms\n\n1. Standards\n\nRequirements\nin CD1 statements\nRationale in CD7 statements\n\nPreferably\nencapsulate\nseparate subpro_\'arns\n\nwhich\n\nengineering\nconstructs\nto be used in FORTRAN\n77, have been defined\nby the STB. [5]\nThese\nstandards\nare added to existing\nstandards\ndefined\n\nStandard\nDocumentation\nHeader statement\n\nStandards\n\ninput/output\n\nand\n\nin\n\nUnderstandability\nUnderstandability\nDesign knowledge\nMaintenance\n\nand traceability\ncapture\n\nI Understandability\nMaintenance\nand understandability\n\n!\n\nHi_her\n\nlevel of abstraction,\n\nunderstandability\n\nMaintenance\n\nMaintenance\nINCLUDE\nCOMMON\ndatabase concept\nMaintenance\nand support to future\nconversions\n\nThe re.engineering\nmethodology\ndefines the steps,\nthe skills required,\nand guidelines\non how far to\nreverse\nengineer\nbefore deciding\nto rebuild.\nThe\nkey goal is to update to modem\ntechnology\nand\n\nReengineering\n\n432\n\nsoftware\nengineering\nconcepts\nwithout\nlosing\nrexiuired functions and data. Methods are provided\nthat have the flexibility\nto meet multiple levels of\nconversion,\neach\nof\nwhich\nimproves\nmaintainability.\nFigure 3 illustrates five methods.\n[6] Method\n1 converts\nan arbitrary\nFORTRAN\nprogram\nto COMGEN-compatiblc\nFORTRAN,\nwhich\nprovides\nin-line\ndocumentation,\ndata\nstructure,\nand unique\ndata names\nwithin\na\nCOMMON\nstructure. Method 2 converts\nsoftware\nalready\nin this format\nto the new "standard"\nFORTRAN\nwith a more Ada-like structure that is\n\nready for a mostly\nautomated\ntranslation\nby\nMethod\n3 to a target\nlanguage\nthat embeds\nsoftware\nengineering\nprinciples.\nAlternatively,\nCOMGEN-compatible\nprograms can be converted\ndirectly to a target language\nlike Ada by Method 4.\nAlthough\nit is easier\nto convert\na FORTRAN\nprogram when the code already meets the standard\nCOMMON\nconcept,\ncommonly\nknown\nas\nCOMGEN-compatible,\narbitrary\nFORTRAN\ncan\nbe directly\nconverted\nto a target language\nby\nMethod 5.\n\ncanterminate\natanyof thestates\nFigure\n\nEnvironment\nto\nand Reengineering\n\nSupport\n\nDesign\n\n3. Reengineering\n\nRecovery\n\nMethods\n\nresponse\nto feedback\nfrom the programmers/\nanalysts.\nCurrently\nseveral groups\nat JSC are\nusing the tools.\nSeveral\ntools, both COTS and\ncustom-built,\nare available for C language support.\n\nThe STB\'s reengineering\nenvironment\n[7] is being\nbuilt\naround\nthree\ncomponents:\nstandards,\nmethods,\nand tools that support the standards and\nthe methods.\nIt contains\nmodified\nversions of the\n\nThe environment\nhas been designed\nwith stable\ninterfaces\ndefined\nto provide for the maximum\nfeasible\ndegree\nof seamless\nintegration.\nIt is\ndoubtful\nthat COTS\ntools\ncan be integrated\nseamlessly\ninto the environment\nas no standard\ninterfaces have yet been established\nfor either user\ninterface\nor data interface\n(as opposed\nto data\nexchange).\nThe tools are integrated\nat the front\nend by a user interface and behind\nthe screen by\ntwo logical databases,\none containing\ndata passed\nto and from the tools and the other containing\nthe\n\ntools used to support the current JSC FORTRAN\nprograms plus commercial\noff-the-shelf\n(COTS)\ntools and additional custom-built\ntools. The intent\nis to get an environment\nout into use in JSC\'s\nmaintenance\ncommunity\nto provide support for\nupgrading\nFORTRAN\nprograms\nin terms of\nmaintainability\nin the near-term, then to extend the\nfunctionality\nof the tool set and environment\nin\n433\n\noriginal\nfigure\n\nand modified\nsource\n4.\nCASE\nframework\n\nFigure\n\n4. Conceptual\n\ncode as shown in\ntools are being\n\nArchitecture\n\nevaluated\n\nof the Design\n\nThe environment\nwill\nnot be a completely\nautomated environment\nsince much work will still\n\nRecovery\n\nas possible\n\nintegration\n\nand Reengineering\n\nmechanisms.\n\nEnvironment\n\nplans and design\nof REAP\nare such, that\nall\ndeliveries\ncontaining\nCOTS\nproducts\nwill be\ntailorable\nso that users can delete the COTS tools\nthat they do not want to license. This policy even\nincludes\nthe framework\nintegration\ntools. In most\ncases, similar functions\nmight still be available\nbut\nthey would have less capability.\n\nhave to be done by a programmer/analyst.\nA\nperson must be in the loop to provide the required\npuzzle-solving\nskills\nthat\nare\nbeyond\nthe\ncapabilities\nof\nstate-of-the-practice\ntools.\nHowever,\nas an experience\nbase is accrued\nin\ndesign\nrecovery\nand reengineering,\nknowledgebased capabilities\ncan be added to the environment.\n\nCONCLUSIONS\nVersion 1 of the environment\ncalled REengineering\nAPplications\n(REAP) was delivered\nin June, 1991.\nThis integrated\nall existing\nJSC supported\ntools\ndiscussed\nabove, behind a common\nuser interface\nbuilt on the MOTIF\nstandard.\nIt contains\nmajor\nelements\nof all subsystems\nand encapsulates\nthe\ncapabilities\nthat have been developed\nand used at\nJSC during the last fifteen years. A version\nwith\nimproved\ntool\nintegration,\nuser\ninterface\nenhancements,\nand the commercial\nLOGISCOPE\ntool\nwas\ndelivered\nin October,\n1991.\nThe\nFORTRAN\ndesign recovery version was delivered\nin February,\n1992. In parallel,\nthe study of using\nCASE framework\nstandards\nand tools to better\n\nJSC has a large amount\nof existing\ncode\nin\nFORTRAN\nthat embodies\ndomain knowledge\nand\nrequired\nfunctionality.\nThis\ncode\nmust\nbe\nmaintained\nand eventually\ntranslated\nto more\nmodern\nlanguages.\nThree\nprimary\nalternative\nsolutions\nhave been identified\nto address\nthe\nmaintenance\nproblems\nof these old FORTRAN\nprograms:\ncomplete\nredevelopment\nof the\nprograms,\ncode translation\nto a more\nmodern\nlanguage\nor\nversion\nof\na language,\nand\nreengineering.\nComplete\nredevelopment\nis\neffective\nbut very costly.\nSimple code translation\nis cheap, but usually ineffective\nsince seldom do\nthe old systems\nincorporate\nmodern\nsoftware\nengineering\nconcepts\nsuch\nas\ngood\ndata\n\nintegrate\nand manage this environment\nshould be\ncompleted\nearly in 1992 and the version\n2 series\nwill be delivered\non one of these platforms.\nThe\n434\n\nstructuring, good control structuring, packages,\nobjects, etc., that should be presentin the new\nsystem.\nModern\nlanguages\nconstructs\nfor representing\ntranslators cannot determine\n\na lower cost than for complete\nredevelopment\nof\nthe program.\nA useful\nenvironment\nfor\nreengineering\nFORTRAN\nsoftware\ncan be built\nfairly\nquickly\nby building\nupon the existing\nFORTRAN\ndevelopment\nand maintenance\ntools,\nCOTS products,\nnew software\nand hardware\ntechnologies,\nplus current research\ninto reuse,\ndesign\nrecovery,\nand reengineering.\nThis\nenvironment\nwill support reengineering\nexisting\nFORTRAN\ncode into more maintainable forms that\n\nsuch as Ada have\nthese features,\nbut\nthese features in the\n\noriginal code to map them into the new system.\nReengineering\nis being recognized\nas a viable\noption\nbecause\nthe old systems,\nin spite of\nobsolete technology,\ndo contain all of the required\nfunctionality\nand can get the job done. However,\nat the present time there are only a few expensive\nComputer\nAided Software\nEngineering\n(CASE)\ntools and no total system environment\navailable in\nthe COTS\nmarket\nto support\nreengineering\nFORTRAN\nprograms.\n\ncan also be readily\ntranslated\nlanguage including newer versions\nTwo versions\n\nof the environment\n\ninto a modern\nof FORTRAN.\nwere delivered\n\nin\n\n1991 which integrate the existing\nJSC tools plus\nthe commercial\nLOGISCOPE\ntool behind\na\ncommon\nOSF MOTIF-like\nuser interface.\nA\nFORTRAN\ndesign\nrecovery\ncapability\nwas\ndelivered\nin\nFebruary\n1992.\n\nThe\nSTB\nmaintenance\nstrategies\nprovide\nstandards,\nmethods,\nand a tool environment\nfor\nupgrading\ncurrent FORTRAN\nsystems\nwithout\nlosing the embedded engineering knowledge\nand at\n\nGLOSSARY\narbitrary\n\nFORTRAN\n\nexisting\ncomponents\ninterface,\nmanagement\ntool set.\n\nFORTRAN\nprogram that is\nnot compatible\nwith the\nCOMGEN\nstandards\nlong\nin place for JSC\'s mission\nplanning\nand\nanalysis\ndomain.\n\ntools;\ninclude\n\nusual\na user\nobject\nsystem,\nand a\n\nFORTRAN\nCOMGEN-compatible\n\ndesign\n\nrecovery\n\nenvironment\n\nframework\n\nOLrrent ANSI\nfor FORTRAN\n\nstandards\n\nFORTRAN\n\nFORTRAN\nprogram\nthat is compatible\nwith the\nCOMGEN\nstandards\nlong\nin place for JSC\'s mission\nplanning\nand\nanalysis\ndomain. [1]\n\n77\n\n90\n\nFuture ANSI\nFORTRAN.\n\nstandards\n\nforward engineering\n\nProcess\nof\ndeveloping\nsoftware\nfrom\n"scratch,"\nthrough\nthe\nphases\nof\nrequirements,\ndesign,\nand\ncoding.\n\npackage\n\n"A collection\nof logically\nrelated\nentities\nor\ncomputational\nresources"\n(Booch[9]).\n\nreengineering\n\n"The\nexamination\nand\nalteration\nof\na subject\nsystem to reconstitute it in a\nnew\nform\nand\nthe\n\nReverse\nengineering,\nthe\nfirst step for maintenance\nor\nre,engineering.\nInstantiation\nof\na\nframework,\ni.e.,\nan\nintegrated\ncollection\nof\ntools.\nIt may support one\nor more methodologies\nand\nmay\nalso\nprovide\na\nframework\nfor third party\ntools.\nSoftware\nsystem\nintegrate\nboth the data\nthe control\nof new\n\nfor\n\nsubsequent\nof\nthe\n\nto\nand\nand\n\n(Chikofsky\n435\n\nimplementation\nnew\nform"\nand\n\nCross\n\n[10]);\nreverse\nforward\n\ncombination\nengineering\nengineering.\n\nof\nand\n\nsoftware\ncycle.\nsoftware\n\nreverse\n\nengineering\n\n"The process of analyzing\na\nsubject system to identify\nthe system\'s\ncomponents\nand their interrelationships\nand create representations\nof the system\nin another\nform or at a higher level of\nabstraction" (Chikofsky\nand\nCross [10]); the first step of\nmaintenance\nor\n\nmaintenance\n\nsubject\n\nprogram\n\nvirtual\n\npackage\n\nreengineering;\nreverse\nof\nforward\nengineering;\nprocess\nof starting\nwith\nexisting\ncode\nand going\nbackward\nthrough\nthe\n\nProcess\nexisting\nsoftware\nprimary\n(Boehm\nProgram\nmaintained\n\ndevelopment\n\nlife\n\nof\n\nmodifying\noperational\nwhile leaving\nits\nfunctions\nintact\n[11]).\nthat\nis being\nor re.engineered.\n\nPackage concept\nas defined\nby\nBooch\n[9],\nbut\nimplemented\neither in Ada,\nwhich enforces\nthe concept,\nor in a language\nin which\nthe\nconcept\nmust\nbe\nsupported\nprocedurally.\n\nREFERENCES\n[1]\n\n[2]\n\n[7]\n\n[3]\n\n[4]\n\n[5] Braley,\n\nDennis:\nMaintenance\nStrategies\nfor\nDesign\nRecovery\nand\nReengineering:\nFORTRAN\nStandards.\nVolume\n2. NASA\nJohnson\n1990.\n\n[6]\n\nSpace\n\nCenter\n\n(Houston,\n\nTX),\n\nwith Ada.\nCo., Inc.\n\nChikofsky,\nE. J.; and Cross\n"Reverse\nEngineering\nand Design\nA Taxonomy."\nIEEE\nSoftware,\n1990.\n\nII, J. H.:\nRecovery:\nJanuary\n\n[11]\n\nFridge HI, Ernest: Maintenance\nStrategies for\nDesign\nRecovery\nand\nReengineering:\nExecutive\nSummary\nand Problem\nStatement.\nVolume\n1. NASA\nJohnson\nSpace\nCenter\n(Houston,\nTX), June 1990.\n\nBooch, G.: Software\nEngineering\nBenjamin/Cummings\nPublishing\n(Menlo Park, CA), 1983.\n\n[10]\n\nBraley,\nDennis:\nSoftware\nDevelopment\nand\nMaintenance\nAids Catalog. NASA IN 86-FM27, NASA\nJohnson\nSpace Center (Houston,\nTX), October\n1986.\n\nGeorge, Vivian; and Plumb, Allan: A Method\nfor Conversion\nof FORTRAN\nPrograms.\nBarrios\nTechnology,\nInc. (Houston,\nTX),\nMarch 1990.\n\n[9]\n\nBraley,\nDennis:\nAutomated\nSoftware\nDocumentation\nTechniques.\nNASA Johnson\nSpace Center (Houston,\nTX), April 1986.\n\nBraley,\nDennis;\nand\nPlumb,\nAllan:\nMaintenance\nStrategies\nfor Design Recovery\nand\nReengineering:\nConcepts\nfor\nan\nEnvironment.\nVolume\n4. NASA\nJohnson\nSpace Center (Houston,\nTX), June 1990.\n\n[8]\n\nBraley,\nDennis:\nComputer\nProgram\nDevelopment\nand Maintenance\nTechniques.\nNASA IN 80-FM-55,\nNASA Johnson\nSpace\nCenter (Houston,\nTX), November\n1980.\n\nBoehm,\nEconomics.\nNJ), 1981.\n\nJune\n\nBraley,\nDennis;\nand\nPlumb,\nAllan:\nMaintenance\nStrategies\nfor Design Recovery\nand Reengineering:\nMethods.\nVolume\n3.\nNASA Johnson Space Center (Houston,\nTX),\nJune 1990.\n436\n\ni\n\n1\n\n.\n\nr\n\nB. W.: Software\nEngineering\nPrentice-Hall\n(Englewood\nCliffs,\n\n'