b'4th NASA Symposium on VLSI Design 1992\n\nN94"21\xc2\xabl"\n\n6.5.1\n\nInstruction Set Commutivity l\nP. Windley\nLaboratory for Applied Logic\nDepartment of Computer Science\nUniversity of Idaho, Moscow, Idaho 83843\nAbstract- We present a state property called congruence and show how it can\nbe used to demonstrate commutivity of instructions in a modern load\xe2\x80\x94store architecture. Our analysis is particularly important in pipelined microprocessors\nwhere instructions are frequently reordered to avoid costly delays in execution\ncaused by hazards. Our work has significant implications to safety and security\ncritical applications since reordering can easily change the meaning and an instruction sequence and current techniques are largely ad hoc. Our work is done\nin a mechanical theorem prover and results in a set of trustworthy rules for instruction reordering. The mechanization makes it practical to analyze the entire\ninstruction set.\n\n1\n\nIntroduction.\n\nInstruction pipelining 2 is critical to good performance in modern microprocessors. Almost\nevery microprocessor developed in the last several years contains an instruction pipeline. Significant attention has been given to the development of scheduling algorithms to reduce the\nthe occurrence of pipeline hazards because of the performance degradation that they cause.\nTypically, scheduling involves reordering the instruction stream produced by a compiler.\nThe approaches to code reordering are largely ad hoc with little or no analysis showing\nwhether the rules are correct and under what conditions they should be avoided. Indeed,\nwhen asked about the rules that he gave for avoiding semantic changes one researcher, who\ndeveloped the code scheduling algorithms for the C compiler in a widely available commercial\nUNIX system, stated "Its all ad hoc. It never occurred to me that there might be any other\nway to do it."\nClearly, the current approach to code scheduling is unacceptable in safety and security\ncritical applications. On one hand, modern pipelined architectures perform poorly without\nthe aid of a compiler that is smart enough to reschedule code to avoid pipeline hazards.\nOn the other hand, the reordering that the scheduler performs has the potential to initiate\nsemantic changes in the code stream. We must either give up performance or live with\nuntrustworthy code. Neither of these approaches is satisfactory.\nThis paper describes the analysis of a microprocessor instruction set for commutivity.\nWe are interested in establishing, by analysis, under what circumstances the instructions\ncan be reordered while avoiding semantic changes. The next section describes related work\nand the following sections present our analysis.\nJ\n\nThis work was sponsored by the Department of Defense under University Research Program contract\nNo. MDA904-91-C-7054\n2\nSee [HP90] for an excellent introduction to pipelining and pipeline hazards.\n\n6.5.2\n\n2\n\nRelated Work\n\nThe formal analysis of code reordering is related to at least three active areas of research: microprocessor verification, compiler verification, and the automatic generation of optimizers.\nThis section discusses these three areas of research and relates them to the work presented\nin this paper.\nMicroprocessor Verification There have been numerous efforts to verify microprocessors. These efforts have been mostly for research purposes and none have included any kind of\nanalysis of their instruction sets regarding code reordering. Only one formally verified general\npurpose microprocessor has been fabricated and it has so few features as to be impractical\nfor real use. Descriptions of these efforts can be found in [Coh88, Joy89a, Joy88, Hun89). It\nis important to note that none of these projects involved verification of a pipelined processor.\nIn [SB90], Srivas et al. describe the formal verification of a pipelined microprocessor called\nMini Cayuga, comparable in complexity of design to that of Hunt\'s FM8501. However, the\nstructure and behavior of the pipeline were hidden from the abstract specification. Only\nprefetching of the next instruction was incorporated into the specification. This precluded\nthe possibility of formally reasoning about pipeline hazards and instruction scheduling.\nWe are designing, specifying, and verifying a microprocessor called AVM-2. AVM-2 has\na load store architecture and will be pipelined. The architecture of AVM-2 is largely the\nsame as that of AVM-1, but the design is substantially different. We described early results\nof this research in [Win91] where we demonstrated the integrity of the supervisory mode of\nAVM-1. In this paper, we describe results regarding instruction set commutivity for AVM-2.\nCompiler Verification There has been much work on verified compilers. Space considerations do not present a full treatment here. Joyce [Joy89b] gives an excellent review. Most of\nthe early work [Rus77, CohSO, CM86] on the compiler correctness problem used idealizations\nof the hardware. Recent work by Joyce [Joy89b], Moore [Moo88], and Young [You89] have\nlooked at compiler verification under the constraints of a real instruction set. None of these\nefforts has addressed code reordering although Young states that initial work on an optimizer has begun. Even so, our approach is different from Young\'s due to the nature of the\nspecification. The specifications in Young\'s work are operational while ours are denotational.\nOptimizer Generation Current approaches to instruction scheduling is largely ad hoc.\nCurrent compiler technology utilizes rule-based, heuristic algorithms for optimizing code\nsequences. Representative of the state of the art, the IBM RISC System/6000 XL compiler\nfamily uses special flags associated with opcodes to indicate instructions which are "dangerous" to move [War90, War92]. To date, there has not been any published results describing\nthe application of formal methods to pipeline scheduling.\nThere has been some work on the automatic generation of optimizers from specifications\nof one sort or another.\nIn [Kes84], Kessler describes a tool called Peep. Peep is an architectural description\ndriven peephole optimizer. The description of the architecture, given in LISP, is used to\ngenerate a table of optimizable instructions that can be used in a an optimizing compiler.\n\n4th NASA Symposium on VLSI Design 1992\n\n6.5.3\n\nIn [DF84], Davidson and Fraser present a system that generates peephole optimizations\ncalled PO. PO uses productions which describe the effect of assembly language instructions\nin a simulator to determine substitutions for 2 and 3 assembly instruction sequences.\nWhile this work is interesting and related to the work presented here, these efforts differ\nin several important ways:\n\xe2\x80\xa2 The descriptions used for generating optimizations are not related to the implementation in anyway. Our work uses a specification that is related through proof to the\nimplementational specification.\n\xe2\x80\xa2 It is not clear whether or not any kind of theory underlies the generation of the optimizers. As we will show later, there are concepts regarding reordering that can be\ngeneralized and used as a basis for reasoning about reordering.\nv\n\n\xe2\x80\xa2 it is not clear how much faith can be placed on the simulation used to determine\nequivalent sequences. Our work will be done in a widely accepted theorem proving\nenvironment.\n\n3\n\nAVM-2\n\nWe have designed a computer designated AVM-2 (A Verified Microprocessor). AVM-2 is a\nsecond generation design that will be implemented in CMOS. The design, specification, and\nverification of AVM-1, the predecessor to AVM-2, are given in [Win90] where it is used as\nan example to demonstrate the utility of generic models in hardware verification. AVM-2,\nlike AVM-1, will feature a RISC-like instruction set and a large register file. Unlike AVM-1,\nAVM-2 will have a pipelined implementation.\nThe Registers. AVM-2 has a load-store architecture based on a large register file. The\nregister file is divided into seven supervisor-mode registers and twenty-four general purpose\nregisters.\nTwo additional registers are visible at the architectural level: the program counter and the\nprogram status word. The program counter (denoted pc) is used to sequence the computer\xe2\x80\x94\nit indicates which instruction in memory to execute next. The program status word (denoted psw) is used to keep track of the status of the last ALU operation, whether or not\ninterrupts are enabled, and the privilege level of the CPU.\nThe Instruction Set. AVM-2 has 30 programming level instructions. There is a group of\neight, 3-argument (source A, source B, and destination) arithmetic and logical instructions\nand another group of 8 arithmetic and logical instructions that use two arguments and a\n16-bit immediate value. There are 4 instructions for loading and storing registers. Only the\nload and store instructions communicate with memory. In addition, there are instructions\nfor performing user interrupts, jumps, subroutine calls, and shifts.\n\n6.5.4\n\n4\n\nInstruction Set Specification\n\nThe instruction set for AVM-2has been formally specified as part of the design process. The\nspecification represents a denotational description of the machine language. In this section,\nwe present several of the state transition functions representing instructions. These examples\nwill be used in later sections describing the analysis.\nThe instructions are modeled by state transition functions. In general, each function\noperates on a state tuple and an environment tuple. The state tuple, contains variables\nrepresenting the register file, reg, the program status word, psw, the program counter, pc,\nand the memory, mem. The environment tuple contains variables representing the interrupt\nvector, ivec, the interrupt line, int, and the reset line, reset. Each function returns a state\ntuple updated to reflect the behavior of the instruction being modeled.\nThe NOOP instruction updates the state tuple by incrementing the program counter. No\nother actions are performed.\n\\~ de j NOOP (reg, psw, pc, mem)\n(ivec, int, reset) =\nlet new^pc = inc pc in\n(reg, psw, new_pc, mem)\n\nNote that NOOP is not an identity function, although it is often thought of that way. The\nfact that NOOP does affect the state and resides in memory affects its commutivity.\nOther instructions are quite a bit more complicated than the NOOP instruction. For\nexample, the ADD instruction is shown below:\n\\~def ADD (reg, psw, pc, mem)\n(ivec, int, reset) =\nlet a = EL (GetSrcA pc mem) reg and\nb = EL (GetSrcB pc mem) reg and\nd = GetDest pc mem in\nlet result = add (a, b) in\nlet cflag = addp (a, b, result) and\nvilag = aovfl (a, b, result) and\nnflag = negp result and\nzilag = zerop result and\nsm\n= get_sm psw and\nie\n= get_ie psw in\nlet new_reg = UPDATE_REG psw d reg result and\nnew.psw = mk_psw(sm, ie, vilag,\nnflag, cflag, zflag) and\nnew_pc = inc pc in\n(new_reg, new_psw, new_pc, mem)\n\nThe ADD instruction updates every member of the state tuple except the memory. The\nprimary action, summing two registers and updating the register file accordingly is reflected\nby the updated register file, reg. The instruction also calculated new values for the overflow,\ncarry, negative, and zero flags of the program status word, psw. The supervisory mode bit\n\n4th NASA Symposium on VLSI Design 1992\n\n6.5.5\n\nFigure 1: State Congruence\nand the interrupt enable bit remain unchanged, as expected. The program counter, pc is\nincremented.\n\n5\n\nState Congruence\n\nOur notion of state correspondence is motivated by the denotational description of the instruction set. Because the specification is denotational, we are interested in showing that\nstate transitions made by one sequence of instructions are equivalent to the state transitions\nmade by another sequence of instructions.\nUnfortunately, the instructions sequences themselves are part of the state and so we\ncannot use equivalence as the relation between states. Instead, we relate the states using\na property we call congruence. We call this relationship congruence because the states are\nequivalent except for (i.e. modulo) the ordering of the instruction sequences in memory.\nFigure 1 illustrates congruence. As the figure shows, we start with two states, SI and\nS2, which are related by the relation p. After they have been transformed by a sequence of\ninstructions, we are left with two modified states SI\' and S2\'. Ideally, these new states are\nstill related by /?, but as we will see in Section 5.2, this is not always the case and so we show\nthem related by p\'.\nThe primary congruence relation that we use in the examples is given by the following\npredicate:\n\n6.5.6\n/ Congruent loc (regl.pssl,pel,meml)\n(reg2,psw2,pc2,mem2) =\n(regl=reg2) A (pswl=pss2) A (pcl=pc2) A\n(V a . ->(a = address loc) A\n-i(a = address (inc loc)) =>\n(fetch (meml.a) = fetch (meml.a))) A\n(fetch (meml,address loc) =\nfetch (men2,address (inc loc))) A\n(fetch (mem2,address loc) =\nfetch (meml.address (inc loc)))\n\nThe predicate operates over a location and two state tuples. We say that the state tuples are\ncongruent if their register files, regl and reg2, program status words, pswl and psw2, and\nprogram counters, pel and pc2, are the same. Additionally, we require that the memories,\nmeml and mem2 be the same except that the words located at loc and loc+1 in meml are\nswapped in mem2.\n\n5.1\n\nSwapping NOOP\n\nTo start with, we examine the cornmutivity of the NOOP instruction. While this may seem\nlike a trivial problem, the problem is not as straightforward as it seems since NOOP does\naffect the state. Also, the difficulties encountered in NOOP cornmutivity are typical of other\ncornmutivity proofs.\nThe following theorem shows that NOOP can be commuted with any instruction that does\nnot modify memory or alter program flow:\nh let si = (regl,pssl,pel,meml) and\ns2 = (reg2,psv2,pc2,mem2) and\ne = (ivec.ireq,reset) in\nV inst.\n\n(inst = macro_inst (Opcode si e)) =*\xe2\x80\xa2\nCongruent pc2 si s2 A\nHOH_MEM_IHST (Opcode si e) ^\nlet si\' = (NOOP (inst si e) e) and\ns2\' = (inst (HOOP s2 e) e) in\nCongruent pc2 si\' e2\'\n\nWe assume that the environment does not change during execution of the two instructions\n(e, representing the environment, is used as an argument for both of them). The theorem\nstates that for every instruction in the instruction set, if the initial states are congruent the\nmodified states are also congruent.\nThe theorem is not true for instructions that alter flow control because the NOOP would\nnever execute in one case and some other instruction would execute in its place. For instructions that modify memory, we can prove a more restricted version that assumes that the\nmemory instruction does not interfere with the program (instructions and data are stored in\nthe same memory). We will see an example using a non-interference condition in the next\nsection.\n\n4th NASA Symposium on VLSI Design 1992\n\n5.2\n\n6.5.7\n\nSwapping Arithmetic Instructions\n\nThe arithmetic instructions of AVM-2 that do not use the carry flag commute under weak\ncongruence. Weak congruence is the same as strong congruence (denned above), except that\nit does not require equivalence for the entire program status word. Rather we require only\nthat the supervisory mode bit and the interrupt enable bit be the same. Most instructions\nthat modify the overflow, carry, negative, and zero flags of the program status word do so\nwithout regard to their previous values, so the value of the two program status words cannot\nbe equal.\nWeak_Congment loc (regl,pswl,pcl,meml)\n(reg2,pss2,pc2,mem2) =\n(regl = reg2) A\n(pel = pc2) A\n((get_sm pswl) = (get_sm psw2)) A\n((get_ie pswl) = (get_ie psw2)) A\n(V a . ->(a = address loc) A\n-i(a = address (inc loc)) =>\n(fetch (meml,a) = fetch (mem2,a))) A\n(fetch (meml,address loc) =\nfetch (mem2,address (inc loc))) A\n(fetch (mem2,address loc) =\nfetch (meml,address (inc loc)))\n\nIn order to commute two arithmetic instructions, we require that they be non-interfering.\nThat is, the destination registers cannot be the same as the source registers. For example,\nthe following instructions do not commute:\n\na := b + c\nd := a + e\nSince the second instruction uses the value computed in the first, we cannot swap them\nwithout changing the resulting state. In addition, we require that the destination registers\nbe different. The following predicate defines the non-interference property in terms of the\nfunctions used by the instruction set definition to retrieve the source and destination register\nindices from memory.\nt-<ie/ Non_Interf ering pc\n-i(GetSrcA (inc pc)\n->(GetSrcB (inc pc)\n-\xe2\x80\xa2(GetDest (inc pc)\n\nmem =\nmem = (GetDest pc mem)) A\nmem = (GetDest pc mem)) A\nmem = (GetDest pc mem))\n\nUsing the weak congruence predicate and the non-interference predicate, we can show,\nfor example, that ADD and SUB commute:\n\n6.5.8\nlet si = (regl,pswl,pcl,meml) and\ns2 = (reg2,psw2,pc2,mem2) and\ne = (ivec.ireq,reset) in\nCongruent pc2 si s2 =>\nNon_Interfering pel meml A\nNon.Interfering pc2 mem2 =>\nlet si\' = (ADD (SUB si e) e) and\ns2\' = (SUB (ADD s2 e) e)) in\nWeak_Congruent pc2 si\' s2\'\n\nNote that we use strong congruence in the assumptions, but can only show weak congruence\nbetween the resulting states.\nWe have presented only two theorems regarding instruction commutivity in AVM-2. We\ncan prove more general theorems about the commutivity of arithmetic instructions. We can\nalso show arithmetic instructions commute with load and store instructions provided they\nare non-interfering.\n\n6\n\nDiscussion\n\nWe have presented only a few small theorems regarding the analysis of the A VM-2 instruction\nset. A more thorough analysis is presently underway. Even so, we believe the results to be\ninteresting.\nThe fact that we can only show weak congruence when commuting arithmetic instructions\nis a function of the design of the instruction set. Other instruction sets would provide\ndifferent results. The contribution of formal analysis is that this property is clearly and\nunambiguously stated in the resulting theorem.\nAlso, the weak congruence result affects when we can actually commute arithmetic instructions in a program. We cannot, for example, commute two arithmetic instructions\nthat are followed by a conditional jump since the values of the flags are changed. Strong\ncongruence is required to maintain the program meaning in this case.\nWe should note that our initial efforts in this area have had an affect on the architecture of\nA VM-2. In light of the results presented here regarding weak congruence, we have undertaken\na modification of the instruction set semantics so that arithmetic instructions commute under\nstrong congruence. This will allow greater freedom in code reordering to avoid pipeline\nhazards.\nCertainly none of our specific discoveries regarding the A VM-2 instruction set will surprise veteran compiler writers. The rules that we have demonstrated for code reordering\nin the AVM-2 instruction set are well known. What is important, however, is that we are\nnot veteran compiler writers. Analysis allowed us to show that they were correct rather\nthan relying on years of experience and intuition. This, it seems, is the heart and soul of\nengineering [ShaQO].\n\n4th JVASA Symposium on VLSI Design 1992\n\n7\n\n6.5.9\n\nFuture Work\n\nWe plan to extend our analysis of commutivity to explore code motion for larger code\nfragments. Our intent is to automate a complete analysis of instruction commutivity for\nall instruction pairs and use these results to determine when large instruction sequences are\ncongruent.\nAs mentioned earlier, the behavioral specification of AVM-2 will be verified against its\nimplementation. Because of the hierarchical nature of the specification (see [Win90]), the\nphase-level mode of the pipeline will have a similar structure to the behavioral model of\nthe top-level. We believe that the techniques demonstrated in this paper will allow us to\nperform an analysis of the pipeline to identify hazards. This work is underway.\n\n8\n\nConclusion\n\nThis paper has presented examples from an analysis of commutivity in a modern instruction\nset. Commutivity is start at a more general notion of instruction reordering that in important\nto both compiler optimizations and pipeline scheduling. Analysis of instruction set reordering\nis important in both safety and security critical applications because of the danger ad hoc\napproaches present to the semantic integrity of the instruction stream.\nOur analysis could have been performed without the benefit of a formal specification of\nthe instruction set or a formal statement of the desired properties. However, the formal\nanalysis has several benefits:\n\xe2\x80\xa2 The theorems about commutivity form a set of rules for commuting instructions. These\nrules have a demonstrated correctness.\n\xe2\x80\xa2 The formal analysis was helpful in finding interferences between instructions that were\nnot immediately obvious.\n\xe2\x80\xa2 The assumptions and results are unambiguously stated and can be used for further\nreasoning about optimization and scheduling.\n\xe2\x80\xa2 In providing a set of rules about commutivity, the instructions must be analyzed on\na case-by-case basis whether the analysis is done by hand or automated. The formal\nanalysis provides a tool for quickly analyzing the instructions.\n\nReferences\n[CM86] Laurian M. Chirica and David F. Martin. Toward compiler implementation correctness proofs. ACM Transactions On Programming Languages And Systems,\n8:185-214, April 1986.\n[CohSO] Avra Cohn. Machine Assisted Proofs of Recursion Implementation. PhD thesis,\nUniversity of Edinburgh, April 1980.\n\n6.5.10\n[Coh88] Avra Colin. A proof of correctness of the VIPER microprocessor: The first level.\nIn G. Birtwhistle and P. Subrahmanyam, editors, VLSI Specification, Verification,\nand Synthesis, pages 27-72. Kluwer Academic Publishers, 1988.\n[DF84]\n\nJack W. Davidson and Christopher W. Fraser. Automatic generation of peephole optimizations. In ACM SIGPLAN 84 Symposium on Compiler Construction.\nACM, June 1984.\n\n[HP90]\n\nJohn L. Hennessy and David A. Patterson. Computer Architecture: A Quantitative\nApproach. Morgan Kaufmann Publishers Inc., 1990.\n\n[Hun89] Warren A. Hunt. Microprocessor design verification. Journal of Automated Reasoning, 5:429-460, 1989.\n[Joy88] Jeffrey J. Joyce. Formal verification and implementation of a microprocessor. In\nG. Birtwhistle and P.A Subrahmanyam, editors, VLSI Specification, Verification,\nand Synthesis. Kluwer Academic Press, 1988.\n[Joy89a] Jeffrey J. Joyce. Multi-Level Verification of Microprocessor-Based Systems. PhD\nthesis, Cambridge University, December 1989.\n[Joy89b] Jeffrey J. Joyce. Totally verified systems: Linking verified software to verified hardware. In Miriam Leeser and Geoffrey Brown, editors, Proceedings of the Mathematical Sciences Institute\'s Workshop on Hardware Specification, Verification, and\nSynthesis, July 1989.\n[Kes84] Robert R. Kessler. Peep\xe2\x80\x94an architectural description driven peephole optimizer.\nIn ACM SIGPLAN 84 Symposium on Compiler Construction. ACM, June 1984.\n[Moo88] J. Strother Moore. A mechanically verified language implementation. Technical\nReport 30, University of Texas at Austin, 1988.\n[Rus77] Bruce D. Russell. Implementation correctness involving a language with goto\nstatements. SIAM Journal of Computing, 6(3), September 1977.\n[SB90]\n\nM. Srivas and M. Bickford. Formal verification of a pipelined microprocessor. IEEE\nSoftware, 7(5):52-64, September 1990.\n\n[Sha90] Mary Shaw. Prospects for an engineering discipline of software. Software Engineering, 7(6):15-24, November 1990.\n[War90] Henry S. Warren. Instruction scheduling for the IBM RISC System/6000 processor.\nIBM Journal of Research and Development, 34(l):85-92, January 1990.\n[War92] Henry S. Warren. IBM T.J. Watson Research Center, Private communication,\nFebruary 1992.\n[Win90] Phillip J. Windley. The Formal Verification of Generic Interpreters. PhD thesis,\nUniversity of California, Davis, Division of Computer Science, June 1990.\n\n4th NASA Symposium on VLSI Design 1992\n\n6.5.11\n\n[Win91] Phillip J. Windley. Using correctness results to verify behavioral properties of\nmicroprocessors. In Proceedings of the IEEE Computer Assurance Conference,\nJune 1991.\n[You89] William D. Young. A mechanically verified code generator. Journal of Automated\nReasoning, 5, 1989.\n\n'