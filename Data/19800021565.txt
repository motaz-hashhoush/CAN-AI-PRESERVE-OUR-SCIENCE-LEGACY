b'NOTICE\n\nTHIS DOCUMENT HAS BEEN REPRODUCED FROM\nMICROFICHE. ALTHOUGH IT IS RECOGNIZED THAT\nCERTAIN PORTIONS ARE ILLEGIBLE, IT IS BEING RELEASED\nIN THE INTEREST OF MAKING AVAILABLE AS MUCH\nINFORMATION AS POSSIBLE\n\nAp pEt,\\) D 1X E\nFrom: H. Hunke, Software EngineeriM Environments, !forth-Holland\nPub.\t\n\nCo., AmsterTaFi, The Netherlands, \t\n\n19 O) .\n\nRSSM/ 100\nAN ASSESSMENT OF DREAM\n\nWilliam E.\t Riddle\nCray Laboratories inc.\n5311 Western Avenue\n\nMoulder, Colorado\t\n\n80301\n14\n^\t\n\n1\t\n\n`r ^G VY ^ ^ \'^V\tr\n\nThe Design Realization,\t Evaluation And Modelling\t (DREAM) System is evaluated.\t A short history of the DREAM research project is first given in\norder to provide an historical \t context.\t Then,\t the significant characteristics of DREAM as a development environment are given,\t the design\nnotation which is the basis for\' the DREAM system is reviewed, and \t the\nIn the\ndevelopment tools envisioned as part of DREAM are discussed. \t\nconcluding section, \t insights into development environments and their\nproduction which we have gained from the work on DREAM are presented\nand used to make suggestions for future work in the area of development environments.\n\nn\n^\no\t\n\nca M\nN\nr\'D\nM\n0\n\no\nU\n^a\t + (n\nW U\nr,.,,-\n\n0\n\no\nH^\nb\nm.H\nG\nc\n\n^\n\nINTRODUCTION\n\n.\n\nDuring software system development, \t help is\t critically needed\t in many activities,\n1) recording what is known and what has been decided about the sysamong them:\t\ntem,\t 2) uncovering what is unknown, 3) assessing the suitability and the completeness of the\t (eventual)\t system, and 4) coordinating and monitr \xe2\x80\x94 ing the effQl , ts of\nthe team working on the development project.\nDevelopment environments are currently being studied as a way of providing help\nfor these activities.\t A development environment is a collection of tools which\nprovide a facilitating context in which to carry out development.\t The tools are\ntypically programs,\t such as compilers or text editors, which augment the "powers"\nof the developers and ease the production of a suitable, executable version of the\nsystem.\t\nBut,\t tools may also be n>tat onaZ and serve to augment the developers\'\ndenotational powers, or cognitive and serve to rationalize the de.:velopment process.\n\nNo\n,^\n^a o FS4\n\n\xc2\xadt\n\nIn the next section, we\n\na short history of the DREAM project in order to provide some historical\t con-\n\ne\xc2\xb0 w7 o\na\na\t\nU H u\n04 V\'\nM a a\nV\n\nIn this\t paper, we give an assessment of the Design Realization,\t Evaluation And\n[Modelling\t (DREAM)\t System, as a development environment. \t\ntext.\t\n\nThen,\t\n\nin the following three sections, we discuss \t the significant charac-\n\nteristics of DREAM as a development environment, give a brief overview of the\nnotational\t tool which is the basis for the DREAM system, and discuss the other\ntools provided\t (or to be provided) \t by DREAM.\t\nIn the concluding section, we relate\nsome of the insights into development environments and their production which we\n\nave gained from our work on DREAM.\nh\n04 M\nA SHORT HISTORY\n\nLike most systems, DREAM is a product of initial goals, prior experiences, biases\n\n^^^__\t\n\nThis work was performed while the author was affiliated with the University of\nColorado and was su pported, in part, by grant NSG 1638 from NASA_LangJey Research\n\nr;\n\nk\xe2\x80\xa2\n\nand external "forces." In this section, we provide a brief history of the DREAM\nproject with the intent of providing some insight into the technical and non-technical concerns which influenced the evolution of the DREAM system.\nDuring the period 1973-1975, an auto^r.7ata theoretic formalism for modelling parallel\nsystems was developed and its theort;tical aspects were investigated (this work is\nreviewed in [Riddle 79d] and [Riddle ! 79e7). Under the formalism, a parallel system\nis considered to be a single-level Lollection of asynchronous components. Component\ninterdependencies are modelled by message exchang \xe2\x96\xba) and some components provide message buffering capabilities. \'The non-buffering components are modelled as sequential processes which carry out a controlled sequence of message production, transmission and reception operations. A parallel system\'s behavior may be described\nin terms of sequences of message transfers among components using a notation very\nsimilar to, but more powerful than the notation of regular expressions. The existence of dual behavior/r\'<ructure i notations affords ti \xe2\x96\xba e opportunity to assess\nthe "correctness" of a parcicular system structure by assessing the consistency\ne\nbetween the behavior produced by thl structure and a specification of the system\'s\ndesired behavior. However, the power of the formalism is such that very few consistency questions are algorithmically decidable.\nConcurrent with this research, the TOPD system, developed by Peter Henderson and\nhis colleagues at the University of Newcastle upon Tyne ([Henderson 75b]), was\nacquired and used as the basis for a senior-level software engineering course.\nThe TOPD system is a development environment oriented primarily toward the implementation phase of sequential program development. It allows the development\nof a program to be done as a series of abstract descriptions, each of which is\na finite-state model organized as a collection of data abstractions. The TOPD\nnotation allows the description of behavior in terms of state transitions and the\nTOPD system provides assessment facilities [Henderson 75a] which allow the checking of the consistency between a procedure\'s behavior l and structural descriptions.\nIt was in this context that the DREAM project began, in early-1976, with the intent, of preparing a prototype version of a TOPD-like system useful for the development of concurrent software systems. Sycor, Inc., provided support because the\nprototype was potentially useful in developing software for clusters of intelligent\nterminals.\nThe project was decidedly a research one, however, and was not driven in any way\nby a particular software development effort at Sycor or elsewhere. One goal was\nto investigate the feasibility and desirability of basing a concurrent foftware\nsystem development environment upon the theoretical model of parallel systems which\nhad been developed. An equally strong goal was to provide a basis for the experimental evaluation of development environments and methodologies. Our aspirations\nin the latter direction followed from our feeling that experimental evaluation\nrequired the R;ility to perform well-defined, analyzable, partial development\nefforts and oor belief that a development environment supporting modelling provided this ability.\nInitially, our efforts focused upon developing a notation primarily founded upon\nour model of parallel systems but ,ghicr , utilized some notions from general systems theory and incorporated some compatible concepts from the TOPD Notation. We\nblatan. tly stole the general structure of the TOPD notation, as well as its concept\nof state-based models for describing data abstractions, but used our model of parallE\'l systems as the conceptual basis for our notation and extended the statebased model adopted from TOPD. The result was the DREAM Design Notation (DDN)\nwhich will be discussed in a subsequent section.\n\n1. We use the to-iii "structure in the automata theoretic sense of denoting the\nd we use the term "organization" to denote the\ncauses of a sy c \' is behavior\t\nThus, we would say "data organization" instead\nmore phy giC dl A S r) e c t\'s of a\t\n\'k\t\n\n,\nof ,_,d0lst7-uct,ure."\n\ni\nDuring its development, we used DON in several description tasks in order to assure ourselves that it was both effective and reasonably natural for describing a\nrelatively broad variety of systems including operating systems, process-based\nproblem solving systems and embedded control systems. Most of our description\n"experiments," however, concerned operating systems or parts of operating systems,\nWe also adopted the TOPD system\'s organization and prepared preliminary versions\nof many of the components of a prototype DREAM system \xc2\xad a data base, a syntax\nchecker and a command interpreter. Integration tasting of these components was\nprecluded by the disbanding of the research group in late-1977. Several of us\nmoved to other institutions, and we took advantage of the interruption in our activity as a group to both prepare reports and critically examine what vie had done.\nOvtt-c the last two years, our critical examination has been broadened to consider\na ri;,mber of specific topics which arose during our development of DDN. Some of\nthese studies concerned the extension of DON\'s conceptual base to a broader spectrum of systems ([Wileden 78a], [Segal 80]). We also investigated both the relationship of our work to system\'s theory [Riddle 79b] and the nature of a top-down\ndesign methodology based on dual behavior/structure notations such as DON\n[Riddle 79c]. Finally, we have been developing algorithms that can be used (in\nmodified form) to assess the consistency of DON descriptions ([Bristow 79],\n[Stavely 79]).\nAt the moment, the research group is distributed and loosely-coupled. Each of us\nhas a different focus to our individual work (flight control system design, distributed problem-solving system development, analysis algorithm development), but\nour work is somewhat integrated through our previous joint efforts.\n\nTHE DREAM SYSTEM\nA wide variety of systems may be called development environments \xe2\x80\x94 even r.urrentday operating systems are, in some sense, development environments. The different\npossibilities may be distinguished by characteristics such as the system\'s methodological base, the development phases supported, the intended audience, etc. In\nthis section, we "define" the DREAM system in terms of a number of then. distinguishing characteristics.\n9xaI1^l\'\n` P^^ . I3\'\nP OOR QUAL11r\nAs indicated previously, DREAM is oriented towaru the development of concurrent\nsystems, i.e., systems .having parts which either actually or logically operate\nin parallel. We have not restricted attention to any specific type of concurrent\nsystems and feel that DREAM is applicable to a wide variety including multi\nprogrammed systems, multiprocess systems, multiprocessor systems, networks and\ndistributed systems. In DON, we have provided a set of description capabilities\nwhich are appropriate for conceptualizing systems of any of these types even\nthough these types differ extensively with respect to some characteristics. As\na corollary, DON does not have facilitieti for describing those aspects, such as\nthe allocation of processes to processors, which distinguish theso different types\nof concurrent systems (although these aspects can sometimes be indirectly\nConcurrent Systems\t\n\ndescribed) .\nOur orientation toward this general class of software is not solely because of\nour previous work on a formalism for describing parallel sy\',tems. Rather, it is\nour belief, confirmed by our own and others\' experiences, that the development\nof concurrent systems is particularly taxing, especially with respect to the\nassessment of suitability.\n\n\t\n\n\t\nr\n\n\t\nDesign Phase\n\n!4\n\nDREAM is oriented toward the an! W1,( tu1-r;1\t\nphase of software development.\nIn this early segment of the total (Ii-sign phase, the task is to delineate the system\'s modules and define the couplin(Is among modules.\' Thus, attention is primarily\nupon decomposing a system into its parts, defining the parts\' interfaces, and indicating the interactions and interdependencies among the parts.\nThe architectural design phase is preceded and followed by other phases --indicating what these entail serves to delimit the architectural design phase even further by indicating what it does no entail. Preceding the architectural design\n\n; p hase are the )-oqui\xe2\x80\xa2i ,ainonts dcaffni.6iou and\n\nrslwol f\'l\'ootion phases during which the\n\nsystem\'s overall capabilities are prescribed. Following the architectural design\nphase are the al..l(,r-{l.lun t1o.siern and the -lilvicni ir.j^^\'rim^>>trrt:i.^^r^ phases durinq which\nthe information structuring and manipulation aspects of the system are detailed\nand encoded in some executable form. Thus, sandwiched as it is between these other\nphases, a primiary purpose of the architectural design phase is to transform the\nrequirements levied against the entire s,;Item into information retention and manipulation requirements to be satisfied by the system\'s components.\nImplicit in this view of the system lifecycle is that system certification and\nmaintenance are fret. separate phases. Rather, certification, by either verification or validation approaches, is viewed as a continual concern which must be performed during wo), phase. Maintenance is viewed as regression to some previous\npoint in the development followed by re - development. Thus, the activities, of\ncertification and maintenance are improtant during the architectural design phase\nand it is our intent to support these activities in DREAM.\n\nTotal System\nIn many applications, the components of a, concurrent system are physical ones\n(e.g., aircraft engines) or human ones ( (, .g., a patient being operated on) a\'s well\nas software. DDN allows the consideration of the total system (hardware, wetware\nand software) and thus permits the design of the software to be carried out with\nfull concern given to the environment in which the software will function.\n\nModelling\nIt is our belief that the..fundamental activity during architectural design is\nmodelling \xe2\x80\x94 in fact, the name "architectural design" was chosen to deliberately\nsuggest a relationship to the discipline of architecture in which the preparation\nof schematic, conceptual models is a paramount concern. The models developed\nduring the architectural design of software (or buildings) are abstract representations of the actual system which omit tho system\'s fine detail but faithfully reflect its externally observable characteristics. In these abstract representations, whatever is represented is done so to a level of accuracy and rigor\nthat there is an adequate basis for suitability assessment. Also, the representations are in a medium in which alterations may be more easily investigated.\nThe analogy to architecture indicates one additional aspect of the design-level\nmodelling of software. This is that there are at least two purposes of a model.\nOne is that indicated above - it should reflect externally observable characteristics. The second purpose is that the model should be an adequate basis for\npreparing implementation plans (blueprints). DDN is intended as a medium in\nwhich models with either or both of these. purposes can be prepared.\n\n_ Funct.ional i t.y\n\nTherie 0,01 mazy, IdLt:.L, F.r,\t\n\nseaf\'twcar^t system\'\t\nV) firnc-t \'Mal itv oncerns, c)erforinance c,\t\n\n:itability, roughly partitionable\na-^^d economic conce rns.\n\xc2\xb0ns. Some\n\nwork has been done on assessment with respect to performance concerns \t\n([Sanquinetti 77], [Sanquinetti 78], [Sancluinetti 79]) at the level of the conceptual basis underlying DON, but tw oriontation of DUN itself is exclusively\nupon the description and assessment of a system\'s functional characteristics.\n\nS\n\nThis focus was taken in order to reduce the scope of our work to a manageable\nsize rather than because of any feeling that performance or economic concerns are\nof less importance. Much to the contrary, we feel that truly effective env\xe2\x80\xa2;ronments must support the assessment of systems with res p ect to these other concerns;\nbut we also know that facilities to allow such assessment are extremely difficult\nto provide.\n\nDecision-making Support\nAs noted, certification is considerQd to be a continuous activity that is wellintegrated with the activity of design preparation. It is an intent of DREAM\nthat designers be able to not only gradually evolve a design but also be able to\ngradually evolve a de^ F ensible confidence in the suitability of that design. Thus,\nDREAM includes a number of tools which guide the decision-making process, allow\nthe recording of decisions, and help designers determine the validity of their\nIn DREAM, decision-making guidance is supported by tools which help\ndecisions.\t\ndesigners identify unmade decisions and the information impacting the decisions.\nDecision recording is aided by providing appropriate notational tools (i.e.,\nlanguages). Decision verification is aided by tools which allow designers to see\n\nthe results, in terms of the\n\nsystem\'s\n\nfunctionality, of a decision\n\n\xe2\x80\xa2! y ^ 04i^ evn^,oxt\n\nof all previous decisions.\nTo date, our accomplishments have fallen short of our intentions and we have fully\ndeveloped only one decision-making tool, the DON notation for recording decisions\nin terms of their effect on the structure and behavior of the system\'s components.\nWe have developed other techniques, discussed later, for decision verification,\nbut have not put these into a form compatible with DON.\n0>R,CGYI KC P1^GE I3\nMethodology Independence\t\n\nOF POOR QUALITY\n\nBecause of our goal to provide a facility for the evaluation of a variety of\nmethodologies, and because of our reluctance to posit a universally applicable\nmethodology, we attempted to keep.DREAM as free of methodological constraints as\npossible. This did not, however, mean to us that we could not make the system\neasier to use under one methodology and our proclivity toward top-dawn elaboration is quite apparent in the DON language.\nOne effect of this decision is that DREAM does not enforce the use of any particular tools at any particular points during design evolution. Our view of the\nDREAM system user (which we adopted from TODD) is that of a person who thinks\noff-line and then uses the system to helm keep track of decisions and periodically derive information by which the logical consequences of the decisions may\nbe deduced. As a consequence, DREAM does \t\npreclude the entry of new information concerning the design which is incompatible with existing information.\nRather, DREAM enforces only the rule that all information is syntactically correct\nand provides tools through which designers may uncover incompatibilities and inconsistences when warranted by whatever design "style" they use.\n\nLanguage-based Integration\nWhile DREAM does not achieve the integration of its tools by organizina them\naround a unifying methodology, it should be apparent from the discussion so far\nthat it does follow the alternativr approach to integration by basing the tools\nupon some common notation. The DON language and the view of software systems\n-.V_. L.._.^ .....{....L{..e:.__ n \xc2\xadiiAn 3 r\xe2\x80\xa2nRVnnn ha-i c\n\nrelationships in terms of how they construct, modify and manipulate descriptions\nin the language. The tools themselves make extensive use of both the syntactic\nand the semantic aspects of DDN.\nIn actuality, DDN is a collection of compatible sub-lanquages. Therefore, DREAM is\nmore correctly characterized as being integrated on the basis of a family of compatible languages. Anyone who has worked with "large" programming languages will\nappreciate the desirability of having a col le ction of "small," well-defined languages where attention has been given to separation of concerns..\n\n"Sophisticated" Users\nDREAM is intended to be used by experienced design practitioners. Provision is\nmade to represent information of interest to both requirements definers and sysi,crr,\nimplementors, but it is assumed that the design practitioners will function as\ninterpreters of the information for these other concerned parties. ro attempt has\nbeen n\'a;de to make DREAM usable by managers, end-system users, customers, docuwentors, testers, accountants, etc., all of whom have a legitimate concern in the\ndesign and its implications. DREAM can, in some instances, represent the information of interest to these agents, but the designers are again assumed to provide\nan interpretive interface to this information.\n\nDREAM DESIGN NOTATION\nThe heart of the DREAM system is the DDN language. It -?mbodies a formalism which\nfacilitates the conceptualization of concurrent software systems during their\narchitectural design. Also, it is the basis for the integration of the tools providing aid to design practitioners. Before describing these tools, it is necessary\nto give a brief overview of the DDN language and that is the purpose of this secLion. More detail on the DDN language can be found in the cited reports or inferred\nfrom the example that appears in the Appendix.\n\nStructural Models\nIn DDN, a system is modelled as an hierarchical, but not necessarily tree-like,\norganization of components which operate asynchronously. At each level in this\nhierarchical decomposition of the system, components interact directly by the\ntransmission of messages or indirectly through shared information repositories.\n\nComponents which interact by message tran-mission are called Sul.) \t\n\n("?? r\n\n([Riddle 77], [Riddle 78a], [Riddle 78b]). At each level, the subsystems represent\nthe components which operate concurrently. Each subsystem\'s \'interface to its\nenvironment (i.e., the other subsystcins at the same level) is defined in terms of\n) , , a rt:, through which messages may flow. The components within a subsystem know only\nabout the ports \xe2\x80\x94 the environment of the subsystem is riot visible to the subsystem\'s\ncomponents. Likewise, the environment knows only about the subsystem\'s ports and\ncannot "see" inside the subsystem. Thus, the subsystem\'s interface is akin to a\ndata abstraction interface with the ports serving a role analogous to a data abstraction\'s procedures.\nSome of a subsystem\'s components are primitive, that is, not decomposible. These\n\noont v7. T,vore8v,\xc2\xb0r govern the flow of messages through the ports and serve to distribute incoming messages to component subsystems and to collect messages from\ncomponent subsystems for transmission out through the ports. Control processes may\ncommunicate directly by message transmission. Also, they may communicate via\nshared information repositories.\nIn Figure 1, we give a gru,.,,,^_al reprr \t\n\ndenote subsyst r\t\n\n-1tion of a DDN model using circles to\n\ntriangles Ga denote control processes and squares to denote\n\n\t\n\nc\n\n7\n\nDAIGMAL PAGE ],1\n02 POOA -QUALXTX\t\n-\n\ntop\n\nf\t\n6-A\n\no\n\n.\'> F\nw\n\n!\t\n\nav\n\n!\n\nN\xc2\xb0\nV)o\n\n`\xe2\x80\xa2\n\n^\t\n\n^\n\nI\n\n11\n\nr\t\n\n1\n\n^ A\n\n1\n\n1\n\n1. 7.\n\nw\n\nW N\nI\n\nO\n\n^^\t\n!\n\n1+ 1 i 1\t\n1\t\n\nU 0\nW O\nU\ncn A\nw\n\n^\n\n^\n\nO\n\nz\n\nr\t\n^\t\n\n1\t\n\nI\n\n}\t\n\nW O\nH\n\no\n\nH Q\nW\n\nsubsystem\t\nQ control process\nmuni tor\nn\n\nlink\nprocedure\n\n\xe2\x80\x94=-T message transmission "channel"\nfir\xe2\x80\xa2\xe2\x80\x94\n\nEl \xe2\x80\x94\xe2\x80\xa2-!\n\na^-\xe2\x80\xa2 -^\n\nprocedure call with only value parameters\nprocedure call with only result parameters\nprocedure call with both value and\nresult parameters\nFIGURE\n\n1\n\n"skin." The small, black squares in the figure are special shared data reposi\'- \' 8\ntories, called ;irzk:,, which provide potentially infinite message buffering\nfacilities. This figure more clearly indicates that subsystems provide the means\nfor encapsulating collections of data storaq e components (internal, shared information repositories) and data processing components (internal subsystems). Note that\ncomponent-sharing is allowed, even between levels of decomposition.\nShared data repositories are modelled as monitoi , n [Hoare 741 since this well-known\nconstruct provides much of what is needed [Riddle 79a]. A monitor in DUN denotes\na multi-procedure data abstraction which can function as a data repository shared\namong asynchronous data processing components. There is the restriction that only\nmonitors may be components within monitors. (This somewhat arbitrary restriction\ncomes from a feeling that once a locus of control is sequentialized it should remain sequentialized.)\n\nBehavior Models\nA structural model reflects operational aspects of the system specifying interfaces\nand modelling the algorithms which control the use of the interfaces. This is\nanalogous to defining the structure of a stack data abstraction and the structure\nof a tree-search algorithm which uses a stack by specifying the Rush and pop procedures and giving an abstraction of the tree-search algorithm which indicates,\nnon-deterministically, the calls upon the push and pop procedures.\nA structure gives rise to, or causes, some behavior which is the effect, over time,\nof "executing" the structure. Thus the behavior of a stack data abstraction is\nrei`lected by statements such as "the number of ms\'s is less than or equal to the\nnumber of Push\'s," and the behavior of the stack as used by the tree-search algorithm is reflected by statements which indicate the sequences of pop\'s and\npush\'s which the algorithm creates when it is executed.\n\nNotice that a component will have an\t\n\n(or\n\nzc tua\n\nl)\n\nbrhuz , ior\n\nwhich is the\n\nbehavior the component\'s structure is capable of producing. A component will also\n\nhave one or more\t\n\n(or\t\n\n^(^I) brhovi,ors\n\nwhich are those stemming from\n\nthe use of the component. In the absence of any knowledge of about how a compon-\n\nent is actually used, its\t\n\nhwh;avi,,\t\n\ncan be defined with the implication\n\nthat any legal extrinsic behavior should exercise the component only in ways that\nare indicated in the required behavior. DREAM\'S certification tools, which will\nbe discussed later, determine suitability by comparing extrinsic, required and/or\nintrinsic behaviors.\nDDN provides a number of ways of specifying a component\'s required behavior and\nthus giving a behavioral model of the component ([Riddle 78b], [Wileden 78b]).\nRequired behavior that relates to the usage of interfaces may be specified by indicating conditions upon the information which may legally pass through the inter.\nface. Thus, conditions may be levied against messages that may pass through\nsubsystem ports or values that may "pass through" parameters to monitor procedure\ncalls.\nMore complicated aspects of a monitor component\'s behavior, concerning when the\ncomponent\'s procedures may be legally invoked, may be specified by giving preand post-conditions, stated in terms of the "stjte" of the component and associated\ntogether to form a transition which indicates the effect of the procedure. For\nexample, a stack\'s states could be specified as em ty, full, and otherwi se and the\ntransitions for poi could be:\nfull \xe2\x80\x94 - i otherwise\nothe r wi\n\nse -- -gp otherwise or e Rty\n\nwhich indicate that\t\n\xe2\x80\xa2annot Lie Ierj,.,,,, invoked when the stack is ei^)tv\nand specify t 1,, rec\xc2\xabirud behavior to be "causod" when p op is invoked.\t (Tho\n\n\t\n\nF\t\n\nspecification of behavior by state transitions is a concept which we borrowed from 9\nTODD.)\nA final set of DON constructs for spurify Hg roquired behavior allows the description of behavior over time. l:\'ocoo i.an bo dofinod as the occurrence of "interesting happenings\'" during system operation an(] the required behavior may then be expressed as required sequences of events. E\'or example, procedure names are automatically events and the usual requi,rod behavior for a stack could be specified as:\nREENTRANT (SEQUENCE (jLush, pop))\n\nj\nscm<fntics of RELNTRANT, wf^ans that the number of r_ush\'s\nmust be greater than or elual to the number of ppp,\'s.\nwhich, because of the\nf\nf\n\nThe DDN constructs for event seciuVricc , definition are powerful but parsimonious.\nAlso, they are a formal notation and are therefore not extremely "friendly" for\ndesign practitioners who lack training in the formal aspects of computer science.\nHowever, they provide a set of denotational capabilities which are extremely important for behavioral modelling.\n\nOrganizational Mode 1\t\n\nCITUGINAIC V GE IS\nQR POOR QUALITY,\n\nfollowing the precedent set by the TOPD language (and originated, we believe, in\nthe Simula language [Dahl 66]), DON descriptions are a collection of al-,!;; definitions. A model is therefore obtained from a description by a process of 1rtjCant.-ia.l`o7r. Standard declarative constructs are used to denote hierarchical organization and special constructs are providod to denote component sharing since the\nstandard declarative constructs would permit only tree-like hierarchies\n[Riddle 801. Message co;nmunication pathways among subsystems are defined by using\nadditional descriptive constructs.\nDDN views instantiation as occurring entirely before execution and thus models\nhave a static organization. Many dynamic organizations can, however, be\n"simulated" by the dynamic use of a static communication pathway organization,\nbut the resulting models tend to be overly complex and unclear.\n\nA Final Word\nDON is a poor programming language; but that\'s because it is not intended to be\na programming language. The intent in developing DUN is to provide modelling\nconstructs which allow the description of what modules comprise a system and what\nthe interactions among the modules should be. Exactly how the modules interact is\nnot considered to be properly part of a DDN model. Thus, for example, a single\nconcurrent process synchronization mechanism (message transfer) is provided in\nDUN whereas one actual synchronization in the fully developed system would be\nachieved by the use of one of a number of synchronization mechanisms.\nHowever, DDN looks like a programming language and this is perhaps a mistake.\nWe have seen designers misled by the similarity and, as a consequence, they misuse the language. We feel, however, that the concepts included in DDN are the\nright ones for the architectural design ofconcurrent systems. We feel that the\nproblems which arise should be solved by education of the designers rather than\nchanging DDN.\n\nDREAM SYSTEM TOOLS\nWe plan a number of tools to help design practitioners in constructing suitable\nmodels for concurrent software systems. We know that some of these tools are\nfeasible because we have constructed prototype versions. Others have been de-\n\n,_....\t\n\n. _.._ .\t\n\nf\n\nput them in a form suitable for use with DDN. We discuss these tools in this sec- 10\ntion as if they have been constructed and the cited references indicate more exactly the degree to which they have been developed.\n\nData Base Core\nThe fundamental tool in DREAM is a data base in which are stored fragments of a\nDDN textual description. Most fragments define some aspect of some class of components in the model; others give information concerning tests or analyses, documentation, etc. The DDN syntax defines how the =se fragments are related and\nprovides for naming them. Fragments to be retrieved from the data base are\nselected by these names and thus DDN itself is used as the basis for the data base\nquery language.\nDescription fragments have other attributes besides names. In the current data\nbase implementation [Numbrecht 80], there can be an arbitrary number of additional attributes although the number of attributes and their values are fixed\nfor any data base. Further, there must be at least one attribute which hold a\ntime/date stamp reflecting when the fragment was inserted into the data base.\nUsers may establish a "slice" through the data base by specifying values for the\nattributes and any modifications to the data base are relative to the fragments\nin the active slice. The time/date stamp attribute is used to resolve all ambiquities, in effect selecting the "newest" fragment in any collection which is\nselected by an ambiguous retrieval command or slice definition. This data base\norganization provides a good deal of flexibility, allo y ing "windows" into the\ndata base which can reflect time, versions, design team organization, etc.\n\nBookkeeping Tools\nIn keeping with the view that a DREAM user intersperses relatively long periods\nof offline thinking with relatively short periods of modification of the information contained in the data base, the DREAM tools for aiding the maintenance\nof the evolving design\'s description are simple extensions of the data base interface. It is assumed that the host operating system\'s editor can be used to prepare new or modified description fragments. The bookkeeping tools then amount\nto 1) an entry tool which syntax checks the fragment and presents syntactically\ncorrect fra g ments to the data base for insertion, and 2) a retrieval tool which\ninterprets the user\'s retrieval directives and constructs the appropriate data\nbase query commands.\n\nDecision-making Tools\nThe major tools provided by DREAM are those which aid design practitioners in\nassessing the suitability of the design as it evolves and in identifying what\nremains to be designed. These tools fail into three categories which we discuss\nbelow.\n\nF\'hav zphi^as i nq 1\'Uo7;,. Tools in this category re-present the information in the\ndata base in a form, perhaps structured in some canonical format or presented\ngraphically, in which the user may more easily inspect it and perhaps even identify some errors. The information is no more and no less than that already contained in the data base although the use may focus on some subset of the total\ninformation. Figure 1 is an example of chat might be produced by an instantiation graph paraphrasing tool. Other par phrasing tools could produce control\nmaps akin to flow charts or they could p-oduce cross-reference charts.\nExtraction Too Zs. Th = type of tool exa"ines the information in the data base\nand, knowing the sF n,\t\n- s of DDN, derivLs feedback "or the designers concerning\n\n,^\t\n\nthe charac jwr r s tic ^,\t\n\nLrie model.\n\nUsually, this feedback concerns the intrinsic\n\nc\nF\n\nN\n\nsimulators, finite-State testors [Henderson 75a,,t , .ind event sequence expression \t\nderivers [Riddle 79e],\n3\nf.! r2S^,;".ra\xe2\x80\x9e^^^\n\n(hr^,l^lr^a ;"^,3:\' .\t\n\nThese tools onci \xe2\x80\x94,or incompatil; i l sties among various\n\na doscriptinr , fragment and some rule (e.g,, no\ndescription fragments or\t\ndeadlock), Because of the difficulty irnd impo^ _, p ity of doing exact, algorithmic\nanalysis, these tools uncover anomali-s (i.c;,, d( , ,^, Lions which are suspicious but\nare noc confirmed errors) and the designers must use, intuition, experience and in-\n\nsight to determine whether or not a \'det,ec:ted anomaly i in fact an\n\nerror.\n\nFxampl es\n\nof consistency checking tools arty ; the TODD c.onsi ,itency checker [Henderson 75a],\nevent trace checkers [Stavely 79], and synchronization anomaly detectors\n[Bristow 791.\n\nOWTI\'M\t\n\nT9\nr\nOr Pooh QUALITY,\n\nCONCLUSIONS\t\n\nEven though we have riot yet prepared a full implementation of DREAM, our development of DDN, along with its assessment and with our investigation into analysis\ntechniques and other associated topics, has ,ivtn us some insights into the characteristics of effective development support systems. Further, we have also\ngained some insight into major problems which remain to be Solved on the way to\nachieving these systems. These insights, ;overal of them quite obvious with 20/20\nhindsight, are discussed in this concludi-rg section.\n\nSome Lessons Learned\n\nBy building on IWI D as a base language, arcs by not giving\nenoug,n thought to the inadvisability of having a large, complex iangc:age, .:e\nsuffered a severe case of the "Second System Syndrome." We do not believe that we\nhave unnecessary constructs. Nor do wefeel that the constructs appear in conflicting f\xe2\x80\xa2\'orms. We do think that DDN should be more clearly decomposed into the family\nof interrelated languages which it. actually is. Perhaps it is sufficient to partition the \'language along structurt^/behavior/org,rnization lines, but that is not\nentirely clear at the moment.\n:1.h^x^^rt.i^^fi\n\nOf\t\n\nDecomposition oi\' thi, not,itional tools into an integrated\n\ncollection of logically complete languages is part o f a larg-:r issue.\n\nil,\'i.\n\ntools\n\nin a development system must serve a narrowly defined purpose and it is a mistake\nto make tools do "double duty.\xe2\x80\x9d For example, having DDN be both a model description language on,l the basis for a data base query language is a mistake since it\ncomplicates the language and negatively impacts the a g ility to easily change either\naspect of the language.\n\nIt is, of cour se, extremely desirable that a Tower of Babel situation be avoided.\nThe point is that our experiences with DDN indicate: one should define a numher of\nsmall, interrelated, well-defined languages and then attempt to amalgamate them.\n\nWe made the mistake of trying to put everything into one language from the very\nbeginning.\nTool w9agc. A beautifully handcrafted banjo can be just a piece of art and not a\nmusical instrument. So it is with software development tools - their value depends\non their usefulness for software development rather than their elegance on more\nesoteric levels. It is imperative, therefore, that tools emerge through a natural\nselection process involving actual use.\nA well-established approach is to implement the tools, nut them into use, and see\nhow they are accepted. This is also an effective w:iy to "sell" tools to practitioners since, if they accept the tool thn,n they will ask for more (a phenomenon\nwhich has been called the "Potato Chip Principlo" [Nassi 80]).\n\nFor a number of reasons, we did notI..__\t\ntake this approach \'iii developing ^RE,\\M. Per.\n_._.. _..__.\t\n\t\n\n11\n\nter--\xc2\xae--\xc2\xb0.-^ -\t\n\n..:.,..-r\t\n\n-\t\n\nt.....^-\t\n\n.....,^ .\t\n\n\xe2\x80\x9e^.- .-r..- ^\xe2\x80\xa2-:r\n\nV\n\nevolve it as a result of that usage. But it is equally important to do gedanken\'\t\nexperiments away from the heat of battle -- one has only to compare Pascal and\nFortran to see this. In developing DDN we have done a number of gedanken experiments and feel that this introspective, controlled usage of tools is an important\ndevelopment approach.\n\n12\n\nL\'xp`l.oratio^z. DREAM provides little tll y, oat help for exploring and comparing alternative designs. Designers may describe alternatives, assess them individually and\ncompare the results. But, more sophisticated facilities are generally needed to\nhelp developers keep track of the alternatives, their sirnilarites and their\ndifferences. Facilities are also necessary to help developers trace back through\na sequence of decisions.\nIn teaching TODD and DDN, we have found it possible, but difficult, to\nestablish the right frame of mind for effective use of modelling-based tools.\nEven those more sophisticated students, who embrace, good programming methodologies,\ntend to use the familiar to understand the unfamiliar and look at architectural\ndesign as something of the same nature as algorithm design, only more complicated.\nFurther, the fact that TOPD and DDN have their heritage in programming languages\nfosters this reaction. We have found it mandatory to carefully establish the\nnature of architectural design prior to introducing design notations.\n\nTatluo(ztion.\t\n\nSome Problems for the Future\nR uuatlon. It probably overloads the world to create yet another paraphrase of\nMacArthur\'s famous saying, but it is true that "(-,, Id programmers never die they\n,just become designers,\' And so it should be, since system designers must be relatively sophisticat".ed programmers so that they create feasible designs. But this\nmeans that we cannot rely on experience being the "teacher" and must directly\naddress the issue of educating developers in the ways to appropriately and effectively use tools and development environments.\n\nSeveral proposals for primitives which should be in languages for programming distributed systems (e.g., [Andrews 771, [Hoare 78], [Liskov 79]) have\nduplicated some of the primitives found in DDN. This indicates that some of the\nprimitives we developed for DDN are useful for the implementation-level description of systems. We view this as desirable since it lessens the gap between a\ndesign and an implementation. But we also feel that blurring the distinction\nbetween design and implementation is not a good idea since it will allow, and perhaps even encourage, implementation decisions to be prematurely made. if the\nlanguage-extension approach to preparing development environments is chosen, we\nfeel it is critically important to allow the use of the primitive concepts (e.g.,\nmessage transmission) without having to express all the details (e.g., message\nbuffering constraints).\n\nLczrujuadrs.\n\nI:oa7urz(.io7z. We currently lack the techniques that will be necessary to assess the\nimpact of tools and environments; there are many \t\nadvantages and disadvantages, but assLssments are intuitive, subjective, ambiguous and contradictory. We\nneed models of the development process and developers themselves. We need metrics\nof system quality and development methodology quality. And, we need some idea of\nhow to conduct "small," experimental development projects in a way which allows\nvalid inferences to be drawn concerning "large" efforts.\nA particular need, in order to be able to prepare truly effective environments, is for some understanding of how developers reaZly carry out\ntheir work. Most development methodologies make the assumption that the process\nof development is, or can be, the ord6 cl v progression of logical steps, and rationalization of the process i,, no doubt, beiteficial. But creative processes are\nnor\xc2\xb0torious fr-, their randot ass and we need to understand the nature of this randomness rath\t\n+han try f ,\t\nnlinato or control it. Only with such an understand-\n\nDeveZopment StryZc.\n\ning can Offec\'.ivo heat) b \t\n\nthy\xc2\xb0 -ih software development tools and environments.\n\n\t\n\nf\nI\n\n13\n\nACKNOWLEDGMENTS\nI am indebted to the other members of the DREAM project -- John Sayler, Al Segal,\nAl Stavely and Jack Wileden \xe2\x80\x94 for their help, Thor comments and assessments presented here were formulated during nunorou s discussions and I would like to thank\nthe following people in particular for their willingness to listen and constructively criticize: Roy Campbell, Bryan Edwards, Gerry Estrin, Vic Lesser, Ed Senn,\nRaymond Yeh, and Pamela Zave.\nG\n\nVT\nOF POOR gUALIT i\n\n&\nt)RTGINATC P YI\n\nREFERENCES \t\n\nAndrews 77\nG.R. Andrews and J.R. McGraw. Language features for process interaction.\n\nSoftwan\'^^\n\n\t\n\nNo t(iv,\n\n0, 2 (March 1977), 114-127.\n\nBristow 79\n\nG. Bristow, C. Drey, B. Edwards and W. Riddle. Anomaly detection in concurrent\n\nprograms.\n\nI\' k n hha , t\n\nh NOPa;N\'\'cnal r\':>nj% on Woftu>z p o F,\'itginearing, Munich,\n\nGermany, (September 1979), pp. 265-273.\nk\n\nDahl 66\n0. Dahl and K. Nygaard. SIMULA - An Algol-basod simulation language.\n\nt\'cwun.\n\n9 ( September 1966) , 671-678.\nDijkstra 68\n\nE.W. Dijkstra. The structure of the T.H.E. multiprogr aiming system.\n11, 5 (ray 1905) , 341-346.\n\nG"ry%m.\n\n11. c.. :. ,\n\nHenderson 75a\n\nP. Henderson. Finite state modelling in program development. sIr.;1Iw uut: ucs,\n10, 6 (June 1975), 221-227.\n\nHenderson 75b\nP. Henderson, R.A. Snowdon, J.U. Gorrie and I.I. King. The TOPD System, Tech.\nReport 77, Computing Laboratory, Univ. of Newcastle upon Tyne, England,\n(September 1975).\nHoare 74\nC.A.R. Hoare. Monitors: An operating system structuring concept.\n175 10 (October 1974), 549-557.\n\nC(mr., . A, 6\'. N.\n\nHoare 78\n\nC.A.R. Hoare. Communicating sequential processes. t.^u= A.C.M., A, 8 (August\n1978), 666-667,\nHumbrecht 80\nJ. Humbrecht. DE:MDAB: A design and maintenance data base system. M.S. Thesis,\nDept. of Computer Sci., Univ. of Colorado at Boulder, Colorado, (to appear 1980).\nLiskov 79\nB.H. Liskov. Primitives for distributed computing. Proc. Symp. on Operating\nSystem Principles, Asilomar, California, (December 1979), pp. 33-42.\nNassi 80\nI. Nassi. Software development tools: An industrial perspective. \t\n\nand Fairley (eds.), \t\n\nIn Riddle\n\n007S, Springer Verlag, Heidleberg,\n\nGermany,(1980).\nRiddle 72\nW.E. Riddle. Hierarchical modelling of operating system structure and\n\nProe. A.O.M.. Notion&\n\nConj%,\n\nBoston, August 1972.\n\nRiddle 77\nW. Riddle. Abstract process types. RSSM/42, CU-CS-121-77\xe2\x80\x9e Dept. of Com puter\nSci., Univ. of Colorado at Boulder, (December 1977; revised July 1978).\n\n`\t\n\n4\n\n!\t\n4\n\nS\n\n14\n\ny\n\nRiddle 78a\nW. Riddle, J. Sayler, A. Segal, A. Stavely and J. Wileden. A description scheme\nto aid the design of collections of concurrent processes. Py, oc. 19?8 Ala ti.onaZ\n\nComj)uter Conj\'., Anaheim, California, (June 1978), pp. 549-554.\nRiddle 78b\nW. Riddle, J. Wileden, J. Sayler, A. Sogal and A. Stavely. Behavior modelling\n\nduring software design. JAWE Y\'mma. rrr \xe2\x80\x9er>ft.7,7avr Ent\t\n\n(I\n\n\t SR-4,\n\n4 (July 1978),\n\n283-292.\nRiddle 79a\nW, Riddle, J. Sayler, A. Segal, A. Stavely and J. Wileden. Abstract monitor\n\ntypes.\t\n\n1jive. - \'J)vc ,ificatioli oj \' Holi\xe2\x80\xa2abl,`\n\n:ii r f \' 17Ji71\'i.\' C.onf.,\n\nBoston, Massachusetts,\n\n(April 1979), pp. 37-43.\nRiddle 79b\nW. Riddle and J. Sayler. Modelling and simulation in the design of computer\nsoftware systems.\t In Zeigler (ed. ), Aft , i hock) lo,.ip 4- n .5ya ains Model iin;i an\'i\nSimulut-ion, North-Holland, Amsterdam, The Netherlands, (1979), pp. 359-386.\nRiddle 79c\nW. Riddle. An event-based design methodology s- \xe2\x96\xba pported by DREAM. In Schneider\n\n(ed. ) A\'0in;aZ Alo(lel3 anti\' Pvactl,ral g\'ooli, fi71\' htf lJZ\'viut vn Syete7m5 1Rc_ i n, Northv\nHolland, Amsterdam, Tie Netherlands, (1979), pp. 93-108.\nRiddle 79d\nW. Riddle. An approach to software system behavior description.\nLanguaued, 4, (1979) , 29-47.\n\nocwgit[1,\n\nRiddle 79e\n\nW. Riddle.An approach to software system modelling and analysis.\nLun(yaayes, 4, (1979) , 49-66.\n\nC,\xe2\x80\xa2arrj:^.?t,?r\n\nRiddle 80\nW. Riddle, J. Sayler, A. Segal, A. Stavely and J. Wileden. Hierarchical de-\n\nscription of software system organization. z lmu. 13th Hawaii Intevm-2tlonaz c"onf.\non SYsGem Sci.,\n\nHonolulu, Hawaii, (January 1980).\n\nSanguinetti 77\nJ.W. Sanguinetti. Performance prediction in an operating system design methodology. RSSM/32 (Ph.D. Thesis), Dept. of Computer and Comm. Sci., Univ. of\nMichigan, Ann Arbor, Michigan, (May 1977).\nSanguinetti 78\nJ.W. Sanguinetti. A formal technique for analyzing the performance of complex,\nsystems. Proc. CF\'rUG Conf., Boston, Massachusetts, (October 1978).\nSanguinetti 79\nJ.W. Sanguinetti. A technique for integrating simulation and system design.\n\nProc. Conk\'. ore Simulation, Maaeum ment zncl A1odc\'ll\xe2\x80\xa2l7,q of Computer\nBoulder, Colorado, (August 1979), pp. 163-172.\nSegal 80\nA. Segal. Modelling supervisory systems which execute on interruptible\npro c essors. Ph.D. Thesis, Dept. of Computer and Comm. Sci., Univ. of Michigan,\nAnn Arbor, Michigan, (to appear 1980).\nStavely 79\nA. Stavely. The membership problem for behaviors of concurrent software systems.\nRSSM/93 and CSR 153, Computer , Sci. Dept., New Mexico Inst. of Mining and Tech.,\nSocorro, New Mexico, (September 1979).\nWileden 78a\nJ.C. Wileden. Mod-lling para"el systems with dynamic structure. RSSM/71\n(Ph.D. Thesis), \'\t\nt. of Com,- er and Comm. Sci., Univ. of Michigan, Ann Arbor,\nMichigan, ()anuary 1978).\n\nY\n\n15\nWileden 78b\nWileden, J.C. Behavior specification in a software design system. RSSM/43,\nCOINS Tech. Rep. 78-14, Dept. of Computer and Info. Sci., Univ. of Massachusetts,\n\nAmherst, July 1978.\n\nDTtI INAX\t\nT3\nQT; F MR, Q) LT \'1.1T\'Y:\n\nji\n\nh\nK\n\nAPPENDIX:\t\n\n.Example DDN Description\n\n16\n\nIn this appendix, we give a DDN description of an operating syster , that is structured similarly to the T.H.E. operating system developed by Dijkstra and his\ncolleagues [Dijkstra 68]. The description given here is essentially a translation\nof the description given in a notation that served as a basis for the DDN notation\n\n[^Ri ddl a 72].\nFirst we use the DDN Notation to give simple models of the devices managed by the\noperating system.\n\n[memory control unit]: SUBSYSTEM CLASS;\nDOCUMENTATION; Items in this class of subsystems process\nrequests for reading and writing of the real memory.\nEach request is in the form of an address within the\nreal memory space. No account is taken in this model\nof the response to a read request.\nEND DOCUMENTATION;\nchannel: IN PORT;\nBUFFER SUBCOMPONENTS; address OF [real address]\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT;\nprocess: CONTROL PROCESS;\nMODEL; ITERATE; RECEIVE channel;\nEND ITERATE;\nEND MODEL;\nEND CONTROL PROCESS;\nEND SUBSYSTEM CLASS;\n[operator console]: SUBSYSTEM CLASS;\nDOCUMENTATION; This models the console and the operator\nusing it.\nEND DOCUMENTATION;\nmessage_in: INPORT;\nBUFFER SUBCOMPONENTS; message OF [program message]\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT;\nreply_out: OUT PORT;\nBUFFER SUBCOMPONENTS; reply OF [operator reply]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\noperator: CONTROL PROCESS;\nMODEL; ITERATE; RECEIVE message in;\nSET reply TO ans;\nSEND reply out;\nEND ITERATE;\nEND MODEL;\nEND CONTROL PROCESS;\nEND SUBSYSTEM CLASS;\n[card reader]: SUBSYSTEM CLASS;\nDOCUMENTATION; This models the actual card reader. For\npurposes of this model, the card reader reads in one\ncard at a time in response to requests from some part\nof \xc2\xad n operatin g vstem.\n\nF\' ,\t\'CUMENTATTu,\',;\nPNg\t\n\nTrM CLASS,\n\n4.\n\n[card reader]: SUBSYSTEM CLASS;\nrequest in: INPORT;\nBUFFER SUBCOMPONENTS; read ,request OF [read request message]\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT;\ncard out: OUT PORT;\nBUFFER SUBCOMPONENTS; card image OF [card]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\nreader: CONTROL PROCESS;\nMODEL; ITERATE; RECEIVE request in;\nSET card image TO defined;\nSEND card out;\nEND ITERATE;\t\nEND MODEL;\t\n\nEND CONTROL PROCESS;\t\n\nOJ\n\n1GINAL pAGE.\nPOOR\n\n17\n\nr^\n\nQUALI\'fy\n\nEND SUBSYSTEM CLASS;\n[printer]: SUBSYSTEM CLASS;\nDOCUMENTATION; The model is of a printer which receives\ncarriage control signals separately from lines to to\nprinted. It is not necessary that each carriage\ncontrol signal be followed by a line to be printed.\nEND DOCUMENTATION;\ncarriage control: IN PORT;\nBUFFER SUBCOMPONENTS; signal OF [carriage\xe2\x80\x94control\xe2\x80\x94signal]\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT\ncontents: IN PORT;\nBUFFER SUBCOMPONENTS; line OF [print\xe2\x80\x94line]\n\nEND BUFFER SJ BCOMPONENTS ;\nEND IN PORT;\nprint: CONTROL PROCESS;\nMODEL; ITERATE; RECEIVE carriage control;\n\nMAYBE; RECEIVE contents;\nEND MAYBE;\nEND ITERATE;\nEND MODEL;\n\nEND CONTROL PROCESS;\nEND SUBSYSTEM CLASS;\nIn giving these models, we have indicated the need to have several different types\nof information. In some cases, we have indicated "values" that pieces of information should assume. This can be recorded more explicitly by using DDN monitor\nclasses to record the names for these types of information and their possible\n"values" as delineated so far.\n[real address]: MONITOR CLASS;\nE.,\'-,! D MONITOR CLASS;\n[program message]: MONITOR CLASS;\nDOCUMENTATION; messages sent by a program to the operator\nthrough the operator\'s console;\nEND DOCUMENTATION;\nEND MONITOR CLASS;\n[operator_ reply]: MONITOR CLASS;\nSTATE SUBSETS; ans END STATE SUBSETS;\nEND MONITOR CLASS;\n[read request message]: MONITOR CLASS;\nEND MONITOR CLASS;\n\n18\n[card]: MONITOR 01LASS;\nSTATE SUBSETS; defined END STATE SUBSETS;\nEND MONITOR CLASS;\n[carriage control signal]: MONITOR CLASS;\nEND MONITCk CLASS;\n[print _line]: MONITOR CLASS;\nEND MONITOR CLASS;\nBefore giving the operational parts of the operating system itself, another primitive part of the overall system that needs to be modelled is a program running\nunder the operating system. The system is a multiprogrammed one, so the class\ndefinition facilities are used to model a generic program running under the\noperating system. With respect to the devices and resources managed by the operating system, the important thing to describe about a program is that it produces\na nondeterministic sequence of uses of the various resources and devices.\n[program]: SUBSYSTEM CLASS;\ncard request: OUT PORT;\nBUFFER SUBCOMPONENTS; read request OF [read\xe2\x80\x94request\xe2\x80\x94message]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\nread card: IN PORT;\nBUFFER SUBCOMPONENTS; card image OF [card]\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT;\nprinter control:.OUT.PORT;\nBUFFER SUBCOMPONENTS: signal OF [carriage\xe2\x80\x94control\xe2\x80\x94signal]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\nline contents: OUT PORT;\nBUFFER SUBCOMPONENTS; line OF [print_,line]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\nto_operator: OUT PORT;\nBUFFER SUBCOMPONENTS; message OF [program message]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\nfrom operator: IN PORT;\nBUFFER SUBCOMPONENTS; reply OF [operator reply]\nEND W FF ER $U BCOMPONENTS;\nEND INPORT;\naccess: OUT PORT;\nBUFFER SUBCOMPONENTS; address OF [virtual\xe2\x80\x94address]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\nEND SUBSYSTEM CLASS;\n[virtual address]: MONITOR CLASS;\nSTATE SUBSETS; defined END STATE SUBSETS;\nEND MONITOR CLASS;\n\nw\n\nI\n\t\n\'[program]: SUBSYSTEM CLASS\' r un: CONTROL PROCESS;\nMODEL; ITERATE; SELECT;\n(PERHAP^F ) COMMENT read operation;\nSET read request TO defined;\nSEND card request;\nRECEIVE read card;\n(PERHAPS) COMMENT write operation;\nSET signal TO defined;\nSEND printer control;\nMAYBE; SET line TO defined;\nSEND line contents;\nEND MAYBE;\n(PERHAPS) COMMENT interact with operator;\nSET message TO defined;\nSEND to operator;\nO\'R\'Gl r\nMAYBE; COMMENT riot all messages\nregjire a reply;\nRECEIVE from operator;\nEND MAYBE;\n(OTHERWISE) COMMENT read or write a location\nin program\'s virtual\nraemory space;\nSET addre ,;s TO defined;\nSEND access;\nEND SELECT;\nEND ITERATE;\nEND MODEL;\nEND CONTROL PROCESS;\n\no\n\n19\n\nA\n\nNotice that there is an inconsistency among these models \xe2\x80\x94 the operator always\nreplies to each message that a program sends whereas the program does not always\nexpect a reply. This could be uncovered by simulation-based testing at this\nlevel of modelling or by more formal analysis. This inconsistency will be removed when the operation of the system with respect to conversations between a\nprogram and the operator is elaborated later.\nThe description of the operating system at this level of modelling may be completed by giving models of the major operational parts of the operating system.\nFirst, the address translator which converts addresses in the virtual memory spaces\nof the programs into the actual memory space of the memory system:\n[address translator]: SUBSYSTEM CLASS;\nvirtual space: IN PORT;\nBUFFER SUBCOMPONENTS; v address OF [virtual\xe2\x80\x94address]\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT;\nactual space: OUT PORT;\nBUFFER SUBCOMPONENTS; a address OF [real_address]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\nEND SUBSYSTEM CLASS;\n\'[address translator]: SUBSYSTEM CLASS\' translate: CONTROL PROCESS;\nMODEL;\xe2\x80\x94ITERATE; RECEIVE virtual space;\nSET a address TO defined;\nSEND actual space;\nEND ITERATE;\nEND MODEL;\nEND CONTROL PROCESS;\nBefore giving mode\'s of the other major processing portions of the operating sys-\n\nterns_ the de_fi:nitA..nnc_.n.f .tha niarac. n:f inf_n.r_ma.ti.nn nrnr_cc_cad b y\t\n\nehnailA\t\n\nJ\n\nlk\n\nbe updated.\t\n\n20\n\n\'[read_request message]: MONITOR CLASS\'\nSTATE SUBSETS defined END STATE" SUBSETS;\n\'[carriage_control signal]: MONITOR CLASS\'\nSTATE SUBSETS defined END STATE: SUBSETS;\n\'[print line]: MONITOR CLASS\'\nSTATE SUBSETS defined END STATE SUBSETS;\n\'[program message]: MONITOR CLASS\'\nSTATE SUBSETS defined END STATE SUBSETS;\n\'[real address]: MONITOR CLASS\'\nSTATE SUBSETS defined END STATE: SUBSETS;\nAt this level of modelling, there are no further distinctions that can be made\namong the "values" of these pieces of information.\nThe next processing module within the operating System is the handler of messages\nbetween the programs and the operator. At this level of modelling, the handler\nis either passing on a program\'s message, perhaps with some accesses to the\nhandler\'s virtual memory space, or passing on the operator\'s reply, again possibly\nwith some accesses to the handler\'s virtual memory space. The description o` this\nclass is parameterized with respect to the number of programs that can be handled.\n[message_interpreter]: SUBSYSTEM CLASS;\nQUALIFIERS: #, of programs END QUALIFIERS;\nP(;;\';\nBUFFER SUBCOMPONENTS; message OF [program-message]\nEND BUFFER SUBCOMPONENTS;\nEND INPORT;\nmessage out: OUT PORT;\nBUFFER SUBCOMPONENTS; message\xe2\x80\x94to\xe2\x80\x94operator OF [program message]\nEND BUFFER SUBCOMPONENTS;\nEND OU\' t PORT;\nreply in: IN PORT;\nBUFFER SUBCOMPONENTS; reply OF [operator\xe2\x80\x94replyli\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT;\nreply out: ARRAY[1::# of_y;rograms] OF OUT PORT;\nBUFFER SUBCOMPONENTS; reply_to program OF [operator\xe2\x80\x94,reply]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\nEND SUBSYSTEM CLASS;\n\nmessage_in: ARRAY [1::# of_programs] OF IN\n\n[message_interpreter]: SUBSYSTEM CLASS;\naccess: OUT PORT;\nBUFFER SUBCOMPONENTS; address OF [virtual address]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\ncollector: ARRAY[l::# ofjrogram;] OF CONTROL PROCESS;\nDOCUMENTATION; These control processes serve to funnel all\nof the messages from all of the programs into one stream\nand therefore to model that the message handler can\nhandle the messages in any order.\nEND DOCUMENTATION;\nmessage stream: LOCAL OUT PORT;\nBUFF\'=R SUBCOMPONENTS; hold message OF [program message]\nBUFFER SUP 4\'MPONENTF\n:AL OUT PORT;\nmnvir\n\ni\t\n\nT-r\n\nmh-rt\t\n\norrriv\n\nND\n\nt\n\nzl\nSET hold message(MY INDEX) TO message(MY_INDEX);\n\nSEND nu,ssagc,\xe2\x80\x94stream(MY\xe2\x80\x9eINDEX);\nEND ITERATE;\nEND MODEL;\nEND CONTROL PROCESS;\nhandler: CONTROL PROCESS;\nget message: LOCAL IN PORT;\nBUFFER SUBCOMPONENTS; one of the messages OF [program message]\nEND BUFFER SUBCOMPONENTS;_\nEND LOCAL IN PORT;\nMODEL; ITERATE; RECEIVE get message;\nITERATr PERHAPS;\nSET address TO defined;\n\nSEND access;\nEND ITERATE;\n\nSET message_ to , operator TO defined;\nSEND message out;\nMAYBE; COMMENT reply not always expected;\nRECEIVE reply--in;\n\nITERATE PERHAPS;\n^RI,GINAI; ^,\t\napp\t\n\n^pE\n\n^UALjT\t\n\nSET address TO defined;\nI$\t\n\nSEND access;\n\nEND ITERATE;\nFOR SOME i IN [1::# of programs];\nSET reply to_program(i) TO defined;\n\xe2\x80\x94\nSEND reply out(i);\nEND FOR;\nEND MAYBE;\nEND ITERATE;\nEND MODEL;\nEND CONTROL PROCESS;\nCONNECTIONS;\nFOR ALL i IN E1::# of programs];\nPLUG(collector(i)jmessage_stream, handlerjget_message);\nEND FOR;\nEND CONNECTIONS;\nEND SUBSYSTEM CLASS;\n\nThe connections among the ports of the control processes serve, as the comment in\nthe documentation of the collector control processes indicates, to set up a message\ncommunication network which funnels all of the messages into one stream. This network, when there are four programs, may be graphically represented as in Figure 2.\nA further elaboration of the message interpreter, given later, will indicate that\nan alternative communication network is really used. This one, and the models of\nthe control processes, serve to give an abstract description of the interactions\nof this part of the operating system with the other parts of the operating system.\nThe remaining major part of the operating system is the spooling subsystem. In\nthe following model of this part, we exhibit an alternative to funnelling message\nfrom many sources into one stream \xe2\x80\x94 the spooler is set up to poll the various\nsources of requests in some nondeterministic (at this point anyway) order.\n\nr\t\n\ni\t\n\n`\t\n\nf\nmessage_in(1)\n\nrepl _ t(1)\n\n22\n\nrep ^ ou 2)\nre\n\ny_ t(3)\t\n\ncoll ctor(1)\t\n\nmessage in(2)\n\nr ply , it(4\ncone tor(2)\n\ncolt\t\n^^\t\n\ntor(3)\n\n\xe2\x80\xa2. messag _in(3)\n\nreply__i\n\nmessage`\t\n\ncoll ctor(4)\n\naccess\n\nFIGURE 2\n)i\n[spooling\xe2\x80\x94system]: SUBSYSTEM CLASS;\naccess: OUT PORT;\nBUFFER SUBCOMPONENTS; address OF \t [virtual \xe2\x80\x94address]\n[virtual address]\nEND BUFFER SUBCOMPONENTS;\nOUT PORT;\nto operator: OUT PORT;\nBUFFER SUBCOMPONENTS; message OF [program message]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\nfrom operator: IN PORT;\nBUFFER SUBCOMPONENTS; reply OF [operator\xe2\x80\x94reply]\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT;\nEND SUBSYSTEM CLASS;\n[spooling system]: SUBSYSTEM CLASS;\nQUALIFIERS; # of user programs END QUALIFIERS;\nread \xe2\x80\x94request\n_in: ARRAYY[l::# of user \xe2\x80\x94 Programs]IN PORT;\nOF\nBUFFER SUBCOMPONENTS; program read request\nOF [read request message] \t\nEND BUFFER SUBCOMPONENTS;\t\nEND IN PORT;\nread request out: OUT PORT;\nBUFFER SUBCOMPONENTS; read request OF [read\xe2\x80\x94request\xe2\x80\x94message]\nEND BUFFER SUBCOMPONENTS;\nEND OUP\' PORT;\n\nread car-: IN PORT;\nBUFFr SUBCOMPONF " !T S: card image OF [card]\n`t!FFER SUBCOMPONENT 7 ;\nLND 1\'! faU\'t^^`;\n\ni\nI\n\nBUFFER SUBCOMPONENTS; dc:livc:reci^cardimay^: OF [card]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\nprinter control in: ARRAY[1::,1 of user programs] OF IN PORT;\nBUFFER SUBCOMPONENTS; signal OF \'Tcarriage ,Ac:ontrol signal]\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT;\nprinter control out: OUT PORT;\nBUFFER SUBCOMPONENTS; signal_to__printer\nOF [carriage .\xe2\x80\x94control \xe2\x80\x94signal]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\nline contents in: ARRAY[1::11 of user programs] OF IN PORT;\nBUFFER SUBCOMPONENTS; line OF [print\xe2\x80\x94line]\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT;\nline contents out: OUT PORT;\nBUFFER SUBCOMPONENTS; line to y rinter OF [print line]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\nspooler: CONTROL PROCESS;\nMODEL; ITERATE; SELECT;\n(PERHAPS) COMMENT send a message to tho\noperator;\nSET message TO defined;\nSEND to operator;\nMAYBE; RECEIVE from operator;\nEND MAYBE;\n(PERHAPS) COMMENF read or write a location\nin virtual memory space;\n\nSET address TO defined;\nSEND access;\n(OTHERWISE) COMMENT service a request\nfrom one of the user\nprograms;\n\nFOR SOME i IN [1::# of user_programs];\nMAYBE; RECEIVE rcadrequest_in(i);\n\nSET read request TO defined;\nSEND read request out;\nRECEIVE read card;\n\nSET delivered_\nccard image(i)\n\nTO card ^image;\nSCND read care! out(i) ;\n_\nELSE:\t\nJiECEIVE printer control_in(i);\n\nSET signaly^to_printer\nTO defined;\nSEND printer__control _\nout;\n\nMAYBE;\t\n\nC,ECEIVE line contents_in(i);\nSET line _to-yrinter\nTO line(i);\nSEND line contents out;\nEND MAYBE;\n\nEND MAYBE;\nEND SELECT;\nEND ITERATE;\nEND MODEL;\nEND CONTROL PROCESS;\nEND SUBSYSTEM CLASS;\n\n23\n\n+i\n\nThis concludes the description of all of the components for the operating system\'. 24\nThe remaining step at this level of modelling is to describe the operating system\nitself, indicating its componentry and the network of communication pathways\namong the components.\n[operating system]: SUBSYSTEM CLASS;\nQUALIFIERS;# of user_programs END QUALIFIERS;\nSUBCOMPONENTS;\nprograms ARRAY[1::# of user_programs] OF [program],\nmemory system OF [memory control system],\nconsole OF [operator console],\nreader OF [card reader],\nhard copy OF [printer],\ntranslator OF [address translator],\ninterpreter OF [message interpreter(# of userrograms+l)],\nspool OF [spooling system(# : of user^programs)e\nT\nEND SUBCOMPONENTS;\t\nCONNECTIONS;\nPLUG (translatorlactual .. space, memory systemlchannel);\nPLUG (interpreterlmessa gje out, consolelmessage_in);\nPLUG (consolelreply out, interpreter reply_in);\nPLUG (interpreter access, translator virtual space);\nPLUG (spoollread request : out, reader request\xe2\x80\x94in);\nPLUG (reader card out, spoollread card);\nPLUG (spool printer control out, hard copy carriage control);\nco\nPLUG (spool line contents out, hard copyJ ,ents);\nPLUG (spool access, translator virtual space);\nPLUG (spool to operator, interpreterimessage_iri(1));\nPLUG (interpreter1reply out(1), spoollfrom operator);\nFOR ALL i IN [1::# of user_ programs];\nPLUG (program(iTIcard request, spoollread request_in(i));\nPLUG (spoollread card out(i), program(i);read card_);\nPLUG (program(i) printer._control, spoonprinter control in(i));\nPLUG (program(i) line contents, spoollline contents in(T));\nPLUG (program(i) to operator, interpreter message_in(i+1)\nPLUG (interpreterJreply out(i+1), program lfrom operator);\nPLUG (program(i)laccess, translatorlvirtual_space);\nEND FOR;\nEND CONNECTIONS;\nEND SUBSYSTEM CLASS;\nThe communication network that is set up by this description is essentially that\ngiven in Figure 1 in [Riddle 72].\n**********\nIn [Riddle 72] the level of modelling for the operating system is elaborated for\neach of the major operational parts of the operating system. For purposes of example, we will carry that elaboration out for the message_interpreter and\naddress \xe2\x80\x94translator parts of the operating system, The elaboration of the\nspooling system, using DDN, is left as an exercise.\nFor the address translator, we need first: to model the external storage that is\nused to hold paged-out portions of the virtual spaces.\n[external storage]: SUBSYSTEM CLASS;\nread request: IN PORT;\nBUFFER SUBCOMPONENTS; request OF [io_request]\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT;\nwrite request: IN POR\nBUFFER SUBCOMPONE r\'\t\nrite request OF [io request]\n\xe2\x80\x94\nBUFFER SIJu^u +ru,,..NT5;\t\n\n\t\n\nI\t\n\nI\nR\n\'i\nx\n\n25\n\nENO BUFFER CONDITIONS;\nEND IN PORT;\nread done: OUT PORT;\nBUFFER SUBCOMPONENTS; signal OF [io.done_signal]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT,\nwrite done: OUT PORT;\nBUFFER SUBCOMPONENTS; write signal OF (io.\xe2\x80\x94done\xe2\x80\x94signal]\nEND BUFFER SUBCOMPONENTS\nEND OUT PORT;\nio: CONTROL PROCESS;\nMODEL; ITERATE; MAYBE;\nRECEIVE read request;\nSET signal TO accomplished;\nSEND read done;\n-ELSE;\t\nRECEIVE write request;\nORIGINAL\' PAGE\' Ig\t\nSET write signal TO accomplished;\nQE PO.Oj& QUU7 \t\nSEND write done;\n. 7X\nEND MAYBE;\nEND ITERATE;\nEND MODEL;\nEND CONTROL PROCESS;\nEND SUBSYSTEM CLASS;\n[io request]: MONITOR CLASS;\nSTATE SUBSETS; read, write END STATE SUBSETS;\nEND MONITOR CLASS;\n[io done signal]: MONITOR CLASS;\nSTATE SUBSETS; accomplished END STATE SUBSETS;\nEND MONITOR CLASS;\nWe have used the buffer conditions construct of DDN to indicate that only write\nrequests may come in through the write request port.\nWe also need a semaphore.\n[semaphore]: MONITOR CLASS;\nSTATE SUBSETS; uninitialized, zero, one\nEND STATE SUBSETS;\nDOCUMENTATION; This is a binary semaphore which may be used\nfor mutual exclusion. The operation of the procedures is\nnot elaborated here \xe2\x80\x94\n\nthf;y\n\nmay be "programmed" using\n\nsignals and waits upon condition variables.\nEND DOCUMENTATION;\ninitialize: PROCEDURE;\nTRANSITIONS; uninitialized - one\nEND TRANSITIONS;\nEND PROCEDURE;\np: PROCEDURE;\nTRANSITIONS; one -r zero; zero _r zero\nEND TRANSITIONS;\nEND PROCEDURE;\nv: PROCEDURE;\nTRANSITIONS; zero -r one\nEND TRANSITIONS;\nEND PROCEDURE;\nEND MONITOR CLASS;\nNow we can s pecify the parts of t he address translator as controlp rocesses.\n\nr\n\n[address translator]: SUBSYSTEM CLASS;\nvirtual space: INPORT;\nBUFFER SUBCOMPONENTS; v addra-is OF [virtual address]\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT;\nactual space: OUT PORT;\nR\nBUFFE SUBCOMPONENTS; a .address OF [real address]\nEND BUFFER SUBLOMPONRNfS;\nEND OUT PORT;\nSUBCOMPONENTS;\nstorage OF [external storage],\nmutex OF [semaphore] \xe2\x80\x94\nEND SUBCOMPONENTS\ncheck: CONTROL PROCESS;\nset up swap: LOCAL OUT FURT;\n(SUFFER SUBCOMPONENTS; signal OF [activate signal]\nEND BUFFER SUBCOMPONENTS;\nEND LOCAL OUT PORT;\nBODY; ITERATE; RECEIVE virtual \xe2\x80\x94space;\nspace;\nmutex.p;\naccess the page tables;\nmutex.v;\nIF PERHAPS\nTHEN a address.assign;\nSEND actual space;\nELSE signal.assign;\n\n26\n\nSEND set_upjwap;\nEND IF;\n\nEND ITERATE;\nEND BODY; END CONTROL PROCESS; END SUBSYSTEM CLASS;\nIn this control process definition, we have used a body textual unit to indicate\nthat what is being defined is an actual part of the subsystem rather than ,just\na model. Within the body, we have used nondeterminism to indicate that it is not\nyet completely specified as to how the decision is made as to whether the page is\nin the actual memory system or on external storage. This is not really legal in\nDDN \xe2\x80\x94 a legal description would require the definition of a flag variable that\nwas set (nondeterministically) to either true or fals e within the critical section\nand was used to control the subsequent fl(w of processing.\nThe definition of the address \xe2\x80\x94translator is completed with the following textual\nunits.\n[address translator]: SUBSYSTEM CLASS;\nswap: CONTROL PROCESS;\nwait for a ctivation:\t LOCAL IN PORT;\nBUFFER -\'.JBCOMPONENTS; signal\t OF [activ ; \'-_signal]\nEND BUFFER SUBCOMPONENTS;\nEND LOCAL IN PORT;\nread request:\t LOCAL OUT PORT;\nBUFFER SUBCOMPONENTS; request OF [io \xe2\x80\x94request]\nEND BUFFER SUBCOMPONENTS;\nEND LOCAL OUT PORT;\nread done:\t LOCAL IN PORT;\nBUFFER SUBCOMPONENTS; signal OF [io done signal]\nr\nEND BUFFER SUBCOMPONENTS;\nEND LOCAL\t IN PORT;\nwrite request:\t LOCAL OUT PORT;\nBUFFER SUBCOMPONENT`\': write request OF [io_request]\n! R(\'\t \'ONENTS;\nEND BUFFER\t\nEND LOCAL OUT\n-dan .\t LOCAL\t li p\t\ni t e^_\n\ni w\xe2\x80\x9e\n\nr\n\nIt\n\nT\n\n\t\nEND BUFFER SUBCOMPONENTS;\n\n27\n\nEND LOCAL IN \'PORT;\n\nBODY; ,ITERATE; RECEIVE wait For activation;\nmutex.p: COMMINT check for page unchanged;\nmutex.v;\n\nIF PERHAPS\nTHEN write request.assign;\n\nSEND 4rite request;\nRECEIVE write \xe2\x80\x94done;\nEND IF;\n\nrequest.assign;\n\nL71^GX^;I\t\n\nSEND read request;\n\nRECEIVE read done;\n\nmutex,p; COMMENT update the page tables;\nmutex.v;\n\n-to0j? Q \'l\nU 1^;, lS\t\nill,\t\n\na address.assign;\nSEND actual\xe2\x80\x94space;\nEND ITERATE;\nEND BODY;\n\nEND CONTROL PROCESS;\nEND SUBSYSTEM CLASS;\n[address translator]: SUBSYSTEM CLASS;\nCONNECTIONS;\nPLUG (checkiset up_swap, swapiwait for activation);\nPLUG (swapiread request, storageiread request);\nPLUG (storageiread done, swaiI read done);\nPLUG (swapiwriterequest, storageiwrite request);\nPLUG (storageiwrl -te done, swapiwrite done);\nEND CONNECTIONS;\nThe graphical representation of this connection network is essentially that appear-\n\ning as Figure 6 in [Riddle 72]. The major difference is that in the 1 = igl)" ,^ in\n[Riddle 72], the semaphore is represented as a link process because the precursor\nof DDN did not have the concept of monitor class.\nThis elaboration indicates one of the major purposes of control processes in addition to their role in modelling. When components within a subsystf"Il arc particular to that subsystem, a body for a control process alay be prepared to indicate\nthe algorithm for the message handling carried out by the component. DDN would\nallow a class definition to be prepared and then an instance of that class to be\ndeclared as a subcomponent within the subsystem \xc2\xad as was done for the ex^%\xc2\xad ernal\nstorage component. But it is often sufficient to indicate the component directly\nas a control process body, and this serves the additional purpose of drawing a\ndirect correspondence between the subsystem\'s modelled be avior and the operation\nof the subsystem\'s components.\nIn these textual units, we have again used procedures named assig n. We should\ndefine these within the class definitions, but this is not roally very illustrativF, so we will skip that.\nFor the elaboration of the message__interpreter, we will not only specify the\noperation of some of its components, but will also elaborate the description with\nrespect to the types of messages that are processed. The intent of this elaboration is to specify some aspects of conversations between a program and the operator. First, we elaborate t;e types of messages that can be sent by the programs\nto the operator.\n\nV\n\n\t\n[program message]: MONITOR CLASS;\nSTATE SUBSETS; write, write_and w wait, terminate\nEND STATE SUBSETS;\nset to terminate: PROCEDURE;\nTRANSITIONS;\t\nterminate\nEND TRANSITIONS;\nEND PROCEDURE;\nEND MONITOR CLASS;\n\n26\n\nWe have included the procedure set to terminate because it will be needed in later\ndescriptions.. The state ,ubsets indicate that the program may send a message to\nthe operator without a fiply expected (write), send a message with a reply expected\n(write and wait), or indicate that the conversation with the operator may be termi-\n\nnated.\xe2\x80\x94\nIn the elaboration of the message_ interpreter, it will attach an identification\nof the originating program to the message before passing it on to the operator.\nThus we need a class definition that describes these coded messages.\n[encoded message]: MONITOR CLASS;\nQUALIFIERS; #_of_programs END QUALIFIERS;\nSTATE VARIABLES;\nid: VALUES (1::# of_programs),\ncontent: VALUES Tmessage, null)\nEND STATE VARIABLES;\nSTATE SUBSETS;\nwrite: <<--, content=message>=,\nwrite and wait: <<--, content = message\xc2\xbb ,\nterminate: <<--, content=null\xc2\xbb\nEND STATE SUBSETS;\nassign: PROCEDURE;\nPARAMETERS:\n\nid VALUE OF [1::#^ of _programs],\nmessage _to_be sent VALUE OF [program message]\nEND PARAMETERS;\nTRANSITIONS; message _to be_sent=write -*write,\nmessage_to_be sent=write and wait -> write_ and_ wait,\n\nmessage_-tobe_sent=terminate- -^ terminate\nEND TRANSITIONS;\nEND PROCEDURE;\nEND MONITOR CLASS;\nWe also need similar class definitions for the messages sent from the operator to\nthe program.\n[operator_reply]: MONITOR CLASS;\nSTATE SUBSETS; ans, suspend\nEND STATE SUBSETS;\nassign: PROCEDURE;\nPARAMETERS;\nreply to be sent VALUE OF [enco,ied _\nreply]\nEND PARAMETERS;\t\nTRANSITIONS; reply _to_be_sent=ans \t\nand\nEND TRANSITIONS;\nDOCUMENTATION; This procedure may not be legally invoked\nwhen the operator has sent a suspend message.\nEND DOCUMENTATION;\nEND PROCEDURE;\nEND MONITOR CLASS;\n\nr\n[encoded reply]: MONITOR CLASS;\t\nQUALIFIERS;# of_programs END QUALIFIERS;\n\nSTATE VARIABLES;\nid: VALUES (1::# of programs),\ncontent: VALUES Trnessagr., null)\nEND STATE VARIABLES;\nSTATE SUBSETS;\n\nans : <<--, content message\xc2\xbb ,\nsuspend: <<--, content\xe2\x80\x94null,\xe2\x80\x94\nEND STATE SUBSETS;\nQ\xe2\x96\xba\nfind id: PROCEDURE;\t\nQ\n4441\nPARAMETERS;\t\n\\\nRESULT OF [1::#_of_prograni\t\n^bqG^\nEND\nPARAMETERS;\nEND MONITOR CLASS;\nWith these monitor classes, we are in a position to give the elaboration of the\nmessage_.interpreter.\n[message_ interpreter]: SUBSYSTEM CLASS;\nQUALIFIERS; # ofrograms END QUALIFILRS;\nmessage_ in: ARRAY[1::# of_ .programs] OF INPORT;\nBUFFER SUBCOMPONENTS; message OF [program message]\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT;\nmessage out: OUT PORT;\nBUFFER SUBCOMPONENTS; message . to_ operator\nOF [oncoded message(# of-programs)]\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\nreply in: INPORT;\nBUFFER SUBCOMPONENTS; reply OF [encoded reply(1\' of jrograrns)]\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT;\nreply out: ARRAY[1::# of_programs] OF OUT PORT;\nBUFFER SUBCOMPONENTS: reply_to_program OF [operator\xe2\x80\x94reply]\nEND BUFFER SUBCOMP01ENTS;\nEND OUT PORT;\naccess: OUT PORT;\nBUFFER SUBCOMPONENTS: address OF [virtual\xe2\x80\x94address]\nEND BUFFER SUBCOMPONENTS:\nEND OUT PORT;\nSUBCOMPONENTS;\nmutex OF [semaphore]\nEND SUBCOMPONENTS;\ntransfer: ARRAY[1::# of_p rograms] OF CONTROL PROCESS;\npass message_in: LOCAL OUT PORT;\nBUFFER SUBCOMPONENTS; passed message OF [program message]\nEND BUFFER SUBCOMPONENTS,\nEND LOCAL OUT PORT;\nMODEL; ITERATE; RECEIVE message in(MY INDEX);\nSET passed message(MY_INDEX) TO message(MY-_INDEX);\nSEND pass message_in(MY_INDEX);\nEND ITERATE;\nEND MODEL;\nEND CONTROL PROCESS;\nencode: ARRAY[1::# of programs] OF CONTROL PROCESS;\nget \xe2\x80\x94message\n_in: LOCAL. 1N PORT;\nBUFFER SUBCOMPONENTS; message from_progran>_or decode\nOF\xe2\x80\x94[program message\nEND BUFFER SUBCOMPONENTS;\nEND LOCAL IN PORT;\n:_ .. _\n\n_.\t\n\n_\t\n\n_I34DY_:_ __ ITERATE\n\n29\n\n30\nRECEIVE get _message in(MY_INDEX);\nmutex.p;\nWHILE message from_p rogram or^decode(MY_INDEX)\nwrite and wait;\nITERATE PERHAPS;\naddress.assign;\nSEND access;\nEND ITERATE;\nmessage_to.operator.assign(MY_INDEX,\n\nmessage_fromorogram or_ decode(MY_INDEX)) ;\nSEND message_out;\nRECEIVE get_message_in(MY_INDEX);\nEND WHILE;\nIF message from_program or decode(MY_INDEX)\n= write;\nTHEN: ITERATE PERHAPS;\naddress.assign;\nSEND access;\nEND ITERATE;\nmiy ssage to_opc-rator.assign(MY_INDEX,\nmessage._from_program or decode(MY_INDEX));\nSEND message out;\nEND IF;\n\ninutex.v;\nEND ITERATE;\n\nEND BODY;\nEND CONTROL PROCESS;\ndecode: CONTROL PROCESS;\ntransfer suspend: ARRAY[1::# ofo rograms] OF LOCAL OUT PORT;\nBUFFER SUBCOMPONENTS: term _message OF [program message]\nBUFFER SUBCOMPONENTS;\nEND LOCAL OUT PORT;\nLOCAL SUBCOMPONENTS;\nid OF [1::# of programs]\nEND LOCAL SUBCOMPONENTS;\nBODY; ITERATE;\nRECEIVE reply in;\nreply.find_id-Cid);\nIF reply = suspend\nTHEN; term message(id).set_to_terminate;\nSEND transfer suspend(id);\nELSE; reply_to_proaram(id).assign(reply);\n\nSEND reply__out(id);\nEND IF;\nEND ITERATE;\n\nEND BODY;\nEND CONTROL PROCESS;\nCONNECTIONS;\nFOR ALL i IN [1::# of_programs];\nPLUG (transfer(T)1pass message in,\nencode-Ci)lget message_in);\nPLUG (decode transfer suspendTi),\nencode(i)lget_message_in);\nEND FOR;\nEND CONNECTIONS\nEND SUBSYSTEM CLASS;\nThis completes tho elaboration of the me,,sage_interpreter. It remains to upd4te\nthe model of the )erator\'s console to reflect the new level of modelling\nachieved in the\t\n-1 of the message_interpreter,\n\nti\n\n-\n\n\t\n\n[operator console]: SUBSYSTEM CLASS; \t\nDOCUMENTATION; This models the console and the operator\nusing it.\nEND DOCUMENTATION;\nmessage_in: IN PORT;\nBUFFER SUBCOMPONENTS; message OF [encoded _message(#! oforograms)]\nEND BUFFER SUBCOMPONENTS;\nEND IN PORT;\nEND SUBSYSTEM CLASS;\n\n31\n\n[operator console]: SUBSYSTEM CLASS;\nreply out: OUT PORT;\nBUFFER SUBCOMPONENTS; reply OF [encoded reply(# ofo rograms)]\n\nEND BUFFER SUBCOMPONENTS;\nEND OUT PORT;\noperator: CONTROL PROCESS;\nLOCAL SUBCOMPONENTS; id OF [id::l#_of_programs]\nEND LOCAL SUBCOMPONENTS;\nBODY; ITERATE;\nRECEIVE message in;\nmessage.find_idTid);\nIF message = write and wait;\nTHEN; reply.set-id(id);\nreply.set type;\n0AIG INAI: PAGE IS\nSEND reply_out;\n\t\n,QE Wp$ QUA\nIF reply = suspend AND PERHAPS;\nQU\t\nTHEN; reply.set some id;\nreply.set message\n;\nSEND reply out;\nEND IF;\nEND IF;\nEND \'\nITERATE;\nEND BODY;\nEND CONTROL PROCESS;\nQUALIFIERS; #i ofo rograms END QUALIFIERS;\nEND SUBSYSTEM CLASS;\nThis description requres the definition of four procedures to operate upon encoded\nreplies.\n\'[encoded reply]: MONITOR CLASS\' set id: PROCEDURE;\nPARAMETERS;\nid VALUE OF [1::#i oforograms]\nEND PARAMETERS;\nEND PROCEDURE;\n\'[encoded reply]: MONITOR CLASS\' set_type: PROCEDURE;\nTRANSITIONS; -> ans, -> suspend\nEND TRANSITIONS;\nEND PROCEDURE;\n\'[encoded reply]: MONITOR CLASS\' set\xe2\x80\x94some\xe2\x80\x94id: PROCEDURE;\n\xe2\x80\x94\nEND PROCEDURE;\n\'[encoded reply]: MONITOR CLASS\' set message: PROCEDURE;\nTRANSITIONS; -)- ans\nEND TRANSITIONS;\nEND PROCEDURE;\nNote the use of nondeterminism in the procedure set type. This makes the description of the operation of the operator_ console be a nondeterministic one even\nthough a body is given for the control process.\n\n'