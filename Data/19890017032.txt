b"Memory Protection\n\nPete? J . D:tming\n\n21 July 1988\n\nRIACS Technicai Repori 88.17\n\nNASA Cooperative Apeerncnt Sumber If OC 2-38 i\n\n[ N AS A-CR-\n\n18 49 6 1)\n\n1Research I n s t .\nScience) 1 4 p\n\nN89 -2640 3\n\n!!l E !OR Y PH 0TEC TIOW\nl\nfor Advanced Computer\nCSCt\n\n09B\nUnclas\nG3/60\n\n0 2 179 13\n\nRlACS\nResearch Institute for Advanced Computer Science\n\nMemory Protection\n\nP e t e r J. Denning\n\nResearch Institute \xe2\x82\xacor Advanced Computer Science\nNASA Ames Research Center\n\nRIACS Technical Report 88.17\n21 July 1988\n\nAccidental overwriting of files or of memory regions belonging to other programs,\nbrowsing of personal files by superusers, Trojan horses, and viruses are examples of\nbreakdowns in workstations and personal computers that would be significantly\nreduced by memory protection. Memory protection is the capability of an operating\nsystem and supporting hardware to delimit segments of memory, to control whether\nsegments can be read from or written into. and to confine accesses of a program to its\nsegments alone. The absence of memory protection in many operating systems today is\nthe result of a bias toward a narrow definition of performance as maximum\ninstruction-execution rate. A broader definition. including the time to get the job\ndone, makes clear that cost of recovery from memory interference errors reduces\nexpected performance. The mechanisms of memory protection are well understood,\npowerful, emcient, and elegant. They add to performance in the broad sense without\nreducing instruction execution rate.\n\nThis is a preprint of the column The Scirnce of Computing for\nAmerican Scientiet 76, N o . 5 (Septernber-October 1988).\nWork reported herein was supported in part by Chbperative Agreement NCC 2-387\nbetween the National Aeronautics and Space 4dministration (NASA)\nand the Universities Space Research Association (USRA).\n\nMemory Protect ion\n\nPeter J. Denning\nResearch Institute for Advanced Computer Science\n\n21 July 1988\n\nYour program contains an error that overwrites an important input file during a test. Another error makes it calculate an index outside the subscript range\nof an array and incorrectly read a value from storage allocated t o another array.\n\nA program running concurrently with yours accidentally writes into your\nmemory region, destroying your program and data files. An entry in a routing\ntable is corrupted by a power failure a t a network switching node; copies of the\ncorrupted data propagate throughout the network, producing a crash that leaves\nyou isolated. A system programmer with superuser privileges browses your\nprivate, read-only mail files. A program you borrow contains a Trojan horse\nthat steals or erases some of your files. A program you obtained from a network\nbulletin board contains a virus that attacks your operating system and later\nerases some of your files.\n\n2/Memory Protection\n\n88.17 (21 July 1988)\n\nThese nightmarish examples illustrate breakdowns that can occur in the\noperation of computers when memory protection is inadequate or missing.\nMemory protection is the capability of an operating system and supporting\nhardware to delimit segments of memory, to control whether segments can be\nread from or written into, and to allow access to segments of a program rather\nthan the whole of it. The protection can be extended t o files stored on disks.\nMemory protection exemplifies the principle that programs should operate\nwith the least privilege required to perform their tasks. Where memory protection prevails, a program cannot write into an input file, refer outside a segment\ncontaining a particular array, or refer outside its own set of segments. A power\nfailure cannot write into a read-only table, a superuser cannot automatically\noverride another user's access specifications, a suspected Trojan horse cannot\naccess outside a limited set of segments during a test, and a virus cannot write a\ncopy of itself into any of a n operating system's segments.\nThe need for memory protection was apparent to the early designers of\ncomputer systems. In the late 1950s, the Atlas computer at the University of\nManchester allowed several independent programs to reside simultaneously in\nthe main memory and included mechanisms that prevented their interfering with\neach other. Early time-sharing systems experimented with paged virtual\nmemory (IBM 360/67 in 1964), file access protection (MIT's CTSS in 1965), virtual machines (IBM M44/44X in 1966), segmented virtual memory (Honeywell\nhlultics in 1968, Burroughs B6700 in 1970), and capability-based addressing\n\n88.17 ( 2 1 July 1988)\n\nMemory Protect ion / 3\n\n(Cambridge CAP computer in 1977). The concepts and design principles of\nthese early systems have been incorporated in today\xe2\x80\x99s large mainframe operating\nsystems. Excellent accounts of the various developments are provided have been\n\n,\ngiven by Jerry Saltzer and Michael Schroeder (1) Maurice Wilkes (2). Elliott\nOrganick ( 3 , 4 ) ,and Robert Fabry ( 5 ) .\nFew of the penetration and virus problems reported in the news would be\npossible in machines that use these old memory protection principles ( 6 ) . Yet\nmany of the small operating systems today, such as UNIXTMand the PCs in\nwidest use, contain relatively few or none of the memory protection mechanisms\nand are easily subverted. Many of the microprocessors in modern workstations\nand PCs, such as the Intel 80386 and Motorola 68000, contain the requisite\nhardware, but the operating system simply ignores it. How has this situation\narisen?\n\nA major reason for the disappearance of the old concern about memory protection is a bias toward performance, defined as the sustained instructionexecution rate of a machine. Designers of operating systems and hardware simply omit any mechanisms that do not, in their assessment, contribute directly t o\nperformance in this narrow sense. Not only do memory protection mechanisms\nnot increase the instruction-execution rate of a machine, but in the poorer implementations they noticeably retard it.\nIn the past several years, hoowever, a major change in attitude has taken\nplace among computer users. People regularly trust valuable information to\n\n4 \xe2\x80\x9834emory Protection\n\n88.17 ( 2 1 July 1988)\n\ncomputer files, and years of work can be destroyed in a few milliseconds. It is\nnow becoming fashionable to demand that computer systems be dependable and\ntrustworthy as well as fast. When performance is defined in a broad sense -minimizing the time to get a job done\n\n-- the possible loss of files and subsequent\n\ndelays in recovering from the loss can be seen as a serious degradation of\nexpected performance.\nIn what follows I will describe the main parts of a memory protection\nmechanism in an attempt to convey the elegance and power of the design. As we\nwill see, there need be no significant loss of speed, because most of the access\n\nchecking can be done by the hardware in parallel with the main computation.\nMost computers consist of processors, fast main memory, and disk memory.\nThe addressing interface between processor and main memory allows for two\ntypes of commands, \xe2\x80\x9cread A\n\n\xe2\x80\x9d\n\nand \xe2\x80\x9cwrite A .\xe2\x80\x9d To read, the processor places\n\naddress A into the address register and signals the memory: the memory copies\nthe value from address A into the data register and returns an acknowledge signal to the processor. To write, the processor places a value into the data register\nand address A into the address register, then signals the memory; the memory\nreplaces the contents of address A with the value and signals an acknowledgment t o the processor. If the memory detects an error during either of these\noperations. it returns a fault signal rather than an acknowledgment t o the processor.\n\n88.17 (21 July 1988)\n\nMemory Protect ion/ 5\n\nMost computations are composed of parts\n\n- the various program modules\n\nand data files -- which are stored in the disk memory as files. When one of these\nparts is loaded into main memory, it is called a segment. A segment can be\ndescribed with two numbers, B and L ; B is the base or starting address of the\nsegment, and L is the length; the segment occupies addresses\n\nB,B+1, * . .\n\n,B+L-1.\n\nWhen a segment is present in main memory, its descriptor ( B ,L ) can.be\nstored in a register within the addressing mechanism and used in the following\nway. The read and write commands are automatically interpreted relative to the\nbase address in the descriptor register; thus \xe2\x80\x9cread A\naddress B + A\n\n.\n\nWhile forming address B + A\n\nthat A is within the span of the segment\n\n\xe2\x80\x9d\n\nis actually applied to\n\n, the memory interface also checks\n\n-- that is, that OGA < L\n\n; if not, a\n\nrange error is signaled, and the processor is not allowed to complete the access to\naddress B + A\n\n.\n\nThe descriptor can be extended to include a presence bit P , set to 1 when a\ncopy of the segment is loaded in main memory and otherwise to 0. If the segment is marked as not present the hardware signals a missing segment fault that\ninterrupts the addressing process and brings into execution a program to locate\nthe file in the disk system, load it, and set the presence bit of the descriptor to 1 .\nThis basic mechanism provides a processor with read and write access to\nexactly one segment, a mode of operation useful when all parts of a computation\nare stored in a single segment. It prevents a processor from reading or writing\n\nb/Memory Protection\n\n88.17 (21 July 1988)\n\nregions of memory assigned to any other computation. In practice, however,\nthere is a need to protect the separate parts of a computation\n\n- for example,\n\nwhen one of the parts is a borrowed program that might contain a Trojan horse\nor is a new program module that has not been fully tested. The mechanism\nmust be refined to allow a set of several descriptors to be associated with a computation.\nTo do this, each descriptor is marked with a unique key, and all the keyed\ndescriptors are stored in a table. When given a key, the addressing hardware\nsearches the descriptor table for an entry with that key. If the search succeeds,\nthe particular P\n\n, B , and L values are indicated as above. High speed associa-\n\ntive memories can be used to hold the descriptor tables so, that the search time\nis small compared to the time of a read or write command. Note that the keys\ndo not change as the segment is moved between the main and disk memories\n(differing presence bit values), relocated within the main memory (differing base\nvalues), or altered in size (differing length values). Thus a program\xe2\x80\x99s design is\nindependent of the details of physical storage, and a major source of programming errors is avoided (7).\nHow does a computation generate the keys corresponding t o the various\nsegments? Associated with the computation is a segment table that contains a\nlist of segment accessors, each of which consists of an access code (whose bits\nenable reading and writing) and a key that matches one of the descriptors. To\nuse this table, the processor must specify the segment within which a given\n\n88.17 ( 2 1 July 1988)\n\naddress falls; thus \xe2\x80\x9cread N\n\nMemory Protection/ 7\n\n,A\n\n\xe2\x80\x9d\n\nmeans read the value in address A of segment\n\nN . Using the accessor at position N of the segment table, the addressing\nhardware checks that reading (or writing) is permitted by the access code and if\n\nso initiates the search of the descriptor table; the rest is the same as the process\nof using a descriptor outlined above. As before, high speed associative memory\ncan be used t o keep these searches to a negligible fraction of the time for reading\nand writing. The full mechanism is summarized in the accompanying box.\nThis design handles shared segments elegantly. There is no requirement\nthat the computations sharing a given segment assign the same segment number\nt o it. Program code modules, which are read-only, are the most common candidates for sharing. All the user sessions employing the same text editor, for\nexample, can have accessors containing copies of the key for the descriptor of the\neditor\xe2\x80\x99s instruction code segment. The editor obtains access to text files by\nreferring t o separate segments, and the numbers of those segments can be passed\nto the editor as parameters. Because it is not necessary to have more than one\ncopy of the editor\xe2\x80\x99s code segment loaded in main memory, substantial savings of\nmemory are possible in multi-user systems.\n\nA simple extension of this mechanism increases its power substantially. A\ncomputation involving a set of segments can be regarded as a unit. For example, the set of programs for opening, closing, reading, and writing files can be\nencapsulated in a package along with segments containing private information\nabout the status and location of files in the disk storage system. A call on any\n\n8,\xe2\x80\x99Memory Protection\n\n88.17 (21 July 1988)\n\none of these four programs automatically switches the computation so that they\noperate with their own segment table, which is distinct from the segment table\nof the caller. The ability to encapsulate a package substantially increases its\nreliability, because none of the private data can be consulted or modified by any\nprograms other than those authorized to do so. Such a mechanism should\nprevent viral infection of package components.\nTo implement this extension, a computation number C stored in the processor is used to inform the addressing mechanism which segment table should\nbe used. An accessor for C consists of a code enabling \xe2\x80\x9ccall\xe2\x80\x9d and the key \xe2\x80\x9cC .\xe2\x80\x9d\n\nA segment number, say N , corresponding to an accessor for C is allocated in\nthe segment table of a computation authorized t o call C ; then the command\n\xe2\x80\x9ccall N\n\n\xe2\x80\x9d\n\nwill automatically invoke the entry procedure of C , and the processor\n\nwill begin using the segment table to C\n\n.\n\nFabry gives a full account of this\n\nmechanism ( 5 ) .\nWhere do the entries in the segment tables come from in the first place?\nThey come from the file system. Each user owns a tree of directories. Each\ndirectory, stored as a file on a disk, contains entries that point to other files by\ngiving their unique keys. Each entry also contains a field that points to an\naccess control list specifying names and access codes for that file. Thus, when\none of my computations attempts to open a file and load it into a memory segment, the operating system checks whether my name is on the access list of that\nfile; if so, it creates an accessor with that code whose key is the same as the file\xe2\x80\x99s\n\n88.17 ( 2 1 July 1988)\n\nMemory Protectionfg\n\nunique key.\n\nI have only scratched the surface of what can be done with the design outlined here. My intention has been simply to exhibit the design principles of\nmemory protection, and to suggest that they can be implemented with negligible\nimpact on instruction execution speed. The added benefits\n\n-- significantly\n\nincreased protection against faults and errors, reduction in exposure to Trojan\nhorses and viruses, and resistance against unauthorized access t o one\xe2\x80\x99s files - are\nwell worth the additional design expense.\nScientists and engineers should be much more forceful in expressing their\nconcerns about memory protection, so that future generations of workstations\nand personal computers willbe dependable and secure as well as fast.\n\nReferences\n1.\n\nJ. Saltzer and M. Schroeder. 1975. \xe2\x80\x9cThe pr3tection of information in computer systems.\xe2\x80\x99\xe2\x80\x99 Proc. IEEE 69, 9. September. 1278-1308.\n\n2.\n\nM. V. Wilkes. 1975. Time Sharing Computer Systems. Elsevier North Holland. 3rd Edition.\n\n3.\n\nE. I. Organick. 1972. The MULTICS Systems: A n Ezamination of Its Structure. MIT Press.\n\n~\n\n~~\n\n1O/Memory Protection\n\n4.\n\n88.17 ( 2 1 July 1988)\n\nE. I. Organick. 1973. Computer System Organitation: The B5700/6700\nSeries. Academic Press.\n\n5.\n\nR. Fabry.\n\n1974. \xe2\x80\x9cCapability-based addressing.\xe2\x80\x9d Communications of A CM\n\n17, 7. July. 403-412.\n6.\n\nP. J. Denning. 1988. \xe2\x80\x9cComputer viruses.\xe2\x80\x9d American Scientist 76, 3 .\nMay-June. 236-238.\n\n7.\n\nP. J. Denning. 1986. \xe2\x80\x9cVirtual memory.\xe2\x80\x9d American Scientist 74, 3. MayJune. 227-229.\n\n88.17 (21 July 1988)\n\nMemory Protection,\xe2\x80\x99ll\n\nAddressing for Memory Protection\n\nThe addressing mechanism for protected segments contains two levels of mappings that\ntransform a request like \xe2\x80\x9cread address A of segment\nthe proper memory location B + A\n\nN of computation C \xe2\x80\x9d into a reference to\n\n.\n\nThe upper level consists of segment tables, such as C 1 and C 2 , attached to computations\nthemselves; it associates a segment number\n\nN (1, 2, 3, 4 , ...) with an access code and unique key\n\nfor each segment. Access code R in the figure enables reading, and access code R W enables both\nreading a n d writing. A shared segment with key K can have different numbers and different\naccess codes in different computations.\nT h e lower level consists of a descriptor table attached to the memory; it records presence,\nbase, and length descriptors for each segment. The presence bit\n\nP is 1 if\n\na copy of the segment\n\nis in main memory; if P =0, the segment is in disk memory and must be located and loaded in\nmain memory before it can be used. The base B gives the starting address of a loaded segment.\nThe length L gives t h e number of consecutive addresses occupied by the segment. The last\naddress in the segment is thus B\n\n+L\n\n-1. Segments can be moved between levels of memory, relo-\n\ncated within main memory, o r changed in length without changing segment numbers, access\ncodes, o r keys or otherwise disturbing any component of a computation.\n\nTo read from a segment, a processor operating on behalf of computation C generates a\nrequest \xe2\x80\x9cread\n\nN , A .\xe2\x80\x9d The addressing mechanism looks a t entry N in the segment table for C ;\n\nif read access is permitted, it searches the descriptor table for K ; it then requests memory t o\nread from B + A\n\n, provided\n\nt h a t O<A\n\n< L . These steps can be completed in\n\na negligible fraction\n\nof the time the memory takes t o read. If any of the checks embedded in them fails, the address-\n\ning system stops the processor with a n error signal.\n\npRocEssoFl\n\nrequest\n\nADDRESSING MECHANISM\n\nnumber\nI\n\nc1\n\ndescriptor\ntable\n\naccess\ncode\n\nc2\n\nk eY\npresence\nbase\nlength\n\n"