b'N91-2o677\nThe\n\nAmes-Lockheed\nMonte\nNASA\n\nAmes\nM.S.\n\nMoffett\n\nField,\n\nOrbiter\n\nProcessing\n\nZweben\nResearch\n\nRobert\nLockheed\n\nCenter\n\n244-17\nCalifornia\n\n3251 Hanover\nPalo Alto,\n\n94035\n\nzweben@pluto.arc.nasa.gov\n\nSt. 0/9620\nB/259\nCalifornia\n94304\n\nKennedy\nSpace Center currently\nuses a three-tiered\napproach\nto developing\nschedules\nfor shuttle flights. At\nthe top level is the long range schedule.\nThis schedule represents multiple shuttle flights over several years.\nThe middle tier is developed\nabout\n60 days prior to the\nbeginning\nof the flight. At this time, the planning\nperson develops a flow that represents\nall of the activities\nthat must be performed\non the specific oribiter prior to\nlaunch.\nThe granularity\nof activities\ndeveloped\nat this\ntier is generally one OMI per activity.\nAn OMI (Orbiter\nMaintenance\nInstruction)\nessentially\ndescribes\na process\nthat must be performed.\nThis activity\ngenerally can be\nbroken into about 10 primitive\noperations\nthat must be\nperformed\non the floor. The third tier represents\nthese\nprimitive\noperations.\nDue to the large quantity of opera_\ntions and the liklihood\nof change, the third tier schedule\nis generated\neach day for the next week.\nThe scheduling\nprocess\nworks as follows.\nApproximately 60 days before the beginning\nof a flight, high level\nplanners\ncreate the middle tier schedule.\nThey are currently using a variant planning\napproach.\nThat is, they\nare starting\nfrom a pre-existing\nflow, removing work that\nwas unique to the previous flow, adding\nnew work specific to this flow, and then rescheduling\nthe activities.\nOnce finished, they perform\nCPM analysis\nto develop a\nschedule.\nThis schedule\nhas many resource\nconstraint\nviolations\nthat must be resolved.\nThe planner\nperson\nthen uses the target start dates and resource balancing\nto make the schedule\nto work.\n\nIntroduction\nDescription\n\nGargan\nAI Center\n\nby the shuttle crew. Most, however, are unaware of the\namount of work that\'s involved in preparing\na shuttle for\nlaunch. Preparing\nshuttles for launch requires successful\nand timely completion\nof many operations\nperformed\nby\nmany people.\n\nThis paper describes a general purpose scheduling system and its application\nto Space Shuttle Orbiter\nProcessing\nat the Kennedy\nSpace\nCenter.\nOrbiter\nprocessing\nentails all the inspection, testing, repair, and maintenance\nnecessary to prepare\nthe shuttle\nfor launch and\ntakes place within the Orbiter Processing\nFacility (OPF) at KSC, the Vehicle Assembly Building (VAB), and on the Launch Pad. The problena is extremely\ncombinatoric\nin that there are\nthousands of tasks, resources, and other temporal conditions\nthat must be coordinated.\nWe\nare currently building a scheduling tool that we\nhope will be an integral part of automating\nthe\nplanning and scheduling\nprocess at KSC. Our\nscheduling\nengine is domain independent\nand is\nalso being applied to Space Shuttle\ncargo processing problems\nas well as wind tunnel power\nscheduling\nproblems.\nThe significant\ntechnical contributions\nof our scheduling\nsystem are\n1) the ability to handle dynamic\nrescheduling\nwhile considering\nthe time it takes to reschedule, the optimization\ncriteria in the domain,\nand the amount of perturbation\nto the original\nschedule;\n2) the ability to represent arbitrary\nstate conditions\nthat change over time and the\nability to declare the requirements\nand effects\nthat activities\nhave in relation to these conditions; and 3) the explicit\nrepresentation\nand\nuse of search control knowledge so that domain\ninformation\ncan drive the scheduling\nprocess.\nOur scheduling engine is a constraint-based\nsystem implemented\nin CommonLISP\nthat runs on\na variety of platforms.\nWe have tested our system with real orbiter processing\ndata and have\nfound the results promising.\nIn the near future,\nwe plan to deploy an early prototype\nof the system which will be used to shadow the current\nscheduling\nprocess at KSC.\n\n1.1\n\nSystem\n\ngargan@laic.lockheed.com\n\nAbstract\n\n1\n\nScheduling\n\nof Problem\n\nMillions of people see or follow shuttle launches\neach\nyear. They are familiar with the kinds of work performed\n\n290\n\nOnce the flow has begun, the planning\nand scheduling\npeople keep a detailed\n72 hour schedule.\nThis schedule\nshows all activities\nthat are being performed.\nScheduling at this level is primarily\ndone based on past shuttle\nflights and via daily scheduling\nmeetings.\nDuring the\nmeetings,\nrepresentativies\nof the various\nwork groups\ndiscuss their resource requirements\nand target completion times. The person in charge of the meeting coordinates the dynamic\nrescheduling\nof the work to be performed.\nUnfortunately,\ndelays still occur.\nFor instance,\non one occasion work that was scheduled\ncould not be\nperformed\nbecause the necessary quality assurance\npeo-\n\npleweren\'t vailable.\na\nOthertimes,weather ould\nc\ncause\na delay certainwork.These\nin\nkindsof delays\narepart\nof therealityof executing\ntheschedule. thisdynamic\nIn\nchanging\nenvironment,is all themore\nit\nimperative\nthat\nthepeople charge\nin\nbeableto seepotentialmpactof\ni\n\nTask:\n\nReceiving\n\nStart:\nEnd\n\n[0 _]\n\ndecisions being made.\nKSC managers\ndo a super job\ncurrently, given the amount of information\nthey have. It\nis desirable to recognize a problem\nand be able to work\nwith the system to determine\na solution.\n\nDuration:\n\n1.2\n\nEffect:\n\nWhy\n\nUse\n\nA Heuristic\n\nOur\n\n[0_]\n[0 _]\n\nDuration:\n\n[0 _}\n\nUsage I:\n\n[0_]\n\n_\nUsage2:\n\nUsage2:\n\nApproach\n\nUsage I:\n\\\n\n_\n\n_\nType:\n\nOn the surface, it appears\nthat a good project\nmanagement tool is all that is required to manage\nthe scheduling\nof activities.\nKSC has been doing this at the second tier\nlevel and beginning\nto do this at the third tier as well.\nUnfortunately,\nthe project\nmanagement\ntools can only\naddress part of the problem.\nEach activity\nhas temporal\nrequirements,\nresource\nrequirements,\nand configuration\nrequirements.\nExisting\nproject\nmanagement\ntools can\nrepresent\nmost of the temporal requirements\nand some\nof the resource requirements,\nhowever, no tool can represent the configuration\nrequirements.\nGiven this, the\nbest any conventional\ntool can do is give you partial information.\nFor instance,\nthere\nare activities\n(hazardous\nopera.\ntions) that require the area to be cleared. When these activities occur, most other work can not occur. However,\nthere may be no requirement\nsaying that the hazardous\noperation must occur before or after other work. Conventional\nsystems have no way of expressing\nthis kind of\ntemporal\nconstraint.\nAdditionally,\nmuch of the work being performed\non\nthe orbiter requires\nthat the orbiter be in a specific configuration.\nAgain there may not be any hard temporal\nrequirement\nconnecting\nseveral activities,\nhowever,\none\nactivity\nmay change the state of the orbiter\nand later\nactivities\nmay require\nthat configuration.\nA simple example of this is requiring\nthat the orbiter bay doors be\nclosed to do certain\ntypes of tile work.\nHeuristic approaches\nto scheduling\nare not new. ISIS\n[Fox83] and then OPIS [SFO86] focused\non developing\na constraint\nbased job shop scheduling\nsystem.\nKSC\nhas also had scheduling\nwork done previously.\nEmpress [HJK*85] and Phits [Gar87] both focused on different aspects\nof planning\nand scheduling\nof cargo processing.\n1.3\n\n:: I 0:00\n\nTesting\n\nStart\nEnd:\n\nI 1123/91\n\nTask:\n\nElectrical\n\nPower\n\n[Bldg_Techs\n\nOty:\n\n5\n\nBldggTechs\n\n_\n\nTyoe:\nTe\\.oIclan_\nUse:\n\nI\n\nPool:\n\n...1\n\nI\n\n[Bus A Bus B .. ]\n\nOty:\n\nPool:\n\nI0\n\nUse:\n\nConsumable\n\nReusal_\n\nFunction:\nSet-to-Value\nState:\nLocation\nof Payloadl\nValue: Recelvlng-Dock\n\nFigure\nstraints\n\n1:\n\nis filtered\n\nTask\n\nbased\n\nRepresentation\n\nand\n\nthe\n\non the various constraints.\n\nUse\n\nof Con-\n\nThe schedul-\n\ning system searches the space of possible schedules for a\ntime when all variables\ncan be fixed and all constraints\nsatisfied.\nThe remainder\nof this paper describes\nthe process in\nmore detail.\nWe first introduce\nthe knowledge\nrepresentation we have utilized.\nThis description\nwill be of the\nvarious types of constraints\nwe are using. Next we describe a rule system we have recently added that allows\nthe user to encapsulate\nthe search control knowledge\nexplicitly rather than implicitly as is usually done. Finally,\nwe describe the process of rescheduling.\nRescheduling\nis\nespecially\ncritical\nto KSC since activity\nstatus\nis in a\nconstant\nstate of flux.\n2\n\nApproach\n\nWe have viewed KSC scheduling as a Constraint\nSatisfaction Problem (CSP). In our system, we represent most\ninformation\nusing variables.\nEach variable can take on a\nrange of values. Constraints\nare used to filter the values\nof the given variables.\nFor example,\nFigure\n1.3 shows\ntwo activities\nand some of the variables\nassociated\nwith\nthem.\nWe use constraints\nmaintain\nthe relationship\nbetween the start time, the end time, and the duration\nof\nan activity.\nAdditionally,\nusing constraints\nwe can express a requirement\nthat one activity\nmust start before\nthe other one can start (or similarly with the end time)\nor that one must precede the other. During the scheduling process,\nthe list of possible values for a given variable\n\n291\n\nKnowledge\n\nRepresentation\n\nScheduling\nknowledge\nis being\nrepresented\nvia constraints.\nConstraints\nare applied to the various variables\nthat are a part of the objects of the system. For instance,\nour major object in the system is the activity.\nActivities\ncontain many status slots. They also contain slots represented as variables\nsuch as the start time, end time,\nand duration.\nConstraints\ncan be tied between\nmultiple\nvariables to maintain\nsome consistency\nbetween\nvarious\nobjects.\nFor instance,\na constraint\nwould be used to state\nthat a resource that is needed for a specific activity must\nbe available\nduring the time of allocation.\nThe remainder of this section gives a brief overview of the types of\nconstraints\nwe represent.\n2.1\n\nResource\n\nRequirements\n\nConstraints\ncan be used to require specific resources for\nan activity.\nResource\nclasses can be represented\nhierarchically.\nEach resource\nclass can have one or mote\nresource pools associated\nwith it. Each resource pool\ncan have a capacity\nof 1 or more.\nA resource pool of\none is used to represent a specific individual\nor piece of\n\nequipment. Alternatively,\nif uniqueness\nis not of concern\nthe pools could contain many values. Using this type of\nresource, would result in allocating\none from the pool to\nthe activity, however, it wouldn\'t matter which one.\n2.2\n\nState\n\nbe done without\n2.4\n\nRequirements\n\nTemporal\n\ndone in the area.\n\nCalendars\n\nFinally, it is necessary to represent\nwhen the work can\nactually\nbe performed.\nWe represent this type of information in a calendar.\nA calendar\nspecifies when work\ncan be performed.\nIt takes into consideration\nholidays\nand daylight savings time. Each activity\nspecifies a calendar that should be used to determine\nwhen it should\nbe scheduled.\nThis is consistent\nwith the current way in\nwhich work at KSC is scheduled.\nThere are a variety of\ncalendars ranging from one 8-hour shift 5 days a week to\na 7 day 24 hour calendar.\n\nAn important\ndistinction\nbetween our system and others is our representation\nof state information\nand the\nuse of constraints\nto maintain\nthe proper state. For instance, most of the work on the shuttle requires that the\norbiter be in some particular state (for instance, the orbiter doors being closed). As was mentioned\nbefore, current systems cannot represent this information.\nIn our\nsystem, the activity representation\nhas been extended to\nsupport task requirements\nand task affects in addition\nto\nthe representation\nof states.\nA state is an object in our system that can take on\nmultiple values. We will eventually\nsupport finite state\nmachines,\nalthough\nwe currently\nsupport known state\nchanges.\nFor instance,\nthe orbiter contains\ntwo bay\ndoors. Each door can take values of opened, closed, or\nhalf-open.\nOther state information\nis represented\nsimilaxly. Activities\nnow can require that before the activity\ncan start the object (in this case the shuttles bay door)\nmust be open.\nConversly, an activity\ncan specify that\nas a result of executing the given activity\nthe following\nobject state will be changed.\nIn the above example, an\nactivity might specify that the pay doors are moved from\nthe open to closed position.\nThe task requirements\nand affects described\nabove are\nencoded as constraints\non the given activity.\nThese constraints must be maintained\nby the system in the same\nmanner\nas the other constraints.\nBy representing\nthis\ntype of information explicitly, the scheduler can take advantage of this type of knowledge when sequencing\noperations.\nScheduling systems\nthat have been developed\npreviously would have represented\nthis information\nimplicitly as precedence constraints.\nThis would reduce the\noverall flexibility of the system as well as make it more\ndifficult to reschedule\nactivities\nwhen problems arise. By\nusing the state information\nto constrain the activities,\nit\nallows a more flexable schedule.\n2.3\n\nother work being\n\n2.5\n\nRepresenting\n\nControl\n\nKnowledge\n\nOne of our goals in developing\nthis system was not to tie\nthe scheduling\nprocess too closely to the KSC domain.\nDifferent applications\nshould be scheduled\nin different\nmanners. There is always domain knowledge that can be\nutilized to more effectively schedule operations.\nThere is\na basic conflict here between adding in this domain specific control knowledge and still maintaining\ngenerality.\nOur desire would be to use a formal language to specify the control knowledge necessary\nto guide the scheduler through the search process.\nThis would allow the\napplications\ndeveloper to add specific control knowledge\nto the system to customize\nit for their application.\nCurrently, most scheduling\nsystems use LISP code to encode\nthe search strategy. The problem with this is that it implicitly requires the search process to be the same for all\napplications\nof the scheduling\nsystem.\nEven if a single\napplication\narea is all that was intended,\nthis approach\nalso fails because it restricts the end-user from being able\nto customize\nthe search process at some later date should\nthe need arise.\nAs a result of these issues, we are integrating\na rule\nlanguage\ninto our scheduler.\nThe user will encode all\nsearch control knowledge into the rule system. The system presently\ncontains\ngeneral knowledge\nencoded\nin\nrules. For instance,\none rule that plays a role in determining the task to schedule states that if there is a same\nstart or same end time relation between\ntwo tasks and\nthe second task is not scheduled,\nthen strongly prefer\nscheduling\nthis task next.\nAs we continue to develop this portion of the system,\nwe will be adding more KSC specific rules into the system. For example,\nthere are certain types of work that\nare prone to identifying\nunforseen\nproblems, so it is useful to do this work as early as possible so the problems\ncan be identified.\nThis type of domain specific information will eventually\nbe represented\nas a rule to the\nsystem.\n\nRelationships\n\nEven though some information\nshould be represented via\nstate constraints,\nother information\nstill should be represented via temporal constraints.\nSome of the most often\nused constraints\nare the precedence\nconstraints.\nOne\ntype of precedence relation states that activity-1\nmust\nbe completed before activity-2\ncan start.\nAll standard\noff the shelf project management\ntools allow this form of\nrepresentation.\nAdditionally,\nsome tools will also allow\nthe user to specify that one activity must begin before\nthe other one can begin (or end before the second one\nends).\nThe standard tools, however, do not generally\nallow the user to place delays on all the precedence relationships.\nIn addition,\nthey don\'t allow the user to\nexpress that two activities\ncan occur in any order, however, they can not happen at the same time. This form of\nmutual exclusion is necessary for constraining\nhazardous\noperations on the space shuttle. This type of work must\n\n3\n\nDynamic\n\nRescheduling\n\nOne of the most critical needs of KSC is the ability to\nreschedule the activities\nbecause work schedules are constantly changing.\nThere\'s a variety of reasons ranging\nfrom unanticipated\ntraining schedules\nto bad weather.\nWhenever\na problem arises, it is necessary\nfor the planning people at KSC to adjust schedules\nto handle the\nproblems proposing the appropriate\nwork around.\nWhile\n292\n\nthis is by far their worst problem, it is also one which is\nextremely\ndifficult to meet using the existing\ntools. Because of the lack of support\nfor the various kinds of constraints described above, planning\npersonnel\nhave used\nprecedence\nrelationships\nto force the schedule to take\nplace in a certain order. Doing this, however, reduces future flexibility in the schedule by arbitrarily\nusing precedence relationships\nwhere they are not really necessary\nAdditionally,\nthe planning\npersonnel\nforce the start time\nfor many activities\nin the schedule\nto be fixed rather\nthan relying on the constraints\nto determine\nnew start\ntimes. This often results in the work not being performed\nwhen scheduled\nbecause the orbiter is not in the appropriate configuration\nor the necessary\nresources are not\navailable. The resolution\nof these problems\nare often the\nsubject of the daily scheduling\nmeetings\ninvolving many\nKSC and Lockheed personnel.\nOur goal with our scheduling\ntool is to provide\nthe\nrescheduling capabilities\nto alleviate\nthe above problem.\nIn order to be successful,\nwe must provide\na tool that\nefficiently\ndetermines\nthe new schedule.\nOur approach\nhas been to investigate\nthe use of iterative\nimprovement\nscheduling algorithms.\nThis approach\ndiffers from traditional "AI" scheduling\napproaches\nin that they incrementally repair complete solutions to the scheduling\nproblem\nrather than systematically\nextending\nthe partial solution\nto the problem.\nOur approach\nhas led us to develop\na framework\n[Zweg0] that converges\non a solution\nby\nmaking local repairs to the violated\nconstraints\nof some\napproximately\ncorrect schedule.\nThis approach\nhas two\nadvantages\nover the other approaches.\nFirst,\nour approach is significantly\nfaster than conventional\nheuristic\nbased scheduling techniques.\nSecond, because of the nature of our algorithm,\na solution can be returned at any\npoint in the algorithm,\nwith the solution\nimproving\nthe\nlonger the algorithm\nis given to execute.\nOur algorithm\nis implemented\nin two phases. The first\nphase is the systematic\nrepair of all temporal\nconstraints.\nThe result is a schedule\nthat is consistent\nwith respect\nto temporal\nconstraints,\nbut is likely to contain resource\nand state varable constraint\nviolations.\nThis schedule is\nthe input to the second phase - constraint-based\nsimulated annealing.\nDuring this phase, the scheduler incrementally\nrepairs\nviolated resource and state-variable\nconstraints.\nThe remainder of this section describes\nthe\ntwo phases in more detail.\n3.1\n\nTemporal\n\nnal task that was moved, so the approach\nof taking the\nearliest unscheduled\ntask would no longer apply.\nWe decided\nto use Waltz\'s\nalgorithm\n[Day87] to address this anomaly.\nThe algorithm\nis based on changing\nthe intervals for each activity\nwhen shifted. Each change\ncauses the interval to be filtered so that each interval continues to represent\nthe range of times when an activity\ncan begin (or end). The algorithm\nbegins by rescheduling the changed\ntask. It then collects the activities\nthat\nhave temporal\nconstraint\nviolations.\nThose\nactivities\'\ntimes are then filtered by a similar\namount.\nThis algorithm\nhas the advantage\nthat it quickly\ndetermines\nplausable\nschedules\nwith minimum\namounts\nof change\nand works for the general class of constraints\nused by\nKSC.\nThe algorithm\nis not guaranteed\nto be successful.\nIf\nan activity\nhas been marked\nas permanent\nand an attempt is made to move it, then the algorithm\nwill return\nunsuccessfully.\nThis could be useful for addressing\nmilestones as well as activities\ndependent\non some natural\nevent (i.e. sunrise).\n3.2\n\nConstraint\n\nBased\n\nSimulated\n\nAnnealing\n\nThe second\nphase\nis based on simulated\nannealing\n[KGV83].\nIt begins with the scheduling\nassignment\nresulting from phase one of rescheduling\nand then evaluates a "cost" of the assignment.\nThe cost function\nfor\nour experiments\nis the number of constraints\nviolated for\nthe given assignment.\nThen, by repairing constraints,\nit\nsuggests\na new solution and evaluates\nits cost.\nIf the\nnew cost is an improvement,\nit adopts\nthe new assignment and continues.\nIf the new solution is worse, the algorithm adopts\nit with some probability.\nThis last step\nallows the algorithm\nto escape local minima.\nWe have\ncustomized\nthis general approach\nto constraint\nsatisfaction problems\nwhich is described in more detail elsewhere\n[Zweg0]. The basic algorithm\nis as follows (where T is a\nset of tasks with assignments\nmade in phase one):\nSolve(T)\'[\nOld = Cost(T);\nRepeat until Old <= *THRESHOLD* (\nNext = Find_New_Solution(T);\nNew = Cost(Next);\nIf New < Old Then _ Old = New; T = Next;)\nElse ( With probability P do\nOld = New;\nT = Next;}\n};\nSaveBestSolutionIfNecessary;\n)\n\nShift\n\nThe temporal\nshift, which is the first phase of our\nrescheduling\nalgorithm,\ntakes a desired change in start\nand end times for a given activity\nand creates a schedule\nwithout any temporal\nconstraint\nviolations.\nWe originally achieved\na consistent\nschedule by systematically\nshifting all activities\nwith temporal constraint violations\nin a fashion similar to those used by OPIS [OST88]. We\nlater discovered\nthat this approach\nby itself would not\nfill our needs because of constraints\ntying the end time of\none activity to the end time of another\n(or start time to\nstart time constraints).\nThese constraints,\nin conjunction with the more conventional\nconstraints\n(end time\nto start time) could lead the system back to the origi-\n\n3.2.1\n\nSystematic\nSchedule\n\nRepairs:\n\nFinding\n\na New\n\nIn our previous work, we concentrated\non simple local\nrepairs in order to investigate\nthe utility of the simulated annealing\nsearch framework.\nHere, we focus on\nfast rescheduling,\nwith a heuristic bias against schedules\nwith excessive work-in-process\n(WlP) time and against\nschedules that require radical perturbations\nto the original schedule. This bias is enforced by the repair strategies themselves.\nFirst, only those tasks involved in con293\n\nstraint violations\nare modified,\nand second, when tasks\nare moved they are not moved drastically.\nOur repair strategy\nalso exploits the knowledge\nthat\nany task move is likely to violate temporal\nconstraints.\nThus, after any constraint\nrepair causes a task to move,\ntemporal\nconstraint\nviolations\nare resolved first by executing the temporal\nshift algorithm\ngiven above.\nBecause these repairs explicitly\nexploit\nthe knowledge\nof\nhow repairs interact,\nthey are no longer local.\nThe following are two of the repair strategies\nemployed\nby the rescheduler:\n\nto use Chapman\'s\nterminology,\nmoving a white knight).\nIf this is impossible,\nthe task with the requirement\nis\nmoved to a point in time when the state variable is set\nappropriately.\nThis will move the task directly after the\nclosest white knight.\nIn either case, to perform\na move, thc temporal\nshift\nof phase one is employed\nwhich results in a temporally\nconsistent\nschedule.\n4\n\ncapacity(?start ?end ?resource):\nI. Deallocate this current resource.\n2. Try to find a pool that is available\nfrom ?start to Vend.\n3. If one exists, change ?resource to\nbe that pool and reallocate.\n4. Otherwise task = the task associated\nwith this constraint;\nnew-start = ?start + random(l .. I0)\n*c,d;\nnew-end = new-start + duration(task);\nTemporalShift(?task, new-start, new-end) ;\nThe constant c is a small,fixed\ntime unit (a day in the\npayload processing\ndomain)\nand d is a direction\n(1 or\n-1 ) that is set by the change that the user makes. The\nstrategy attempts\nto substitute\na new resource pool, but\nif that is impossible,\nit moves the requesting\ntask back or\nforward in time. After the task is moved, the temporal\nshift algorithm\nof phase one is executed\n- this systematically propagates\nthe change caused by tile repair to all\ntemporal dependents.\ntemporal-equals(?tl\n\n?t2 ?a ?v):\n\nFirst strategy:\nI. supporter = the first task after ?tl\nthat sets ?a = ?v;\n2. task = the task associated with this\nconstraint;\n3. new-end = start(task) - c;\n4. new-start\n= new-end\n- duration(supporter);\n8. TemporalShift(supporter,\nnew-start,\nnew-end);\n\n2.\n\n3.\n4.\n\nStatus\n\nThe project\nto apply the scheduler\nto the KSC shuttle\nprocessing\nproblem\nhas been underway\nfor about a year.\nSince February,\nwe have been working with actual data\nfrom a completed\nshuttle flight. While this data did not\nprovide us with the data to utilize our state variable\nrepresentation,\nit did provide us the ability to test our\nalgorithms\non realistic amounts\nof data.\nOur plan is to shadow the STS-37 flight later this summer. The initial purpose\nof this first test is to collect the\nnecessary scheduling\ninformation\nto put into the system.\nCurrently,\nno information\nexists in computer\nform stating various configuration\nrequirements\nof the orbiter for\nthe various activities.\nAdditionally,\nthe resource\ninformation that is presently\nstored must be compared\nwith\nthe floor supervisors\nfor accuracy\nas well as adding new\nresources that are not presently\nbeing stored.\nDuring the\ntesting period,\nwe will add in the changes\nto the work\nas they occur providing\nnew schedules\nin a timely manner. As the quality\nof the information\nbeing stored in\nthe knowledge\nbase increases,\nour system will produce\nbetter schedules.\nThe schedules\nwe produce\nwill then be\ncompared\nto existing\nwork schedule\nproviding\nus some\ninsight into new information\nto add to our system.\nOur\nhope is that even at this early phase of testing, we will be\nable to provide\nthe KSC personnel\nsome insight into alternative\nschedules that might not have been considered\nin the past.\n\n5\n\nConclusion\n\nIn this paper,\nwe described\na researdl\nscheduling\ntool\nthat is being applied\nto scheduling\nground\nprocessing\nactivities\nfor the space shuttle.\nResearch\nin this area has\nbeen on-going for several years and is at a state where an\napplication\nof this magnitude\ncan be attempted.\nWe provided a brief overview\nof the scheduling\nsystem providing examples\nof the use of the various pieces to the KSC\napplication.\nExperimentation\nwith the repair strategies\nwill continue as we use the rescheduling\ncomponent\nof the\nsystem with the real data. It is generally felt, that there\nis a tremendous\npotential\nfor savings to the shuttle program if this effort and the other phases of the scheduling\nprocess (not described\nhere) at KSC are automated.\n\nIf unsuccessful:\n1.\n\nDevelopment\n\ntask\n\n= the task associated\nwith\nthis\nconstraint;\nnew-start\n= the first\ntime of a state\ntransitions\nt,\n(away from ?tl\nin the direction\nof d)\nwhere ?a is set to ?v;\nnew-end\n= new-start\n+ duration(task);\nTemporalShift(task,\nnew-start,\nnew-end);\n\nReferences\n\nThis repairisanalogous to the modal truth criterion [Cha87]\nofnon-linear\nplanning[Cha87] but without the flexibility\nof adding actions. The preferredrepair is to move a\n[Day87]\ntask that setsthe state-variable\nappropriately, a time\nto\ninterval\nbefore the task that has the requirement (i.e.,\n294\n\nD. Chapman.\nPlanning\nfor conjunctive\nArtificial\nIntelligence,\n32(4), 1987.\nErnest\nDavis.\nConstraint\nwith interval\nlabels.\nArtificial\n32(4):281-331,\n1987.\n\ngoals.\n\npropagation\nIntelligence,\n\n[Fox83]\n\nMark S. Fox. Constraint-Directed\nSearch:\nA\nCase Study of Job Shop Scheduling.\nPhD thesis, Carnegie-Mellon\nUniversity,\n1983.\n\n[Gar87]\n\nR.A. Gargan\nJr. Mission planning\nand simulation\nvia intelligent\nagents.\nIn Proceedings\nof Space Station\nAutomation\nIII, November\n1987.\n\n[HJK*85]\n\nG. B. Hankins,\nJ. W. Jordan,\nJ. L. Katz,\nA. M. Mulviehill,\nJ. N. Dumoulin,\nand J.\nRagusa.\nEmpress:\nexpert\nmission\nplanning\nand replanning\nscheduling\nsystem. In Proceedings of Expert Systems\nin Government\nSymposium, 1985.\n\n[KGV83]\n\nS. Kirkpatrick,\nC. D. Gelatt,\nand\nchi.\nOptimization\nby simulated\nScience, 220, 1983.\n\n[OST88]\n\nP. Ow, S. Smith,\nand A. Thiriez.\nReactive\nplan revision.\nIn Proceedings\nof AAAI-88,\n1988.\n\n[SFO86]\n\nSteven\nF. Smith,\nMark S. Fox, and Peng Si\nOw.\nConstruction\nand\nmaintaining\ndetailed\nproduction\nplans:\ninvestigations\ninto\nthe development\nof knowledge-based\nfactory\nscheduling\nsystems.\nAI Magazine,\n7(4), Fall\n1986.\n\n[Zwe90]\n\nMonte\nZweben.\nA framework\nfor iterative\nimprovement\nsearch algorithms\nfor constraint\nsatisfaction\nproblems.\nIn AAAI-90\nWorkshop\non Constraint-Directed\nReasoning,\n1990.\n\nM. P. Vecannealing.\n\n295\n\n'