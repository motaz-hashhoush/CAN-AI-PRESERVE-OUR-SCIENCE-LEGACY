b'Source of Acquisition\nNASA Ames Research Center\n\nSoftware Certification and Software Certificate\nManagement Systems\n(Position Paper)\n\nEwen Denney and Bernd Fischer\nUSRA/RIACS, NASA Ames Research Center, Moffett Field, CA 94035, USA\n{edenney,fisch}@email.arc.nasa.gov\n\n1 Introduction\nSoftware certification demonstrates the reliability and safety of software systems in\nsuch a way that it can be checked by an independent authority with minimal trust in\nthe techniques and tools used in the certification process itself. It builds on existing\nsoftware assurance, validation, and verification techniques but introduces the notion of\nexplicit sojbvare certijicates, which contain all the information necessary for an independent assessment of the demonstrated properties. A software certijicate management\nsystem (SCMS) provides a range of certification services. It maintains the links between\n, different system artifacts (e.g., design documents, engineering data sets, or programs)\nand different varieties of certificates, checks the validity of certificates, provides access\nto explicit audit trails, enables browsing of certification histories, and enforces systemwide certification and release policies.\nWe believe that a customizable SCMS with support for automated re-certification\nof diverse artifacts should become an essential part of any effective development process. Its primary impact is to increase the reliability and safety of software systems by\nproviding automation support for their audit. A SCMS can at any time provide current information about the certification status of each component in the system, check\nwhether certificates have been audited, compute which certificates remain valid after a\nsystem modification, and automatically start an incremental re-certification.\nWe are particularly interested in the combination of software certification with automated code generation and formal verification methods. Here, our focus is on the\nrelated questions of how code generators can support the certification process, and how\nsoftware certification can be used to demonstrate and increase the reliability of the code\ngeneration process.\n\n2\n\nChallenges\n\nBuilding reliable software is a challenging task in itself, but there are several challenges\nspecifically related to certification, e.g.,\n\n- maintaining high reliability, especially when a combination of diverse development\ntechniques is used,\n\n- minimizing certification efforts, especially for product families and interconnected\nsystems of systems,\n\n- reducing certification and re-certification times,\n- linking between artifacts and certificates, and\n- providing useful information (e.g., estimates of certification efforts).\nWe claim that the solution to these challenges is an intelligent, automated, and highly\ncustomizable software certificate management system integrated into the development\nprocess.\n\n3 Software Certification\nSoftware certification comprises a wide range of formal, semi-formal, and informal\nassurance techniques, including formal verification of compliance with explicit safety\npolicies, system simulation, testing, code reviews and human \xe2\x80\x9csign offs\xe2\x80\x9d, and even references to supporting literature. Consequently, the certificates can have different types,\nand the certification process requires different mechanisms. A SCMS must be able to\nsupport such different certificate types and certification mechanisms. In order to guarantee separation of concerns and thus achieve scalability, certification approaches need\nto concentrate on individual risk factors one at a time. Consequently, a SCMS must be\nable to combine different certificates for the same artifact to construct an overarching\ncertificate and, ultimately, to provide a higher degree of confidence.\nCertificatesA certificate contains all information necessary for an independent assessment of the properties claimed for an artifact. Obviously, the exact nature of the certificates depends on the nature of the artifact, the property, and the claim. However, a\nSCMS needs a unified view of certificates. At its most abstract, a certificate thus has\nto represent the three entities involved in the certification process, (i) the artifact being\ncertified, (iz) the property being asserted, and (iii) the certification authority.\nCertifiable Artifacts Certifiable artifacts include not only the conventional software\nartifacts (e.g., product families, completed systems, individual components, or even\ncode fragments) but also supporting non-software artifacts: requirements documents,\nsystem designs, component specifications, test plans, individual test cases, scientific\nand engineering data sets, and others.\nIn particular, the supporting evidence for one certificate can be considered as the\nartifact of another certificate. For example, if the correctness of a component is to be\ncertified using traditional black-box testing, the test harness and the test scripts are\nsupporting evidence for the certificate; at the same time, the test harness can itself be\n+\ncertified, e.g., by a code review, and is thus the artifact of another certificate.\nCertificate Hierarchies As indicated in the example above, the certificates for an artifact are not an unstructured collection but exhibit some hierarchical structure. This\nstructure is determined by two independent dimensions, (i) the system structure, and\n(ii) the certificate types.\nThe internal structure of a system is reflected in the certificate hierarchy. If a system\nis decomposed into a number of subsystems, and each subsystem is built from a number\nof components, then a certificate for the system depends directly on the certificates of\n\nthe subsystems and indirectly on the certificates of all involved components. A SCMS\nmust be able to represent this structure, taking into account language-specific visibility\nrules like module and subsystem boundaries that can limit the propagation of changes.\nThe second dimension is given by the certificates themselves, or more precisely,\nby the certificate types. The validity of a certificate can also depend on certificates for\nthe supporting evidence (as described above), or even the authority, e.g., when a code\nreview can only be signed by a certified software engineer. This part of the certificate hierarchy reflects the internal structure and procedures of the organization developing the\nsoftware. A SCMS can then use the certificate hierarchy for auditing and incremental\nre-certification, similar to the way the Unix make-tool uses explicit dependencies and\nrules for incremental re-compilation. The SCMS can determine which certificates need\nto be inspected, recomputed, or revalidated after an artifact or a certificate has been (or\nwould be) modified.\n\nCertifiable Properties and Certification Authorities Traditional V&V has only addressed a restricted range of formal properties. Realistically, however, software development requires a wide range of notions of software reliability, safety, and validity,\neach with an appropriate certification authority. This must all be supported by a customizable SCMS. Examples include coding standards, test cases, statistical validity for\ndata sets, simulation on high-fidelity test beds, fault tree analysis (FTA), failure modes\nand effects analysis ( M E A ) , stress tests, interoperability, usability, compatibility, and\nfeasibility studies, as well as formally specified logical safety properties.\nRelease Policies In the context of certification, a release refers to the transition of an\nartifact into a new defined state: for example, launch, system integration test, alpha and\nbeta testing phases, spiral anchor-point milestones, or code inspection. A release policy\nformally describes under which conditions an artifact is deemed to be in an adequately\ncertified state and can thus be released safely to another state. Different release policies\ncan be formulated to describe the different types of releases, and the corresponding\ncertification requirements.\n\n4 Certification Services\nIntuitively, a SCMS combines the functionalities of a database (e.g., storing and retrieving certificates) and a make-tool (e.g., incremental re-certification). Specifically, it\nprovides a variety of different services.\n\nCertificate construction The main task of the SCMS is the construction of certificates. Given an artifact, a claimed property, and a certification authority, the SCMS will\nattempt to construct the certificate, invoking automatic mechanisms and notifying individuals of pending tasks, as appropriate. It should estimate the time and effort that the\ncertification will take.\nEditing and revoking Users can deem an individual certification authority to no longer\nbe valid (e.g., a bug is discovered in a test harness, or an employee\xe2\x80\x99s badge has expired).\nThe SCMS should revoke all certificates which depend on this.\nCertificate maintenance The SCMS will carry out intelligent re-certification when\na (customizably) appropriate change has taken place in the code or, more generally,\n\nsoftware artifacts to be certified. Existing (sub-) certificates should be reused where\npossible, especially where product families are concerned.\n\nAuditing Since the SCMS provides a complete certification history with full information about all procedures followed, comprehensive audits can be carried out, applying\nalternative tools and/or oversight to any elements. The audit itself can then be recorded\nin the certification database.\nSchema management Clearly, the SCMS must be generic. It must be customizable\nto existing procedures. It can be thought of as having a client-server architecture. The\nSCMS is the client and allows users to \xe2\x80\x9cplug and play\xe2\x80\x9d with arbitrary certificate servers.\n\n5 Current Technology and Advances Required\nIn terms of computing infrastructure, the notions of certificate and certification are USUally used in the context of security mechanisms for computer systems, in particular for\ncomputer networks and network-based services.\nA SCMS can build on an existing secure infrastructure, e.g., PKI, for distribution,\nauthentication, tamper-proof access control, persistence, and other desirable properties.\nHowever, there are a number of differences from existing technology where advances\nare required:\n\n- linking to (and deep into) software artifacts,\n\n- the wide diversity of forms of certification, both formal and informal, and\n- the need for customizability and extensibility.\nThe SCMS should be an integral part of a development tool suite and use the same\nunderlying datastructures, e.g., development graphs [ 13. It can be linked to other tools,\ne.g., code generators and software reliability estimators. In particular, software certification can be combined with automated design documentation, so that the SCMS can\nprovide an integrated exploration tool for code, certificates, and documentation, similar\nto safety cases [5]but more specific to the code level. Likewise, model-based software\ndevelopment tools should allow the definition of arbitrary domain-specific certificate\ntypes with respect to explicit domain models.\n\n6 Certification of Automatically Generated Code\nWe are currently investigating some of these ideas in the context of an ongoing project\non automated code generation. We have developed an approach to safety verification\n[3] in which the code generator is extended to enable Hoare-style safety proofs for each\nindividual generated program. The key idea is to generate logical annotations along with\nthe code, so that the proofs can be automated. These proofs ensure that the generated\ncode does not violate certain conditions during its execution. However, it has gradually\nbecome clear that since this process produces a large number of auxiliary artifacts, and\ninvolves many components of varying complexity and reliability, that additional tool\nsupport should enable users to browse the entire set of safety artifacts.\n\nIn [41, we describe a rudimentary certification browser, which provides linking\nbetween the generated program, its verification conditions, the generated axioms, the\nproofs, and the proof checks. This is a first step towards an interactive tool which would,\nfor example, allow designated users to sign off on otherwise unverified lines of code.\nThis would be a prototype SCMS for code generation. Similar ideas have been investigated by the Programatica project [6],\nthough not in connection with code generation.\nIn recent work we have developed an approach to infemng annotations for code\nproduced by third-party code generators. This suggests a means of certifying the code\nproduced by COTS code generators, and circumvents the difficulties that stem from\ntreating these tools as black boxes.\n\n7 Conclusions\nIncremental certification and re-certification of code as it is developed and modified is\na prerequisite for applying modem, evolutionary development processes, which are especially relevant for NASA. For example, the Columbia Accident Investigation Board\n(CAIB) report 121 concluded there is \xe2\x80\x9cthe need for improved and uniform statistical\nsampling, audit, and certification processes\xe2\x80\x9d. Also, re-certification time has been a limiting factor in making changes to Space Shuttle code close to launch time. This is likely\nto be an even bigger problem with the rapid turnaround required in developing NASA\xe2\x80\x99s\nreplacement for the Space Shuttle, the Crew Exploration Vehicle (CEV). Hence, intelligent development processes are needed which place certification at the center of\ndevelopment. If certification tools provide useful information, such as estimated time\nand effort, they are more likely to be adopted. The ultimate impact of such a tool will\nbe reduced effort and increased reliability.\n\nReferences\n[ 11 S. Autexier, D. Hutter, T. Mossakowski, and A. Schairer. The Development Graph Manager\n\n[2]\n[3]\n[4]\n\n[5]\n\n[6]\n\nMAYA (System Description). In Proc. 9th International Conference on Algebraic Methodology And Sofnyare Technology (AMAST\xe2\x80\x98O2).LNCS 2422, pp. 495-501, 2002.\nColumbia Accident Investigation Board Report, Volume 1. http : / /caib .nasa .gov/.\n2003.\nE. Denney and B. Fischer. Formal Safety Certification of Aerospace Software. In Proc.\nInfotech@Aerospace.AIAA,2005. Invited talk.\nE. Denney and B. Fischer. A Program Certification Assistant Based on Fully Automated\nTheorem Provers. In Proc. Internarional Workshop on User Inregaces for Theorem Provers,\n(UITP\xe2\x80\x99OS),2005.\nT. Kelly and R. Weaver. The Goal Structuring Notation - a Safety Argument Notation. In\nProc. DSN Workshop on Assurance Cares: Best Practices, Possible Obstacles, and Future\n0.qoortunities. 2004.\nProgramatica Project. www .cse .ogi.edu/PacSoft/projects/programatica.\n2004.\n\n'