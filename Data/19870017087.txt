b'ment of Electrical and\nuter Engineerin\nUniversity of Colorado\nBoulder, Colorado\n\nI.\n\nt\n\nForce User\xe2\x80\x99s Manual\nby\nHarry F. Jordan\nMuhammad S. Benten\nN o r b e r t S. Arenstorf\nand\nA r u n a V. Ramanan\n\nC o m p u t e r S y s t e m s Design G r o u p\nD e p a r t m e n t of Electrical and C o m p u t e r E n g i n e e r i n g\nU n i v e r s i t y of Colorado\nB o u l d e r , Colorado 80309-0425\nRevised\nJ u n e 1987\nThis work w3s s u p p o r t e d in p a r t by Encore Computer Corporation, by NASA Langley Research\nC e n t e r under NAG-1-640, a n d by t h e Office of Naval Research u n d e r NOOO14-8GK-0204.\n\nT A B L E OF CONTENTS\n\nI.\n11.\n\nIntroduction\n\n1\n\nD e s c r i p t i o n of t h e Force Macros:\n\n4\n\nA.\nB.\nC.\nD.\n\nh l a c r o s S ecifying P r o g r a m S t r u c t u r e\nV a r i a b l e eclarations\nParallel Execution\nSynchronization\n\n6\n\n5\n9\n12\n18\n\nI11\n\nR e s t r i c t i o n s o n t h e Force h l a c r o s\n\n22\n\nIv\n\nHow to Invoke t h e Force\n\n23\n\nA . Flex/32 (Flexible C o m p u t e r Corp.)\nB. 3 l u l t i m a x ( E n c o r e C o m p u t e r C o r p . )\nC. B a l a n c e ( S e q u e n t C o m p u t e r C o r p . )\n\n23\n21\n25\n\nS a m p l e P r o g r a m Listing\n\n26\n\nReferences\n\n29\n\nv\n\nI. Introduction\nT h e principle of global parallelism in parallel programming was introduced by Jordan[l], through a set of F O R T R A V macros called t h e Force\nmacros. These macros support t h e construction of programs t o be executed\nin parallel by a Force of processes. T h e number of processes is left unspecified\na t compile time, b u t is potentially quite large. T h e Force provides a FORT R . W style parallel programming language utilizing an extensive set of\nparallel constructs. T h e programmer, insulated from process management, is\nleft free to concentrate on t h e synchronization issues of parallel programmicg.\nA Force module, Le., a main program or subroutine, consists of regular\nF 0 R T R . W 77 statements t h a t will be executed by all processes from t h e first\nline of the program listing, unless limited by a process synchronization cons t r u c t . Macros in t h e Force support parallel execution of DO loops using\npre-scheduled and self-scheduled algorithms. T h e Force includes constructs\nto allow for mutual exclusion, synchronization, and/or sequential execution\nwhen necessary, and constructs for d a t a based control of execution.\n-4 key feature of t h e Force is its management of variables in an I I I I I D\nenvironment. T h e Force maintains six classes of variables. Each class in t u r n\nsupports all t h e standard F O R T R A N variable types: INTEGER, RE.%,\nCOllPLES, etc. T h e parallelism class of a Force variable determines how it\nis accessed by different processes and may be Private, Shared, or Async. Each\nof these three classes will also inherit from F O R T R A N t h e storage class of\nC\'O\\llION among program modules or local t o one module, yielding six\nclasses. P r i z d e variables have separate instantiations for each component\nprocess of t h e Force. Shared variables have only a single instantiation a n d\nare accessible by all processes of t h e Force. ..lsync, or "asynchronous," variables have a "full/empty" s t a t e associated with them, and are shared between\nprocesses as well. Interprocess communication is achieved through use of\nShared or .4sync variables. T h e F O R T R A N COLILION mechanism is used t o\nimplement Force COIIMON. T h e Force variable declarations are meant t o\nsupersede FORTRAN variable declarations. However, ordinary F O R T R A N\ndeclarations will normally be treated as Private, so t h a t sequential FORT R . U modules may be called from Force modules.\nT h i s manual will describe t h e Force constructs in detail. Force cons t r u c t s are divided into four categories: program structure, dedaration of\nvariables, parallel execution, and synchronization. T h e programmer using\nt h e Force writes a program t h a t is t o be executed simultaneously by an arbitrary number of processes. This number is a run-time parameter. T h e program may consist of many Force modules. A Force module is analogous to a\nF o r t r a n main program or subroutine, except t h a t a Force module is called\nand executed by all of the processes. T h e Force constructs are summarized in\nT.4BLE-I. Triangular brackets, < >, are used t o indicate required parameters; square brackets, [ are used t o indicate optional parameters. An example of a complete Force program is shown later in this manual.\n\nI,\n\nTABLE-I Force Program Constructs\nProgram Structure:\nForce < n a m e > of < # of procs> ident <proc i d >\n< declaration of variables >\n[ Externf < Force module name > ]\nE n d declarations\n<Force program>\nInin\n\nEND\n\n.....\nForcecall < n a m e > ([parameters])\n\nForcesub <name>([parameters)) of < # of procs> ident <proc i d >\n< declarations >\n[ Esternf < Force module name > 1\nEnd declarations\n< subroutine body >\n\nRETURN\n\nESD\nDeclaration of Variables:\nPrivate < F O R T R A N type> <variable list>\nPrivate Common / < l a b e l > / <FORTRAN t y p e > <variable list>\nShared <FORTR.4N type> <variable list>\nShared Common / < l a b e l > / <FORTRAN t y p e > <variable list>\nAsync < F O R T R A N type> <variable list >\nAsync Common / < l a b e l > / <FORTRAN t y p e > <variable list>\n\n2\n\nTABLE-I Force Program Constructs (continued)\nParallel Execution:\nPcase on <variable>\n<code block>\n[I\'sect]\n[Csect ( <condition >)]\nEnd pcase\nScase\n[C s e< t ( <c o ndi t.io n > )]\n\n<code block>\n[I\'sect]\nEnd scase\n\n<n>\n\nPresched Do < n > <var>\n<loop body >\nEnd Presched Do\n\n<n>\n\nSelfsched Do < n > <var> = < i l > , < i 2 > [ , < i 3 > ]\n<loop body >\nEnd Selfsched Do\n\n<n>\n\nPre2do < n > < v a r l > = < i l > , < i 2 > [,<i3>]; <var2> = < j l > , < j 2 > [ , < j 3 > ]\n<doubly indexed loop body>\nEnd Presched Do\n\n<n>\n\nSelfPdo < n > < v a r l > = < i l > , < i 2 >\n<doubly indexed loop body>\nEnd Selfsched Do\n\nSynchronization:\nBarrier\n< code block\nEnd barrier\n\n=\nI\n\n<il>,<iP>[,<i3>]\n\n[,<i3>]; <var2> = <j l > ,<j2 > [, <j 3 > ]\n\n>\n\nCritical <lock-var>\n< code block >\nEnd critical\nVoid <async variable>\nProduce < async variable> = <expression>\nConsume < async variable> into <variable>\nCopy < async variable > into <variable >\n... Isfull( <async variable> ) ...\n\n3\n\n11. Description of the Force Macros\n\nI\n\nT h e macros are divided into four groups: program structure, variable\ndeclaration, parallel execution, and synchronization. T h e user of t h e Force\nmacros writes a single parallel main program. zero or more parallel Force subroutines, a n d zero or more single stream subroutines t o be executed by a single process. "hen writing t h e parallel main program and parallel subroutines, t h e macros given in t h e previous Table and described below may be\nused. T h e single stream subroutines and all of t h e code except t h e macros in\nt h e parallel routines a r e in F O R T R A N 77 and familiarity with t h a t language\nis assjilmed.\nT h e number of processes executing a Force program is a parameter t h a t\nt h e user will supply a t run time. M\'hat actually happens is t h a t execution of\na Force program begins with a "driver" routine. T h e driver will determine\nt h e n u m b e r of processes, create these processes, and then transfer control t o\nt h e user main program. This procedure is invisible t o t h e user and programmer.\nT w o ic: t \' ! b r?re used when referring to t h e parallel execution macros.\nTh es e t e r m s are p re- s c h e d u 1in g \'\' an d "s e 1f-s c h e d u 1in g . P re- s c h e d u I in g ref e r s\nt o a division of labor (usually based on t h e local process index) t h a t is fixed a t\ncompile time a n d independent of t h e actual work being done. Self-scheduling\nrefers t o a dynamic, run time allocation of work t o processes. Self-scheduling\nis more sophisticated, and regulates t h e work load better; b u t it requires\ngres t er over head.\n\\Ye have adopted t h e following convention: t h e first Force keyword t o\nappear on a line must have t h e first letter capitalized with the remaining\nletters in lower case. Additional keywords on t h e s a m e line a r e case insensitive. For example, Battier would be recognized by t h e Force preprocessor,\nb u t barrier or BARRIER would not. A pattern matching preprocessor is\nused, a n d this convention makes confusion between Force keywords and\nF O R T R A N variable names less likely.\nSyntactically, t h e Force macros adhere t o F O R T R A N standards. A few\ndifferences between t h e Force macros and standard F O R T R A N syntax exist;\nthese will b e given later in t h e restrictions section.\n"\n\n"\n\n4\n\nI1 A. Macros Specifying Program Structure\nForce\nT h e Force macro declares t h e s t a r t of a parallei main program and has\nt h e following syntax:\nForce < n a m e > of < n p r o c > ident < m e >\nT h e Force statement sets up t h e parallel environment. All processes\nbegin esecution from this point on, until they are terminated by t h e J o i n\nstatement. < n p r o c > and < m e > are both user named integer variabies. with < n p r o c > containing t h e number of processes in t h e Force,\na n d < m e > containing a unique identifier for each process (between 1\nand < n p r o c > ) . < n p r o c > and < m e > will be declared automatically.\nValues are assigned automatically t o < n p r o c > and < m e > , b u t these\nvalues must not be changed by t h e user program.\nT h e Force main program ends with a Join s t a t e m e n t usually followed by\nt h e FORTRAN E,!?D statement. T h e Join statement terminates all b u t\none of t h e Force of processes. This last process will return control t o t h e\nForce driver program. An example:\nForce METORCE of C O U N T ident hIE-INDEX\n<declarations>\nE n d declarations\n\nC\n\nForce body with\n\nC\nC\nC\n\nCOUNT\n\nC\nC\nC\nC\n\nMYINDEX- is a user named private integer\n\n-\n\nis a user named shared integer\nvariable containing t h e number\nof processes executing the program.\nvariable t h a t contains a unique\nindex for each process, numbered\nbetween 1 and count.\n\nJoin\nEND\n\nE n d declarations\nT h i s macro call terminates t h e declarations section of a Force module\na n d begins its executable code. It marks t h e place t o insert declarations\ngenerated automatically by t h e macros and may generate some executable code. E n d declarations must follow t h e last declaration s t a t e m e n t\na n d precede t h e first executable s t a t e m e n t of a Force module.\nSome examples using the E n d declarations macro are given on the pages\ndescribing t h e Force and Forcesub macros. Please note, every Force or\n\n5\n\nForcesub statement must have exactly one End declarafions s t a t e m e n t\nfollowing it at some point in t h e program listing for t h a t moduie.\n\nJoin\nJoin terminates execution of t h e parallel main program. It is an executable s t a t e m e n t , b u t is listed with t h e macros determining program struct u r e because it is, in some sense, the inverse of t h e Force s t a t e m e n t .\nInstead of creating a Force of processes, Join will terminate all processes\nexcept t h e last one t o reach it. This last process returns to t h e Force\ndriver program, where it too will be terminated. S o t e , t h e nonexecutable F O R T R A N E\xe2\x80\x9dVD statemen is still necessary.\n\nI\nI\n\n,\n\nForcesu 6\nT h e Forcesub s t a t e m e n t declares t h e s t a r t of a parallel subroutine and\nhas t h e general form:\nForcesub < n a m e > ( < p a r a m e t e r list>) of < n p r o c > idenf < m e >\nThis s t a t e m e n t is roughly analogous to t h e F o r c e statement. Each process will maintain its local copy of its process index, < m e > , from t h e\ncalling module; however, this index may be renamed in t h e Forcesub\nheader. Declarations including Private, Private Common, Shared, Shared\nCommon, Async. or Async Common statements may come between a Forcesub s t a t e m e n t and t h e following End declarations. There is no special\nForce keyword to terminate a parallel subroutine. T h e F o r t r a n\nRETURN s t a t e m e n t is used to return control to t h e calling module.\nT h e arguments passed t o a Forcesub via t h e parameter list should be\ndeclared using only normal FORTRAN declarations. Such arguments\nretain t h e parallelism class, Private or Shared, with which they were\ndefined in t h e calling module. Current implementations do not s u p p o r t\nAsynchronous variables passed as parameters. T h e following is an example of a Forcesub:\n\n.\n\n6\n\nC ------- hIATRIX MCLTIPLICATION SCRROUTINE: C = A * B\n\n---\n\nForcesub MVLT(A,B,C,Nl,N2,~\xe2\x82\xac1)NPROCS ident ME\nof\nINTEGER X l , N 2 , M l\nREAL A(Nl,N2),B(N2,M1), C(N1,Ml)\nPrivate INTEGER I, J,K\nEnd declarations\n\nC\n\nInitialize C ...\n\n100\n\nPre2do 100 I= 1,Nl ; J = 1 , M l\nC(1,J) = 0.0\nE n d presched do\n\nC\n\nT h e multiplication process\n\n200\n300\n\n...\n\nPresched DO 300 I = 1 , N l\nDO 200 J=l,XIl\nDO 200 K = l , N 2\nC(I,.J) = C(1,J) A(I,K)*B(K,J)\nEnd presched DO\nRETURN\n\n+\n\nEND\nThis parallel subroutine can b e called with call s t a t e m e n t as follows:\nShsred REAL A( lOO,SO), B(50,loo), C(100,100)\nPrivate N1, N2, M1\nE n d declarations\nForce c all M ULT(A,B ,C,N 1,N 2,M 1 )\n\nExternf\nT h e syntax of this macro is as follows:\nEzternf <Force module name list>\nEztern! is used t o inform t h e Force compiler/preprocessor about esternal\nForcesub modules t h a t a r e called using Forcecall. "External modules"\nrefer only t o Force modules t h a t are not included in t h e s a m e file as t h e\nForce main program. Modules defined below t h e main Force program\n(within t h e same file) are not required t o be declared Extern!. This\nfeature preserves the "separate compilation" feature of the FORTRAN\nlanguage. When a list of external module names is specified using\nErternl, names in the list should be separated by commas. Some examples:\n\n7\n\nExtern f INTMAT\nExternf INTMAT, OCTMAT\nT h e Externf s t a t e m e n t is placed in the declarations section of a Force\nprogram. E z t e r n f may appear in any Force module t h a t has itself been\ndeclared E d e r n f . Consider t h e following example. Force modules A. B,\nand C each appear in separate files which are perhaps to be compiled\nseparatelp. If t h e F o r c e main program, A, calls F o r c e s v b B, which in\nt u r n calls F o r c e s v b C, then .4 must declare B using E z t e r n f , and B would\nClocl~rnC ns E d e r n f . T h e point is t h a t as long as C is declared E t t e r n f i n\nB, which is declared in A, then A need not declare C as Erternf. hiultiple\ndeclarations, while not required, are allowed.\n\nForcecall\nT h e Forcecall executable statement is used t o invoke parallel subroutines\nt h a t have been declared as named Forcesub modules.\nForcecall ( < p a r a m e t e r list>)\nT h e entire Force of processes will jump to and execute t h e parallel subroutine. However, Forcecall does not cause synchronization. Forcecall\ndiffers from t h e regular F O R T R A N C.4LL only in t h a t provisions are\nmade to automatically pass t h e local process identifier < m e > . Normal\nF o r t r a n scope rules apply to Force variables. Note, Async variables may\nnot be included in t h e parameter list, b u t may b e passed through an\nA s y n c Common block instead.\n\n8\n\nI1 B. Variable Declarations\nT h e implementation of t h e Force as a preprocessor, which does not cons t r u c t a symbol table, requires t h a t all type information be included in t h e\nPrirate or Shared declarations, so t h a t it. is available during the preprocessing\nof t h s t statement. I t should be noted t h a t F O R T R A N IMPLICIT typing of\nyari2bloG is allowed under t h e Force, and t h a t all implicitly typed variables\nwill be of Force variable class Private.\n\nPtirat e\nPrivate < t y p e > <variable list>\n\\\\-hen a variable is declared Private, then each process of the Force maintains its own storage space for t h a t variable, even though t h e variable is\nnamed only once in t h e main program listing.\nFor esample:\nPrivate DOUBLE PRECISION X (100,100)\nPrivate INTEGER I, J, K\nPrivate CHARACTER*80 STRING1\nSuch variables are normally used for arithmetic temporaries or index\nvalues which have distinct values for each process of t h e Force.\n\nPrivate Common\nA Private Common variable is Private in t h e sense defined above, b u t it\nmay be Common between Force modules. This declaration would appear,\nwith the variables specified in t h e same order, in each of t h e modules\nt h a t wished t o include t h e Common variables. T h e syntax is as follows:\nPrivate Common / < l a b e l > / < t y p e > <variable list>\nUnlike F O R T R A N 77, Force Common variables are typed within t h e\nsame statement t h a t declares them t o be Common. For example:\nPrivate Common\nPrivate Common\nPrivate Common\n\n/ MI-COPY / RE.4L TIhlE( 15)\n/ MYCOPY / INTEGER P O S , S P E E D\n/ GRID / COSlPLEX X,Y\n\nFrom t h e example, we can see t h a t variables of different type may be\ncombined within the same Common block, b u t this requires different\ndeclaration statements. As in FORTRAN 77, it is the programmers\nresponsibility, to insure that all Force modules that use a given\nCOMMON block, specify the variables of that COMMON block\nin the proper order. Also note t h a t arrays are dimensioned on this\nline. F.ORTRAN "blank COMMON" is not allowed.\n\nShared\n\\Vhen a variable is declared Shared, then only one copy of t h a t variable\nis maintained by all of t h e processes in t h e Force. In this manner, multiple processes may operate on and communicate through shared memory\nlocations. Care must be taken when multiple processes try t o modify a\nShared variable all a t once. Normally, one would modify a Shared variable only within a critical section of the program. Regular F O R T R A N\ndeclarations follow t h e Shared keyword. T h e syntax is as follows:\nShared < t y p e > <variable list>\nFcr example,\nShared INTEGER I, J\nShared REAL A(800), B(800)\nThis example declares I and J to be shared integers and declares A and B\nto be real vectors of t h e specified dimension.\n\nShared Common\nThis s t a t e m e n t has t h e following syntax:\nShared Common / < l a b e l > / < t y p e > <variable list>\nA Shared Common variable is Shared between processes as defined above.\nIn addition, Shared Common variables may be common between Force\nmodules. T h a t is t o say, different processes in different Force modules\n(subroutines) all have access t o t h e same variable.\nAgain. as in Private Common, the type of a variable is declared on t h e\nsame line -vith t h e Common declaration. Variables of different t y p e may\nbe combined within t h e same Shared Common block, b u t this will require\nt h e use of several declaration statements. Once again, as in F O R T R A N\n77, it is t h e programmer\'s responsibility t o preserve t h e ordering of variables in a Common block. An example:\nShared Common /PENPOS/ DOVBLE PRECISION S,Y\nShared Common /PENCOL/ INTEGER COLOR(8)\n-4sync\nThis statement has t h e general form:\nAsync < t y p e > <variable list>\nAsynchronous variables are shared between processes; t h a t is, they have\nonly one instantiation for all processes. T h e distinguishing feature of an\nA s y n c variable is its "full/empty" state. T h e use of these variables is\ngoverned by t h e Produce, Consume, Copy, L\'oid, and Isfull macros which\na r e described later. Briefly, an asynchronous variable may be Consumed\nor Copied only if it is "full," and Produced only if it is "empty." T h u s ,\nAsync variables may be used t o implement d a t a based synchronization.\n\n10\n\nFor example, t h e following Force program fragment illustrates t h e\nuse of this macro:\nAsync INTEGER I\nAsync REAL X, Y, Z\nEild Declarations\nBarrier\nVoid X\nE n d barrier\nProduce X = localstuff\n\n-4sync Common\n\nThis statement has t h e general form:\nAsync Common / < l a b e l > / < t y p e > <variable list>\n-4.sync Common variables have all t h e properties of A s y n c variables\ndescribed above. In addition, they may be Common between Force\nmodules t h a t include this designation.\n\n11\n\nI1 C. Parallel Execution\nParallel execution is specified using macros related t o t h e DOALL and\nparallel case constructs. T h e two constructs are similar t o t h e extent t h a t\nboth involve segments of code t h a t can be executed in any order. DOALL\napplies t o independent instances of t h e loop body for different loop index\nv ~ l r i * s . T h e psrallel case construct applies t o different single stream code\nblocks which are mutually independent. T h e distribution of work may either\nbe p re-sc h ed uled or self-sc hedu led.\n\nPcase\nThis s t a t e m e n t establishes a pre-scheduled parallel case construct which\ns t a r t s with either of t h e following constructs:\n\nPcase\nI\n\nor\n\nI\n\nPcase on < v a r >\nT h e construct consists of a series of independent sections of code, each of\nwhich is to be esecuted by a single process. T h e sections a r e delimited by\na Pcase , zero or more L\'sect , zero o r more C s e c t a n d a n End pease statements.\nT h e construct assigns its own private integer variable unless t h e variable\n< v a r > is used explicitly in t h e second form of t h e construct. In such\ncases it t h e programmer\'s responsibility t o declare < v a r > as a Private\nI n t e g e r variable. In either case t h e execution of multiple cases is prescheduled using this variable which will be assigned t h e value i during\nt h e execution of t h e ith-case. T h e jth-case of a Pcase will be executed by\nt h e process with l o c a l i d equal t o ((j-1) mod np)+1, where n p is t h e\nnumber of processes.\nIf there a r e more processes in t h e Force than there are code sections then\nall code sections will be executed simultaneously. Otherwise some of t h e\nsections will be executed sequentially by t h e same process. For this reason care m u s t be taken while using asynchronous variables\n(producer/consumer) within a Pcase. A parallel case with only one code\nsection is similar to a barrier in t h a t the code is esecuted by a single process, b u t differs in t h a t no synchronization of other processes occurs.\nT h e r e are slight variations in the implementation of t h e parallel case\nconstruct. An example of the simplest implementation is given below.\nHere each task represents a group of regular (single stream) FORTRAN\n77 instruct ions.\nPcase\n<task A >\nUsect\n< t a s k B>\nUsect\n< t a s k C>\nE n d pcase\n\n12\n\nIf any of t h e single stream code sections are conditional, t h e C s e c t statement can b e used. T h e condition is built into t h e Csect construct. 4 n\nexample when all code sections are conditional is given below.\nPcase\nCsect ( < c o n d i t i o n > )\n< t a s k A>\nCsect ( < c o n d i t i o n > )\n<task B>\nCsect ( < c o n d i t i o n > )\n<task C >\nE n d pcase\nCsect and Usect can both appear in a parallel case construct. T h e sections on Csect a n d Usect outline t h e variation in implementation of\nparallel case construct.\n\nI -s e c t\nThis statement separates multiple single stream code sections of a pnralle1 case. \\\\.\'hen C\'sect is used t o s t a r t a conditional case section then C\'sect\nis not used t o separate it from t h e previous code section. -41~0,\nC-sect is\nnot used if there is only one code section.\n\nC\'sect\nThis statement begins a conditional single stream code section of a parallel case a n d has t h e following Form:\nCsect ( < condition > )\nwhere, <condition> is a FORTRPLN condition of the same form allowed\nin a FORTRAN IF statement.\n\nEnd pcase\nT h e pre-scheduled parallel case construct is terminated by this statement. Note t h a t some processes may proceed past t,his point while portions of t h e parallel case are still being executed.\n\nScase\nT h e Scase statement is an alternative to t h e Pcase s t a t e m e n t of a parallel case construct. \\:hen\na parallel case is initialized by t h e statement\nScase\nt h e allocation of the work is done at t h e execution time rather than being\npre-scheduled. A process receives t h e next available case section when it\nfinishes t h e previously assigned section. T h e other aspects of a self-\n\nscheduled parallel case construct are t h e same as t h e pre-scheduled\nparallel case construct. except t h a t it is terminated by a n E n d scase\ns t a t e m e n t instead of EnL pcuse.\nIn contrast t o t h e P c a s e construct, process synchronization is included t o\nensure that two instances of a self-scheduled construct, either a parallel\ncase o r a parallel DO loop, a r e not being executed simultaneously.\n\nI\n\nE n d scase\n\':\'he self-scheduled parallel case construct is terminated by this statement. Although processes may proceed past this point while portions of\nt h e self-scheduled parallel case are still being executed, no process may\nenter another self-scheduled construct (parallel case or loop) or re-enter\nthis o n e a second time before all processes have exited.\n\nPresched D O\nA pre-scheduled parallel loop is introduced by t h e Presched DO, which\nhas t h e following form:\nP r e s c h e d DO < n > < i > = < i l > , < i 2 > [ , < i 3 > ]\nThis s t a t e m e n t m u s t have a body s u c h t h a t instances of t h e body for\ndifferent values of t h e local variable < i > are independent and can t h u s\nbe executed in parallel. Pre-scheduling partitions different values of\n< i > evenly over processes in a manner fixed a t compile time. Prescheduled loops are useful when t h e execution time of t h e loop body is\nfairly constant. T h e step size <i3> is optional and is taken as one if\nmissing.\nT h e parameters < i l > , < i 3 > and <i3> must be constants or espressions yielding a n integer value. These values must be identical for all\nprocesses of t h e Force (i.e., if P r i v a t e variables are in t h e expressions),\na n d they must remain fixed during execution of t h e loop. T h e parallel\nDO constructs d o not nest with each other, however they may be nested\n(internally or externally) with normal FORTRAN DO loops.\nAn example:\n\n99\n\nPresched DO 99 J = 1,M1\nC(J) = 0.0\nE n d presched DO\n\nwould initialize t h e t h e first M1 elements of t h e vector c t o zeros. Note\nt h a t M1 and t h e vector c are assumed to have been declared Shared or\nShared Common. Also note t h a t no process synchronization occurs processes may enter and leave t h e loop asynchronously.\n\n14\n\n<n>\n\nE n d p r e s c h e d DO\nThis s t a t e m e n t terminates t h e body of a pre-scheduled DO loop. T h e\nstatsi,ient number < n > must match t h a t on t h e P r e s c h e d DO statement.\n\nSelf8 c h e d D 0\nT h e Selfsched DO s t a t e m e n t is an alternative for introducing a parallel\nloop and it has t h e following general form:\nS c l p c h e d DO < n > < i > = < i l > , < i 2 > ( , < i 3 > ]\nT h e behavior of the S e l j s c h e d DO loop is t h e same as t h a t of a P r e s c h e d\nDO escept t h a t the allocation of the work is done a t execution time. A\nprocess receives t h e n e s t unassigned value of < i > when it finishes its\nprevious iteration. This tends t o even the workload over processes when\nt h e execution time of t h e loop varies significantly for different values of\n< i > . T h e parameters < i l > , <i2> and <i3> must be constants or\nespressions yielding an integer value, and this value should remain fixed\nduring esecution of t h e loop. T h e implementation generates a S h a r e d\ntemporary variable t o handle t h e shared loop index. Synchronization is\nprovided t o ensure t h a t t h e execution of different instances of selfscheduled loops or cases is not overlapped. This means t h a t t h e overhead is higher for self-scheduled loops versus pre-scheduled loops.\nAs was t h e case with pre-scheduled loops, t h e parameters < i l > , < i 2 >\nand <i3> must be constants or expressions yielding an integer value.\nThese values must be identical for all processes of t h e Force, and remain\nfised while t h e loop is executing. T h e parallel DO constructs do not nest\nwith each other, however they may be nested (internally or externally)\nwith normal F O R T R A N DO loops.\nFor example:\n\n99\n\nSelfsched DO 99 J = 1 , M l\nC(J) = 0.0\nIF (J/7 .EQ. J/7.0) CALL HARD\\VORK(C( J ) )\nEnd selfsched DO\n\nwould initialize t h e t h e first h l l elements of t h e vector C t o zeros, and\ncall hardwork if J is a multiple of seven. Note t h a t b i l and t h e vector C\na r e assumed t o have been declared S h a r e d o r S h a r e d Common. Also note\nt h a t processes may enter t h e loop before all have arrived and may leave\nt h e loop before all have finished, b u t no process may enter another selfscheduled loop, or re-enter this one a seccjnd time, until all have esited.\nProcesses may also not enter a subsequent self-scheduled case construct\nuntil this self-scheduled construct is complete.\n\n< n > E n d seljsched DO\nThis s t a t e m e n t ends t h e body of t h e self-scheduled DO loop with statem e n t number < n > .\n\nPrcL\'do\n\nDoubly indexed DO loops are supported as separate constructs within\nt h e Force. Semantic considerations dictate t h a t these be implemented\nwith separate constructs rather t h a n to allow nesting of t h e parallel DO\n!xp3.\n\nPre&do < n > < i > = < i l > , < i 2 > [ , i 3 ] : < j > = < j l > , < j 2 > [ , < j 3 > ]\nLike single-index parallel DO loops, this s t a t e m e n t m u s t have a body\nwhere instances of t h e body for different values of t h e local indices < i >\na n d < j > a r e independent. Pre-scheduling partitions different pairs of\nvalues of < i > and < j > evenly over processes in a manner fixed a t compile time. S t e p sizes <i3> and < j 3 > are optional, and they are taken\nas one if missing. For example:\n\nPre2do 99 J = 1,LIM ; E;= 10,1,-1\n\nC(J,K) = A(J,K) + B(J,K)\n\n99\n\nE n d Presched DO\n\nNote t h a t LIhl and t h e vectors A, B, and C are assumed t o have been\ndeclared Shared or Shared Common., and I and K are P r i z w f e . .Again,\nnote t h a t no process synchronization occurs - processes may enter and\nleave t h e loop asynchronously.\n\n<n>\n\nE n d presched DO\n\nThis s t a t e m e n t ends t h e body of t h e doubly indexed pre-scheduled DO\nloop as well. < n > must match t h e < n > given in t h e PrecOdo statemen t .\n\nSelj2do\nT h e Selj.?do statement is a self-scheduled version of t h e doubly indexed\nDO loop. I t has t h e following form:\nSeljZdo < n > < i > = < i l > , < i 2 > [ , < i 3 > ] ;\n<j> = <jl>,<j?>[,<j3>]\nScheduling of t h e indices is done at execution time; processes receive t h e\n"next" pair of indices available when they are ready t o perform a n iteration of t h e doubly indexed loop. Self-scheduling regulates t h e workload\namong processes at a cost of higher synchronization overhead. When\nloop iterations require approximately the same amount of execution time,\nthen it is more efficient to use a pre-scheduled DO loop. Once again,\nthere m u s t b e no d a t a dependencies between loop bodies for different\n\n16\n\n< j > pairs; this is t h e programmers responsibility.\nT h e parameters < i l > through <i3> a n d < j l > through <j3> must\nbe integer constants or expressions, which remain fixed during a given\nexecution of t h e Self2do loop. Overlapping executions are prevented for\ndifferent instances of doubly indexed. as well as singly indexed, selfscheduled loops.\nAn example:\n\n<i > ,\n\n100\n\nSelfrZdo 100 I = 1 , M l ; J = l , M l\nIF ( I .XE. J) T H E N\nC(1.J) = 0.0\nELSE\nC(1,J) = DTAN(DOC\'BLE(J*PI/\\f 1))\nEND IF\nE n d selfsched D O\n\nProcesses may enter t h e loop before all have arrived and leave before all\nhave finished, b u t no process may enter a second instance of a selfscheduled loop before all have exited.\n\n< n > End selfsched D O\nThis statement terminates t h e body of a doubly indexed self-scheduled\nDO loop as well. T h e statement number < n > must match t h a t on t h e\nSelj2do statement.\n\nI1 D. Synchronization\nBarrier\nThis s t a t e m e n t m u s t be executed by all processes of t h e Force. When all\nhave reached t h e B a r r i e r statement, a single process will execute t h e\n"horly" nf t h e Barrier, t h e body is defined as t h e block of code between\nt h e B a r r i e r and t h e End barrier statements. After t h e body has been executed by a single process, all t h e processes of t h e Force will resume execution after t h e End barrier statement, and they will have been synchrcnized. Note, it is not necessary for t h e Barrrer t o have a body a t all,\nb u t End barrier is always required.\nExample:\nBarrier\n\nX=X+l\nE n d barrier\nBarrier synchronization will cause all the processes t o wait at t h e first\nB a r r i e r s t a t e m e n t until t h e last one arrives. A single process will then\nexecute t h e body of t h e Barrier construct, in this case incrementing S by\none. After t h e body has been executed, then all processes continue a t\nonce with s t a t e m e n t s following t h e End barrier statement.\nIt is t h e programmers responsibility to place Barriers where they make\nsense. To place a B a r r i e r inside a Pcase causes a deadlock, since not all\nprocesses will reach t h e Burrier, and those t h a t did would hang. Likewise, B a r r i e m within Self or Pre-scheduled DO loops should be avoided.\nThey would also deadlock, unless t h e number of processes divides evenly\ni n t o t h e number of loop iterations.\n\nEnd barrier\nPaired with t h e previous s t a t e m e n t , this one delimits a secbion of code\nexecuted by a single instruction stream. Synchronized parallel execution\nbegins after this statement.\n\nCritical\nM u t u a l exclusion can be accomplished by named critical sections using\nt h e Critical construct, which has the following form:\nC r i t i c a l <lock-var >\nT h e critical section is ended by t h e End critical statement. Use of a C r i t i cal section guarantees t h a t only one process will be executing any block\nof code nested between t h e Critical and End Critical s t a t e m e n t s of critical sections with t h e same <lock-var>.\n\n18\n\nT h e user must declare <lock-var> as a Shared variable, preferably of\ntype LOGICAL. This variable is used as a lock and should contain no\nother value. T w o or more critical sections may share t h e same <lockv a r > . T w o critical sections on t h e same <lock-var> cannot execute\nsimultaneously. If one wishes to coordinate activities between Force\nmodules, then t h e <lock-var> may be a Shared Common variable,\ndeclared in those Force modules t h a t wish t o use it. For example:\nShared Common /IO/ LOGICAL \\C\'RITER\nEnd Declarations\n\n10\n\nCritical \\VRITER\nWRITE(6,lO) ME\nFOR;IIAT( lX,"Me\nEnd critical\n\n= ",I3)\n\nE n d critical\nThis statement is paired with t h e nearest unmatched preceding. Critical\nstatement t o delimit a cribical section. Nested critical sections a r e\nallowed; however there is no automatic deadlock prevention employed if\ncritical sections are improperly nested.\n\nProduce\nProduce <async v a r > = < e x p r >\nIf t h e asynchronous variable <async v a r > is "empty," P r o d u c e will\nassign t h e value of t h e expression < e x p r > t o <async v a r > and mark\n<async var> as "full." If <async v a r > is not "empty," t h e process\ncurrently executing P r o d u c e will wait until <async v a r > becomes\n"empty" and then make t h e assignment and mark <async v a r > as\n"full." These actions occur atomically. T h e variable <async v a r > must\nhave been declared as an asynchronous variable using t h e .4sync statement.\n\n19\n\nExample:\nPrivate RE.4L YY\nAsync REALXX\nEnd Declarations\nBarrier\nVoid L\nT\nEnd Barrier\n\nYY = 7.0*COS(A+B)\nX\nProduce , X = YY + 3\n\nConsume\nConsume <async v a r > i n t o < v a r 2 >\n\nIf t h e asynchronous variable is "full," then this macro routine will assign\nt h e value of <async v a r > to <var2> and mark <async v a r > as\n"empty." If it is not "full," Consume will wait until <async v a r >\nbecomes "full," store its value, and mark it as "empty." If multiple\nprocesses are executing a C o n s u m e statement on t h e same <async v a r > ,\nand if t h e <async v a r > is "full," then only one consumer process will\nsucceed. T h e others will have t o wait until <async var> is set "full"\nagain (by a P r o d u c e ) before they will have a chance to succeed. T h e variable <async v a r > must have been declared as an asynchronous variable.\nIn most applications, < v a r 2 > will b e Private. For example:\nConsume XX into kY\n\nCOPY\nCopy <async v a r > i n t o < v a r 2 >\nThis macro routine will store t h e value of t h e asynchronous variable\n<async v a r > into < v a r 2 > if <async var> is "full," without changing\nt h e variable\'s s t a t u s . If t h e variable is "empty," then Copy will wait\nuntil <async v a r > becomes "full," and then return its value, and leave\nit "full:" T h e variable <async v a r > must have been declared as an asynchronous variable. For example:\n7\nY\nCopy k (into E\n\n20\n\nVoid\nVoid < async v a r >\nThis macro routine will unconditionally mark t h e asynchronous variable\n<async v a r > as "empty." T h e variable <async v a r > must have been\ndeclared as an asynchronous variable by t h e Async s t a t e m e n t . Note,\nasynchronous variables are not necessarily "empty" when declared; normally one would first Void an asynchronous variable before using it in a\nproducer/consumer macro. For example:\n1-oid Am\n\nISJU\n\n11\n\n1;ZfulI ( < async var > )\nThis macro "function" will return t h e logical s t a t e of t h e asynchronous\nvariable < v a r > , with T R U E corresponding to "full" and FALSE indicating t h a t t h e asynchronous variable is "empty." It may be used anywh,ere t h a t a F O R T R A N logical function would b e used. T h e variable\n<async var> must have been declared as an asynchronous variable by\nt h e .4sync s t a t e m e n t . For example:\n\nAsync R E i I L X X\nPrivate RE.4L MYCOPY\nE n d declarations\nIF( Isfull(=) ) T H E N\nConsume 4Lyinto MYCOPY\nELSE\n< d o something else>\nEND IF\n\n21\n\n111. Restrictions on the Force Macros\nT h e Force macro implementations o n the Flex/32, t h e Encore Multimax\nand t h e Sequent Balance adhere t o almost all of t h e FORTRAN s t a n d a r d s\nand elements of style except for t h e following points:\n1. Barrier, Forcecall, and Join, and all of t h e macros t h a t specify parallel\nexecution must be executed by all the processes executing t h e parallel\nprogram. Skipping over these constructs by a fraction of the processes\nmay cause an indefinite hang u p and unexpected results may be\nobtained.\n2. Branching into or out of a body of a Force construct is not allowed and\nmay not be detected by either t h e Force preprocessor or t h e FORTRAN\ncompiler and will lead t o unexpected results.\n3. Except for t h e statements closing parallel DO loops, Force statements\nshould not be numbered, and numbered Force s t a t e m e n t s will not be\nrecognized by t h e preprocessor and will produce F O R T R A W syntax\nerrors. Also, Force statements may not be continued on two or more\nlines.\n4. T h e Force preprocessor may generate subroutine names using a variation\non t h e name of a given Force module. For this reason, t h e first five characters of t h e name of a Force module m u s t uniquely identify t h a t\nmodule.\n5. Asynchronous variables cannot b e passed as parameters t o other modules\nor subroutines and be expected t o behave asynchronously. Async cornmon must be used for this purpose.\n6. F O R T R A X BLOCK D A T A is currently not supported a n d t h u s Shared\nand Shared Common variables cannot be initialized statically a t compile\ntime.\n1.\nT h e F O R T R A N DATA statement can only be used t o initialize P r i v a t e\nv 3 ria b les.\n8. Finally, it should be noted t h a t t h e line numbers which are referenced by\nt h e error messages resulting from using the "force" command refer to t h e\n.f files and not to t h e .frc files.\n\n-\n\n22\n\nIV. How to Invoke the Force\nThis section will discuss t h e UNIX shell scripts, force, forcerun, a n d\npreforce, used t o invoke t h e Force. Implementations on three machines will\nbe considered: t h e Flex/32 (Flexible Computer Corp.), t h e Multimax (Encore\nComputer Corp.) and t h e Balance (Sequent Computer Corp.).\nforcc is t h e shell command t h a t is used t o preprocess, compile and link\nForce source programs. T h e force command takes an argument list of files\nand flags a n d produces a parallel executable o u t p u t program. W e will a d o p t\nt h e convention t h a t Force source files have a filename ending with a .frc\nextension. Files in t h e argument list with a .frc extension will first be\npreprocessed t o expand the Force macros. T h e resulting files along with t h e\nForce driver program and any other files specified will then be compiled a n d\nlinked.\nT h e forcerun command is used t o execute a Force program. forcerun\nalso specifies t h e number of component processes t o be used by t h e Force proy a m during t h a t run. forcerun takes two arguments: t h e first is t h e name\nof t h e Force esecutable file, and t h e second is an integer number representing\nt h e number of processes (processors on Flex/32) t o be used for t h a t run.\nT h e preforce command performs only t h e preprocessing steps, producing FORTRAN .f files from Force .frc files specified in t h e argument list.\nT h e preforce shell script is intended as a debugging convenience, as t h e f77\ncompiler used by the force command will give line numbers referring t o t h e .f\nfile when referencing errors.\nT h e force, forcerun, and preforce commands are executable from any\ndirectory, a n d we recommend t h a t frequent users of t h e Force include aliases\nfor these shell scripts in their .cshrc files or links t o them in their own bins.\nAll three commands, when invoked with no arguments, will print a help message illustrating their use. T h e sections below will describe features and\noptions of t h e commands t h a t are specific to t h e Flex/32, t h e hlultimax or\nt h e Balance.\n\nIV A. Flex/32 (Flexible Computer Corp.)\nT h e shell scripts, force, forcerun, and preforce, may be found in t h e\n/usr/local/force directory on NASA/Langley\'s Flex/32.\nOn the Flex/32, t.he force command uses Flexible\'s cf77 compiling command, and t h e Force preprocessor will generate .cf files from .frc files in t h e\nargument list. force will accept all options associated with cf77. T h e\nGreenhills compiler is automatically selected by force, and cfg.18 is used as\na default if no other configuration file is specified. T h e syntax is as follows.\nforce ( c f i i options] <filename list>\nSome examples:\nforce matmul.frc init.frc subs.f\nforce -0 test.exe -h cfg.8 testl.frc test2.frc\n\n23\n\nT h e forcerun command is used to execute a Force program. It has t h e\nfollowing syntax:\nforcerun <execut,able file> <number of processors>\n\nFor esample:\nforcerun tcst.exe 18\nr3n ;he Flex/32, preforce invokes both t h e Flexible and Force preprocessors. preforce accepts files ending with an .frc or .cf extension and creates\nt h e .f F O R T R A S equivalents. T h e r e are two options. T h e -cf option invokes\nonly t h e Force preprocessor, creating .cf files from .frc source files. T h e -a\noption creates "all files": .cf, .f, .su.f, .sh.f, and .CF.I. When used without\noptions, preforce will create only .f files. T h e syntax is as follows:\npreforce <filename> [filename, ...I\nAn example:\npreforce thisfile.frc\n\nIV B. Multimax (Encore Computer Corp.)\nT h e shell scripts, force, forcerun, and preforce, may be found in t h e\n/usr/local/unsupp/force directory o n the University of Colorado at\nBoulder\'s hiultimax (max). For t h e Multimax, force preprocesses .frc files in\nt h e argument list producing .f files, and then uses the standard f77 compiler.\nforce will accept all options associated with f77. T h e syntax is as follows.\nforce [f77 options] <filename list>\n-4n example:\nforce\n\n-0\n\nmatmul.exe matmul.frc x.f\n\nT h e forcerun command is used to execute a Force program. It has t h e\nfollowing syntax:\nforcerun <executable file> < n u m b e r of processes>\nFor example:\nforcerun matmul.exe 8\nT h e preforce command performs only t h e preprocessing steps, producing FORTRAN .f files from Force .frc input files. T h e syntax is as follows:\npreforce <filename> Ifilename, ...I\nAn example:\n\np re force m a t mu].frc\n\n24\n\nIV C. Balance (Sequent Computer Corp.)\nT h e shell scripts. force, forcerun a n d preforce, may be found in t h e\nlusrllocallunsupplforce directory on t h e University of Colorado a t\nBoulder\xe2\x80\x99s Sequent ( t r a m p ) . For t h e Sequent, force preprocesses .frc files in\nt h e argument list producing .f files, and then uses t h e s t a n d a r d F O R T R A N\n(Silicon Valley) compiler. force will accept all options associated with t h e\n(SS32000 series Silicon Valley) F O R T R A N compiler. T h e syntax is as foll0.cr.s.\nforce [fortran options] <filename list>\n\nAn example:\nforce -0 matmul.exe matmul.frc x.f\nT h e forcerun command is used t o execute a Force program. I t has t h e\nfollowing syntax:\nforcerun <executable file> < n u m b e r of processes>\nFor example:\nforcerun mstmul.exe 8\nT h e preforce command performs only t h e preprocessing steps, producing FORTRAN .f files from Force .frc input files. T h e syntax is as follows:\npreforce <filename> [filename. .I\n.An example:\npreforce matmul.frc\n\n25\n\nV. Sample Program Listing\n*****************************~*********~~******~***~**~x*$**************\n\n*\n\n*\n*\n*\n\n*\n\nForce demo program\nT h i s program normalizes a square matrix by its largest element.\n-An external Force module, IXThlAT, is called to initialize the\nmatris. .4nother Force module, OCTAIAT, is called t o print t h e\nfinal matris.\n\n**********i***************************************x************~********\n\nI\nI\n\nForce DE110 of N P ident hlE\nPrivate REAL PXIXX, TEhl\nPrivate INTEGER INDES\nShared REAL S(lOO.100)\nXsync REAL ALL3lk.X\nEx t ern f INThf AT\nE n d declarations\n\nC\n\nINTMAT is an esternal subroutine that will will initialize t h e matrix.\nForcecall INThIAT(X,100)\n\nc\n\nNow we must search t h e matrix for its greatest element ...\nALLXLLX holds t h e currunt maximum value\nInitialize -4LLAI.L.X\nBarrier\nYoid ALLMAX\nProduce ALLA1.L.X = 0\nE n d barrier\n\nI\n\nC\nC\n\nC\n\nC\n\n200\n\nPreschedule rows of X among processors ...\nEach processor finds t h e maximum of its row in t h e inner loop.\nPresched d o 100 I = 1,100\nDO 200 j = 1,100\nTEM = ABS(X(1,J))\nIF (TEM .GT. PhlAX) PMAX = TEM\n\nCONTINUE\n\n100\n\nE n d presched do\n\nC\n\nT h e processors communicate t o find the overall max of their local may vals.\nConsume ALLMAX into TEM\nIF (PMAX .GT. TEM) TEM = PMAX\nProduce ALLMA)[ = TEM\n\n26\n\nSynchronize ...\nBarrier\nEnd Barrier\n\nC\n\nCopy ALLMLX into PMAX\n\nIF (P5iAX .GT. 0) T H E N\n\nc\n\nSormalize t h e matrix, dividing t h e labor on t h e outer loop\nPresched do 300 I = 1.100\nDO 400 J= 1,100\nS( J ) = S(I, J) / PMAX\nI,\nCONTINUE\nEnd presched do\n\n-100\n300\n\nBarrier\nEnd barrier\n\nEND IF\n\nc\n\nOUThI.4T will perform sequential i/o ...\nPcase on ISDEX\nCall OC\'TMAT(X, 100)\nEnd pcase\n.Join\n\nEND\nSCBROUTINE OGTXIAT(X,N)\nISTEGER N, INDEX\nREAL S ( N , N )\n\nDO 10 I = 1,X\nDO 10 J = l , N\nwrite(6,") I, J, X(I,J)\n\n10\n\nRETURN\nEND\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n*\nAssume t h a t t h e next program listing is in a separate file.\n..........................................................................\n\nc\nc\n\nForcesub INTMAT(MAT,N) of N P ident ME\nThis parallel subroutine will initialize t h e matrix M.4T\nto a "test" value.\n\n27\n\n.\n\n.\n\n.\n\n.\n\nINTEGER N\nREAL M A T ( N , S ) , GEN\nE n d declarations\nPresched do 20 I = l . N\nDO 30 J = l,N\n\'The sequential function G E N is used t o generate values.\nMAT(I, J ) = GEN(1,J)\nCONTIXVUE\nE n d presched do\nRETURN\n\nESD\nREAL FUNCTION GEN(1,J)\n0.0 < GEN <= 1000.0\nI S T E G E R I, J\n,\' ( ( I + J ) .GE. 1) T H E N\ni\nG E N = 1000.0 / (I+J)\n\nELSE\nGEN\n\n=\n\n1000.0\n\nEND IF\nR ETL-R N\n\nEND\n\n........................................................................\n........................................................................\n\nI\n\nI\n\nI\n\n28\n.-\n\nREFERENCES\nH. F. J o r d a n , "Structuring parallel algorithms in an hII\\ID, shared\nmemory environment," Parallel Computing. vel. 3, No. 2. p p . 93-110,\n\nP\nI\n\nhlay 1986.\n\xe2\x82\xac1. F. Jordan, "The force on t h e Bex: global parallelism and portability,"\nIC=ISE Report X o . 86-54, NASA Langley Research Center. Hsmpton, Virginia. .August. 1986.\nFie .r/3 2 d u 1tic o m p u t e r: System 0c e r 29 i e u,, F 1ex i b 1e Co m p u t er Corporal\ntion, Dallas, Texas, 1986.\n,Ilultirnaz Technical Summary, Encore Computer Corporation, Aiarlboro,\nllassachusetts, May, 1985.\n\n29\n\n-- ~ G R AAT A~ H I1. C 50.\n~ ~ L ~\nD\nReport\n\n2.\n\n3. Hcclpren:\'s Accession No.\n\nECE Tech. Rept. 86-1-4R\n\nHEET\n1 itle and SuxicIe\n\n5. Report Uate\n\nForce User\'s Manual\nAuthor(s)\n\nHarry F. Jordan, Muhammad S. Benten,\nAruna V. Ramanan and Norbert S. Arenstorf\n\nPerforming Organization Sam;\n\nand Address\n\nComputer Systems Design Group\nDepartment of Electrical and Computer Engineering\nUniversity of Colorado\nBoulder, CO 80309-0425\n. Sponsor:ng\n2\n\nOrgmizarion Name\n\nand Address\n\nNational Aeronautics and Space Administration\nLangley Research Center\nHampton, VA 23665\n\nJune 1987\n6.\n8. Performing Organization Repc.\n\nCSDG 87-2\nIO. Pro)ecr/Task/Uork Unir ho.\n1 I. Contracc/Crant No.\n\n--\n\n;\ni 1 640\n.4G\n13. Type of Report 8 Period\nCovered\n\nInterim\n14.\n\n5. Abstracts\n\nA methodology for writing parallel programs for shared memory multiprocessors\nhas been formalized as an extension t o the Fortran language and implemented\nas a macro preprocessor. The extended language is known as the Force, and\nthis manual describes how t o write Force programs and execute them on the\nF1exibl.e Computer Corporation Flex/32. the Encore Multimax and the Sequent\nBalance computers. T h e parallel extension macros are described in detail,\nbut knowledge of Fortran is assumed.\n\n7. K e y U\'ords and D o c u a e n c Analysis. 170. Descriptors\n\nparallel programming\nmultiprocessor\nshared memory\nForce macros\nFortran\n\n7b. Identifiers/Open-Ended Terms\n\nFIex/32\nEncore Multimax\nSequent Balance\n\n'