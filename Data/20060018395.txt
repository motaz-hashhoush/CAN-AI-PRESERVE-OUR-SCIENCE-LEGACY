b"i\n\n*\n\nSource of Acquisition\nNASA Ames Research Center\n\nI\n\nIdentifying executable plans\nTania Bedrax-Weiss\xe2\x80\x99\nJeremy D. Frank\nConor McGann*\nAri K. J6nssont\nNASA AIMS Research Center, MS 269-2\nMoffett Field, CA 94035-1000,\n{tania, f r a n k ,jonsson, cmcgann}@email. arc.nasa.gov\nAbstract\nGenerating plans for execution imposes a different set\nof requirements on the planning process than those imposed by planning alone. In highly unpredictable execution environments, a fully-grounded plan may become inconsistent frequently when the world fails to\nbehave as expected. Intelligent execution permits making decisions when the most up-to-date information\nis available, ensuring fewer failures. Planning should\nacknowledge the capabilities of the execution system,\nboth to ensure robust execution in the face of uncertainty, which also relieves the planner of the burden\nof making premature commitments. We present Plan\nIdentification Functions (PIFs), which formalize what\nit means for a plan to be executable, m d are used in\nconjunction with a complete model of system behavior\nto halt the planning process when an executable plan is\nfound. We describe the implementation of plan identification functions for a temporal, constraint-based planner. This particular implementation allows the description of many different plan identification functions.\n\nIntroduction\nPlanning has been an important problem in Artifcial\nIntelligence, but plan execution is a problem that AI\nhas often overlooked. In fairly simplistic and highlypredictable environments, the planning system can\nhand a fully-grounded plan to the execution system and\nthe execution system will be able to execute it flawlessly. However, in unpredictable environments, a fully\ngrounded plan will often result in execution failures.\nAdditionally, it is inefficient for the planning process\nto commit to decisions in advance that are likely to be\ninvalidated during execution. One way to avoid these\nproblems is to have an intelligent execution system that\nis able to \xe2\x80\x9cfill in the blanks\xe2\x80\x9d given a plan that is not\nfully grounded. Intelligent execution may range in complexity from fairly simple computations t o a process resembling full-blown planning. Depending on the characreriStics crf the ~ x e c ~ ~ t i o f i\nenvir~nm-enf, best plan\nthe\nt o hand to the execution system will contain more or\nless commitment and information.\n~\n\n\xe2\x80\x98QSS Group, Inc.\n\n2\n\nResearch Institute for Advanced Computer Science\n\nAI sdutions fer placning uld p!m execution often use\ndeclarative models to describe the domain of interest.\nThe planning system typically uses an abstract, longterm model and the execution system typically uses a\nconcrete, short-term model. In mast systems that deal\nwith planning and execution, the language used in the\ndeclarative model for planning is different than the language used in the execution model. This approach enforces a rigid separation between the planning model\nand the execution model. The execution system and the\nplanning system have to agree on the semantics of the\nplan, and having two separate models requires the system designer to replicate the information contained in\nthe planning model in the execution model. Since much\nof the knowledge may be shared between the planning\nand execution systems, this produces a model synchronization problem. Furthermore, if the execution system\nwants to relay information back to the planner, in this\nscenario, the information has to be translated. Not using the same language may be detrimental because synchronization and translation may introduce errors and\nincrease model engineering effort.\nIf both the execution and planning systems have a\ncommon language, then information from and t o the\nexecutive can flow seamlessly. Furthermore, changes\nin the planning model are then automatically propagated to the execution model. In addition, it is easier\nto modify the boundary between planning and execution systems in such systems. Even if a single model for\nplanning and execution is not available, there are still\ngood reasons for making it easy to vary the boundary\nbetween planning and execution systems using a single\nmodel of system behavior. Many candidate execution\nsystems may be available; identifying the right one requires a planning model that can be used with any one\nof the possible execution systems.\nAn executable plan is a plan that the execution system can make any remaining decisions and then translate the result into commands that can be sent to the\nhardware with which the syszern is irritraciirig. Based\non this notion, the \xe2\x80\x9cexecutability\xe2\x80\x9d of a plan depends directly on the capabilities of the execution system. For\na general model of system behavior, we would like to\nspecify which parts of that model describe the commit-\n\n4\n\nb\n\nments that should be made by the execution system.\nIn this paper we provide the formalism and implementation of Plan Identification Functions PIFs . These\nfunctions exactly characterize the executable plans in\na model that is shared between the planner and the\nexecutive. Thus, they serve to separate the duties of\nplanning by partitioning the planning problem into a\nset of commitments that are made in advance, and a\nset that are interleaved with plan execution.\nWe will proceed by presenting a simple example to\nclarify some of these notions.\n\nA Simple Example\nTo examine the issues involved in generating plans for\nexecution, let us consider a simple spacecraft that can\nslew (i.e, turn to different orientations), take pictures,\nand download pictures to Earth.\nA plan request for this spacecraft might consist of a\nset of picture requests, and then a request for downloading some or all of these pictures to Earth. The\nplanning process would generate an \xe2\x80\x9cexecutable plan\xe2\x80\x9d\nthat achieved those goals. The execution agent would\nthen execute the plan by thrusting to rotate the spacecraft, activating camera components, and transmitting\ndata.\nA traditional approach to this problem would be\nbased on separating the planning from execution at\nsome specific level of abstraction. For example, the\nplanning process might involve generating slew actions, orientation maintenance actions, picture-taking\nactions, and download actions. The complete plan, at\nthat level of abstraction, would then be executed by\nbreaking each high-level action down into specific commands that together perform the action. The slew actions, for example, would be broken down into engine\nwarmup, thruster firing, wait, opposite thruster firing,\nand then stabilization. The sequence of execution commands would have to fit within the time allocated to\nthe slew action.\nIf the execution system is sophisticated, it could determine how fast to slew, since the slewing rate is controlled by the time spent firing the engines at the start\nand end of the slew. Slower slew rates typically save\nfuel. The execution system might also be able to determine when to start activities that have some temporal\nflexibility. Rather than waiting until the next action\nstart time, which is bound to be later rather than earlier, to provide a safety margin, the execution system\ncould determine that all earlier actions have been completed, that the action in question can start as early as\na given time, and then start that action at that time.\nIn the Remote Agent Experiment (JMMfOO;\nMNP+98), the planning process built a partial plan\nwhere certain temporal decisions were left to the execution engine. These temporal decisions were limited\nto those that together formed a simple dispatchable network (MMT98). However, as noted in (JMM+OO), the\nnotion of retaining flexibility in the executed plan can\nbe generalized to an arbitrary set of decisions.\n\nModels of System Behavior\nsystem model defines the set of possible states\nactions, along with rules that specify allowed\nforbidden relations between actions and states.\nstates and actions are defined by predicates like\npointingAt (obj ect) and slewFromTo ( o b j 1, o b j 2 ) .\nWe define a partial plan as a collection of temporal predicate statements, based on a given model. We assume\nthat the parameter set for each predicate doesn\xe2\x80\x99t have\nto be fully grounded. This notion naturally supports\nmore flexible planning paradigms such as those used in\nconstraint-based planning systems.\nThe rules in the system model specify, directly or\nindirectly, the conditions for a state or action being in\nthe plan:\n0 which instantiations of statelaction predicates are\nvalid\nfor each actionlstate, what other states or actions\nmust exist in the plan to support it\n0 the temporal and parametric relations between states\nand actions\nFor example, a model for our simple spacecraft\nwould state that the predicates include pointingAt ,\nslewingFromTo, takepicture, download. Legal instantiations of slewingFromTo are limited to those\nwhere the origin and destinations are not the same, and\ntakepicture instantiations are limited to objects and\ntimes where an overly bright object, like the sun, is not\nin the frame. There are a number of relations between\npredicates in this model; for example, a takepicture\nmust be done within a period where the spacecraft is\npointing at the object in question. This means that\nthere must be a pointingAt predicate in the plan, and\nthat furthermore, the appropriate pointingAt must\nhave the same object value as the takepicture, must\nstart no later than the takepicture and must end no\nearlier than the takep icture.\nIt should be noted that this core approach covers basic STRIPS-like descriptions, where states are preserved\nby the frame axioms and action definitions define state\nchanges. It also covers constraint-based approaches,\nwith and without an explicit representation of time or\nresources. Furthermore, in STRIPS, the initial state\nand goal statements are simply part of a partial plan\nthat must be extended to include the actions necessary\nto go from the initial state to a goal state. Since both\nplanning and execution use the same model, the plan\nis semantically meaningful to both the planner and the\nexecutive l .\nThe rest of the paper is organized as follows. We\nfirst provide a formal definition of PIFs and characterize some useful properties of PIFs . We then describe\nan implementation of PIFs in a planning framework\ncalled EUROPA. We identify some important implementation details that arise when implementing PIFs\nThe\nand\nand\nThe\n\n\xe2\x80\x98This idea is borrowed from (MDF+02), which we describe later in the paper.\n\nin this framework. We then conclude and discuss severa1 open issues.\n\nPlan Identification\nWe now turn our attention to formally defining the concepts related to general plan identification. We begin\nwith a general and expressive approach to planning,\nwhich supports arbitrary variables, quantitative temporal relations, arbitrary constraints, and expressive\nactivity-state rules.\n\nConstraint-based planning\nIn order to address realistic problems, a planning\nparadigm must support actions and states with temporal extent, complex reiations anivng action and state\narguments, as well as complex model rules about conditions and effects of actions and states. In recent years,\ndifferent approaches have been proposed for moving\naway from the classic STRIPS paradigm, and towards\nmore realistic approaches that incorporate explicit representations of time and resources. These approaches\nfall into a broad category called Constraint-Based Planning (CBP) (SFJOO).\nThe basic idea behind CBP is to use variables to\nrepresent all aspects of states and actions, and to use\nconstraints to enforce relations between those variables.\nThe basic element in constraint-based planning is an interval. An interval is simply a predicate holding over a\nperiod of time. The start and end of the interval and\nthe parameters of the predicate are described by variables. M a e formally, an interval is a tuple, (p, s, e),\nwhere B is a predicate name, X is a vector of variables\ndefining the arguments to the predicate, and s and e\nare temporal variables, defining the start and end of\nthe interval.\nA planning domain is defined by the set of kterval\ntypes, and a set of configuration rules. A conjiguration rule is a generalization of the notion of preconditions and effects. Instead of specifying only state\nvalues before and after an action, a configuration rule\ncan specify arbitrary temporal relations specifying how\nactions and states must relate in a valid plan. This\nmeans that a configuration rule can specify that whenever an attribute is assigned an interval of a certain\nkind, other intervals must exist in the plan, such that\nspecific constraints are satisfed. In addition to temporal constraints, configuration rules can specify other\nconstraints amongst the parameters of the actions and\nstates.\nIn\nour\nspacecraft\nexample,\nconsider a takePicture(x) interval, I , for the camera attribute. A configuration rule might specify that\nthere must be a pointingAt (y) interval, J , such that\nx = y , t h e siarr. of j is at ieast iG seconds before the\nstart of I , and the end of J is no earlier than the end\nof I . Notice that the latter constraint in the rule is not\nstrictly a precondition or an effect, but only involves\ntemporal constraints.\n\nx,\n\nIn constraint-based planning, partial and complete\nplans are represented as networks of intervals. The connections between intervais in such a necwork are defined\nby the configuration rules.\n\nPartial plans and completions\nIn CBP, a partial plan consists of a set of intervals and\na set of constraints among the variables representing\nthose intervals.\nA partial plan P is valid, if for every applicable configuration rule, all the intervals and constraints required\nby those rules are in P. A partial plan P is instantiated, if each variable has been given a single value. A\npartial plan P is consistent if none of the constraints in\nthe plan are violated and inconsistent otherwise.\nA planning problem is simpiy a partial pian. This\nnotion generalizes the very restrictive STRIPS notion\nof only specifying an initial state and a set of goals. The\nnotion of a planning problem as a partial plan allows\nspecific actions as goals, supports the specification of\nmaintenance goals, makes it easy t o define exogonous\nevents, and much more. Planners can modify plans in\ntwo ways. A restriction is defined as the binding of a\nvariable or the addition of a constraint. A relaxation is\ndefined as the unbinding of a variable or the removal of\na constraint. An extension of a given partial plan, P , is\na plan Q such that each interval in Q can be mapped to\na compatible interval in P , and each constraint in P is\nin Q. Thus, restricting a plan P results in an extension\nQ, and relaxing a plan Q\xe2\x80\x99 results in a plan P\xe2\x80\x99 such that\nQ\xe2\x80\x98 is an extension of P\xe2\x80\x99.\nA partial plan, Q is complete if every interval is instantiated and the plan is valid. Q is a completion of\nevery relaxation of &. We say that a problem instance\nP has a solution if it has a consistent completion Q.\nThe strictest notion of solving a planning problem P\nis t o find a consistent compltior? of P . However, a more\ngeneral notion is much more useful when it comes to\nplanning for execution agents that are not completely\ntrivial in complexity. In essence, solving a planning\nproblem P for an intelligent execution agent involves\nfinding a consistent extension Q that can be executed by\nthe given execution agent. We now turn our attention\nto a general formulation of such a notion.\n\nPlan identification functions\nConsider a partial plan encountered during the course\nof planning. We would like a declarative description\nof the set of plans that can be accepted for execution\nby the execution system. This is the notion of plan\nidentification functions (PIFs ). The basic idea is to\nhave a mapping that indicates whether or not a partial\nplan is suitable for a given execution engine or not.\nIdentifying inconsistency is a natural complement to\npian identification. Consider a partiai pian that has\nno valid completions. In a sense, the partial plan is\na dead-end. However, it is computationally expensive\nto determine whether any given partial plan is inconsistent or not. Consequently, it is useful to think of a\n\nc\n\n\xe2\x80\x9cconsistency identification function\xe2\x80\x9d that maps partial\nplans to T, F, or 7, where the T value indicates that the\nplan is consistent, F indicates it is inconsistent, and ?\nindicates that the consistency of the plan is not known.\nThe original notion of a PIF appeared in (JMMfOO).\nThis definition combined the notion of consistency with\nexecutability, and used three return values, T,F and ? A\nreturn value of F indicated that the plan violated some\nconstraint, i.e. no extension of the plan was consistent,\nwhich forced the planner to backtrack. A return value\nof T indicated that all intervals were valid and consistent according to a set of applicable configuration rules,\nand thus planning was complete. A return value of ?\nindicated that the plan was consistent but not valid,\nand thus the planner had to continue searching for an\nextension.\nIn this paper, we define a more relaxed notion of a\nplan identification function. A PIF maps partial plans\nto the values Y and N. A return value of Y indicates\na plan is executable and a return value of N indicates\na plan is not executable. Keeping the definitions as\ngeneral as possible, we do not pose any more restrictions\non the evaluations of partial plans. For example, it is\npossible that plan execution systems may be based on\ntechnology that works in the space of inconsistent plans,\nand thus we want to be able to specify PIFs that are\nable to pass inconsistent plans to the execution system.\nWe therefore look at specific characteristics of PIFs that\nare desirable in certain cases.\n\nCharacteristics of plan identification\nfunctions\nRegardless of the impact of execution, we assume that a\npartial plan P must be consistent when the plan execution commences. We also assume that the instructions\nthe execution system issues to the underlying hardware\nf\nare based on fully instantiated plans. I either of these\nconditions is not satisfied, then the plan execution system must be able to come up with a consistent complete\nplan.\nThe simplest question one can ask of a plan handed\nto the execution system is whether it has a consistent\ncompletion. In most (but not all) cases, such correctness would be a crucial characteristic of an executable\nplan.\nA PIF , i, enforces correctness if, for any partial plan\nP , such that f(P) y, P has at least one consistent\n=\ncompletion.\nThe next question is how much work needs to be done\nby an execution engine to find a consistent completion\nin different circumstances. This is a particularly interesting question if uncertainty during execution is taken\ninto account.\nA PIF , i, enforces solvability if, for any partial plan\nP , such that i ( P ) = y, all extensions of P are complete\nand consistent.\nIt is often difficult to find plans satisfying the above\nproperty without finding a complete plan to begin with.\nAs such, it is useful to identify PIFs that return partial\n\nPartial Plan\n\nFigure 1: The Plan Identification Function as a Flaw\nFilter\n\nplans that require only a bounded amount of time to\nsolve. In cases where a PIF returns inconsistent plans\nto the executive, it is also useful to characterize the\namount of time that search in the infeasible space is\nperformed. Because of the different search procedures\nrequired we provide two definitions below.\nWe first want to formally characterize an executive\nthat can efficiently ensure a completion of a consistent\nplan can be found, if one exists. A PIF , i, enforces\nO ( f ( n ) )solvability if, for any consistent partial plan P\nsatisfying i ( P ) = y, then in time O(f(lP1))either a\nconsistent completion of P can be found or it can be\nshown that no consistent completion of P exists.\nOn the other hand, if the executive is handed an inconsistent plan, the problem is somewhat different. In\nthis case, no completion is possible. Instead, we must\nfind a completion of the original planning problem that\nthe planner attempted to solve. Suppose the original\nplanning problem is R. A PIF , i, enforces O ( f ( n ) )\ntransformability if, for any partial plan P satisfying\ni ( P ) = y, then in time O(f(lP1))a series of transformations of P resulting in a &, a consistent completion\nR, can be found, or it can be shown that no such completion exists.\n\nExamples\nIn the Remote Agent Planner, the PIF accepted only\nconsistent and valid plans where all parameter variables\nhad been assigned specific values, but tolerated unassigned temporal variables forming a dispatchable simple\ntermporal network (JMM+OO). The restriction that the\nresulting temporal network be dispatchable made the\nPIF correct and provided a linear bound on how much\ntime it would take the execution engine to complete a\ngiven plan. This is an O ( n ) solvable PIF .\nRecent techniques have extended the ability of execution systems to handle uncertainty in temporal quantities. In particular, (MMVO1) presents an algorithm\nthat can detect when a temporal network with uncertainty can be executed without failure, and (MMO1)\npresents an algorithm for executing such networks in\npolynomial time. Thus, we can write PIFs for such\nwhere f is a polynomial.\nproblems that are O ( f ( l P I ) ) ,\n\nJ\n\nFrom Plan Identification t o Flaws\nWe ha7e forma!!y defbed the PIF as a function from\na plan and a model to an answer of either Y or N. In\npractical applications, however, a planner using the PIF\nwould like further indication of what is wrong with the\nplan when the answer is N. A more useful notion of a\nPIF , depicted in Figure 1, is one that given a plan and\na model, returns a set of possible plan modifications if\nthe answer is N and the empty set if the answer is Y.\nWe refer to the set of plan modifications as flaws.\nA flaw is a modification to a partial plan, either a\nrestriction or a relaxation. Let 3 ( P )be the set of flaws\ns\nderived from plar, P. We can now redefine a PIF a a\nmapping: F ( P ) + 27(p). That is, the PIF identifies a\n(possibly proper) subset of the flaws that define the set\nof plan modifications that a planner can make.\nThe set of flaws can be defined in different ways depending on how the planner conducts search. For example, suppose the partial plan has valid extensions.\nmight consist only of the set of\nThen the set, of P,m~s\nrestrictions that a planner can impose in its search for a\ncompletion that satisfies the PIF . However, a planner\nsuch as ASPEN (FRCY97) can benefit from flaws that\nare restrictions or relaxations, since it c m search the\nspace of infeasible solutions.\nNotice that it could require exponential space to define very complex plan identification functions if it were\nnecessary to enumerate all the possible sets of flaws and\nthe mapping that applied for each of those flaw sets.\nPracticality dictates that we have a concise manner of\nboth expressing and evaluating PIFs .\n\nAn Implementation of Plan\nIdentification\nWe have implemented the notion of a PIF as a flaw\nfilter in the context of the Construant-based Attribute\nand Interval Planning framework (FJ03) (CAIP), in the\nsystem called EUROPA (Extensible Universal Remote\nOperations Planning Architecture). In this section we\nfirst give an overview of EUROPA, then describe the\nPIF implementation. Further details on EUROPA implementation can be found in (FJ03); in this section, w\ne\nfocus on those aspects that are most relevant to PIFs .\n\nEUROPA Overview\nCAIP is an extension of CBP. Like the basic constraintbased planning paradigm, intervals provide the basic\nrepresentation of actions with durations and states with\ntemporal extent. The key addition is in the notion of an\nattribute. An attribute represents some system, subsystem or other .zspect of the domain for which planning is\nbeing done. An attribute can only take on one value at\na given time, so attributes enforce a mmuai eXCiUSiUn\nrelation among intervals that are assigned t o the same\nattribute. In addition, each interval must be placed on\nan attribute. This requirement enforces mutual exclusion among all intervals.\n\nEUROPA\n\nI\n\nPlan Database\n\n3\nPartial Plan\n\npartial Plan\xe2\x80\x99\n\nFigure 2: Planning For Execution With EUROPA\nIn our spacecraft example, the state of the camera\nmight be one attribute. When a picture is being taken,\nthe camera takes on the state t a k e p i c t u r e , otherwise,\nthe state is cameraIdle or slewingFromTo. Similarly,\nthe attitude of the spaccraft could be another attribute,\nwhose values are instantations of slewingFromTo and\np o i n t ingAt.\n\nA partial plan in EUROPA consists of a mapping of\nattributes to sequences of intervals, a set of free intervals, and a set of constraints on variables in the given\nintervals. Free intervals are intervals that have not been\nsequenced on attributes yet. We assume for simplicity\nthat the set of flaws of a partial plan is comprised of\nfree intervals and unbound variables 2 . A plan identification function, then, takes the set of free intervals and\nunbound variables in the plan database and returns a\nsubset of these in response to a query from the planner.\nFigure 2 shows the overall architecture of EUROPA\nin the context of planning for execution. The system is\ncomposed of the following modules: a planner, a plan\ndatabase, and a plan identification module. Planning\nbegins with a partial plan and a domain model. The\nplan database is initialized with the partial plan and\nthe model. During planning, a planner can query the\nplan database through the plan identification module\nfor flaws in the initial partial plan. Flaws are defined in\nterms of the model configuration rules and the PIF acts\nas a filter. If no flaws remain and the plan is consistent,\nthe planner concludes that a plan has been found. If\nflaws remain, however, the planner makes commitments\nt o resolve the remaining flaws by updating the plan\ndatabase. The planner thus alternates between asking\nthe plan identification module for flaws and updating\nthe plan database until a plm that satisfies the model\nand the PIF is found.\n2Note that this set of flaws is only useful for planners that\nsearch in feasible space, but EUROPA can support other\nflaws as well.\n\nc\n\nIn the EUROPA plan database, predicate arguments,\ntimepoints, and attributes of an interval are represented\nas variables. Configuration rules impose constraints on\nthe values these variables can take. The plan database\nmanages the variables and constraints and makes use\nof a temporal network to maintain consistency between\ntemporal variables and the temporal relationships imposed by the configuration rules. The plan database\nalso uses a constraint network to maintain consistency\namong all other variables and constraints.\nConsider the following simpIe model of the spacecraft\ndomain. The first half of the model specifies the intervals that can appear on each attribute, and the second\nhalf specifies the configuration rules. We use the simple\ntemporal relations of Allen\xe2\x80\x99s Algebra to specify constraints between the timepoints of required intervals.\nWe also assume that parameters of different intervals\nwith the same variable name require the parameters to\ntake on the same value.\nAttitude :{pointAt (obj e c t ) , turnTo (obj e c t ) }\nCamera: {off (1, r e a d y ( ) , takePic(object)}\nTake-Picture(B) -+ met-by ready()\nTake-Picture ( B ) -+ contained-by pointAt ( B )\nr e a d y 0 -+ met-by o f f (1\npointAt ( B ) -+ met-by turnTo(B)\nFigure 3: A simple model of the spacecraft domain\n\nEUROPA enforces configuration rules by means of\nthe following plan invariant whenever a plan modification results in a change to the set of plan completions,\nthe intervals in the plan are updated. New intervals\nare added as free intervals. In the case of relaxations,\nsome intervals that were part of the plan may no longer\nbe justified, and if so, the intervals and all associated\nvariables and constraints are removed. In the case of restrictions, new intervals, variables and constraints may\nbe needed in the plan, and if so, they are added.\nFigure 4 shows a plan fragment based on the simple\nmodel. The Camera attribute is initially turned off, then\nit is ready, and then it is taking a picture. While the\nCamera is taking a picture of the object, the A t t i t u d e\nis pointing at the object. Notice that there are two free\nintervals, one with predicate turnTo and one with predicate pointAt. The free interval turnTo was generated\nby the plan invariant, while the free interval pointAt\nwas part of the initial problem instance.\nConsider the interval pointAt(A) which is inserted on the A t t i t u d e attribute. In this case, the\nrule pointAt(B) + met-by turnTo(B) means that\nif a pointAt(B) interval exists in a plan, then a\nturnTo ( B ) must preceed the pointAt ( B ). The presence of the pointAt(& interval forces the addition\nof the free turnTo(C) interval due to the plan invariant. Similarly, if the pointAt(A) interval is removed\nfrom the A t t i t u d e attribute, then the free interval\nTurnTo ( C ) is no longer justified, and is removed from\nthe plan.\n\n-\n\nLEGEND\n\n+ i Interval\n+\nPrecedence\nConstraint\n\nTemporal\n\\\xe2\x80\x98aria&\n\nEquality\nConstraint\n\n+\n+\nFigure 4: A simple partial plan for the model described\nin Figure 3\nIn EUROPA, the parameter equivalence is handled\nby creating a new variable for the required turnTo interval and posting an equivalence constraint between the\nparameters. In this example, the parameter C of the\nturnTo predicates has been equated with the parameter A of the sequenced p o i n t A t 0 interval. Finally,\nwe note that C has not been bound to any particular\nvalue, while parameter D of the other turnTo has been\nbound to value d.\n\nPlan Identification in EUROPA\nIn EUROPA, the PlanId function is implemented as\na filtering operation on the set of flaws in the plan\ndatabase. To support this, the system must provide\ncapabilities to:\n1. obtain access to the set of flaws in the plan database;\n2. define a filter expressing criteria for including or excluding a flaw;\n\n3. obtain a set of filtered flaws by applying such a filter.\nThese capabilities are accomplished by providing:\n1. a flaw storage mechanism, referred to as the\nFlawcache, which keeps the set of flaws in the plan\ndatabase synchronized with changes made through\nexplicit commitments by the planner or derived\nthrough inference.\n2. a highly customizable filtering structure which allows\npre-defined conditions and/or new custom conditions\nto be seamlessly integrated in a single filter.\n3. a flaw querying facility which handles all access to\nthe Flawcache and applies filtering criteria defined\nby the planner.\n\nThe remainder of this section describes in more detail\nthe framework developed to achieve this in an efficient\nand customizable manner.\n\ni\nPlanner\n\nand event-based synchronization leads to efficient implementation.\n\nwhile (done==false)\nif (isconsistent 0)\nfilteredFlaws=getFlawsFromQuery ()\nif (filteredFlaws.isEmpty () ==false)\nnextFlaw = choose(filteredF1aws)\nresolve(nextFlaw)\nelse done=true\nelse... // rest of the algorithm omitted\nend while\nFigure 5: Class Diagram of the PlanId Framework\nFignre 5: Planning with Flaw Queries.\n\nFramework Class Diagram\nFigure 5 presents the internal details of the PlanId module referenced in Figure 2. The PlanDatabase generates events indicating changes to intervals and variables\nwhen the plan invariant is invoked. These events are received by the Flawcache and used to maintain the set\nof all flaws in the system, i.e. all free intervals and unbound variables. Events indicating a restriction may\ncause a flaw to be removed from the Flawcache e.g. inserting a free interval or assigning a value to an unbound\nvariable. Events indicating a relaxation may cause a\nflaw to be inserted into the Flawcache e.g. relaxing t o\ndomain of a variable or freeing an inserted interval.\nA planner creates a Flawquery at the beginning of\nthe planning process. It is by means of a Flawquery\nthat a planner obtains the relevant subset of flaws as\nindicated by a filter. Planner-specified filters are defined in a F i l t e r c r i t e r i a o b j e c t , which is just a collection of Conditions. Each Flawquery has exactly one\nF i l t e r c r i t e r i a instance, provided t o it during construction. Condition objects provide the customization necessary for planners to filter out flaws they wish\nto ignore. For a Flaw in the FlawCache t o be returned\nby a Flawquery, all Conditions must be satisfied.\nIn order to gain access to the set of flaws and the set of\nflaw changes, each Flawquery establishes a Connect ion\nwith the Flawcache. A Connection provides access\nto all flaws in the Flawcache. A Connection also\nprovides a location to store information on changes\nin the Flawcache since the the Flawquery was last\nqueried. Notifications of changes in the contents of the\nFlawcache, i.e. flaws inserted or removed, are pushed\nto each connection from the Flawcache as the latter is\nsynchronized with the PlanDatabase.\nThis architecture provides a number of useful features. First, the FlawCache can support many connections at once, enabling it to provide flaws to many\n~!ZLIXI~FS. S e c ~ c d ,a wide ~ i + t y siriiple iofiditi~nj\nof\na x provided, enabling a very large number of different\nPIFs to be expressible. Third, it is very straightforward\nto develop additional conditions making the approach\nvery extendible. Finally, emphasis on lazy evaluation\n\nStep 1:\nFlawCache={A, B , C,pointAt ( D = d ) ,turnTo(C)}\nFilteredFlaws:{A, B , c , p o i n t A t ( D = d ) }\nnextFlaw: pointAt ( D = d )\nStep 2:\nFlawCache={A, B , C, E,turnTo(C) ,turnTo(E)}\nFilteredFlaws:{A, B , C,E }\nnextFlaw: E\nStep 3:\nFlawCache={A, B , C}turnTo ( E = d ) ,turnTo ( C )]\nFilteredFlaws:{A, B , C}\nnextFlaw: A\n\nFigure 7: Evolution of the flaws for the partial plan in\nFigure 4.\n\nTo see how the flaw filtering works, consider the sam.\nple partial plan shown in Figure 4 There are five\nflaws: the variables A, B and C, the turnTo(C) interval and the p o i n t A t ( D = d ) interval; the FlawCache\nhas these five flaws. Now suppose that the PIF filters out intervals with predicate turnTo. Then the set\nof filtered flaws consists of the three variables and the\npointAt (D= d) interval.\nThe basic loop of a planner is similar to the fragment\npresented in Figure 6. At each step, the planner requests the filtered flaws. Once the flaws are retrieved,\nthe planner uses some criteria to select a flaw, then uses\nanother criteria to resolve the flaws. Application of the\nplan invariant and propagation of variable changes in\nthe constraint network result in updates to the FlawCache. Subsequent queries to the FlawQuery will return a new set of flaws that accounts for these updates\nand the filtering of these flaws by the PIF .\nTIl:\n-.\nLu act: tiiia pucIeaa iii actioii, kt i i CO&&i\n~\na few\nsteps of planning given the partial plan and PIF that we\nhave described. This process is shown in Figure 7. Let\nus assume that choose selects flaws according to some\narbitrary order. Also suppose that resolve performs an\n^^^\n\n-I^-^--\n\ninsertion for free intervals or a variable assignment for\nunbound variables. After inserting p o i n t A t ( D = d )\nwe see that the plan invariaiit ensures the creation of\na turnTo ( E ) interval. The FlawQuery, however, indicates that the set of filtered flaws at step 2 only includes\nthe variables A , B , C, E. At the next step, choose() returns flaw E ; there is only one possible value, d, and\nthus the plan invariant doesn\xe2\x80\x99t lead to the creation of\nany new variables or intervals.\nSuch a simple filter could be achieved with- a single condition which would check the predicate name of\neach interval flaw and exclude it if it matched the name\nturnTo.\n\nEUROPA Plan Identification Function\nCapabilities\nEUROPA\xe2\x80\x99s PIF framework supports the following conditions, among others:\n0 Interval predicate filtering - filters all intervals of a\nparticular predicate.\n0 Interval variable filtering - filters selected variable of\nall intervals with a particular predicate.\nAttribute filtering - filters all intervals and all variables of all intervals from a particular attribute.\n0 Temporal filtering - filters intervals according to a\nvariety of temporal specifications. One example is a\nfilter for intervals guaranteed not to happen within a\ntemporal extent (a horizon filter).\nIn practice, different applications will impose different requirements on plan executives. In an execution\nenvironment that is uncertain, there are advantages to\nnot fully specifying a plan. To be robust against uncertainty in the execution environment a plan must be\nflexible. For instance, if decisions cannot be determined\nin advance because the way in which they are made depends on factors that are only determined at execution\ntime, it may be advantageous to leave these decisions\nup to the execution system. The PIF framework allows considerable latitude in defining the capabilities\nof execution systems, and thus enables the planning\ntechnology to be more widely useful. However, it also\nprovides considerable flexibility within a single application. Engineers can design different PIFs and analyze\nthe resulting performance of the integrated planning\nand execution system, and choose the PIF that works\nbest.\nAn execution system will typically only care about\nthe plan developing inside the current execution window. If this execution system is implemented as a planner, a PIF could be used to focus the planning effort\non that execution window only using the horizon filter. Such a PIF would contain a horizon condition that\nwould specify, for each free interval and each unbound\nvariable, whether it falls within the horizon or not. A\nfree interval falls within the horizon if its start time and\nend time variable domains include the horizon timepoints. An unbound variable will fall inside the horizon\n\nif it belongs to one of the intervals that falls within the\nhorizon.\nThe time at which an event actually occurs is usually different from the planned time. This difference\ncan sometimes prove costly since it may cause some assumptions that were made in the planning stage to fail.\nIn EUROPA, the temporal network is implemented as\na Simple Temporal Network (DMPS 1). Simple Temporal Networks guarantee that if the network is consistent,\nan appropriate set of bindings of the temporal variables\ncan be found in polynomial time. Thus, if the temporal network is consistent, no further commitments on\ntime have to be made during planing. This is assuming\nthat the executive is intelligent enough to be able to\nfind this appropriate set. A PIF provides the means to\ndefine this flexibility if it implements a condition that\nfilters temporal variable flaws. If no temporal variable\nflaws are passed on to the planner, these decisions will\nremain unbound (though constrained by the temporal\nnetwork) until execution time.\nOvercommitment at planning time may prove costly\nin other ways. In cases where a plan consists of highlevel and low-level tasks, the low-level task expansion\nof the high-level tasks may depend highly on when the\ntasks get executed. In such cases, it is convenient to\nlet the execution system map high-level tasks into lowlevel tasks during execution. This frees the planner\nfrom generating low-level tasks, and allows the executive to choose the low-level tasks that best fit the actual\nexecution. In EUROPA, high-level and low-level tasks\ncan be placed on separate attributes. A PIF provides\nthe means to define this flexibility by implementing a\ncondition that filters flaws depending on whether they\nare allowed to be placed on high-level attributes or not.\nA free interval can be placed on a high-level attribute\nif it belongs to the set of allowable states of that attribute. An unbound variable belongs to the high-level\nattribute if it belongs to an interval that can be placed\non the attribute.\nThere are instances of planning for execution when\nsome planning decisions inside one execution cycle may\ndetermine what will happen in a future execution cycle.\nThese commitments are sometimes unnecessary, especially in uncontrolled execution environments. These\nplanning decisions may manifest themselves as particular predicate logic statements or as arguments to predicate logic statements. A PIF povides the means to\ndelay commitment on these predicates or variables by\nimplementing a condition that filters flaws on whether\nthey are based on these predicates or variables.\n\nComplexity Analysis\nIn the simplest implementation, one could omit the\nFlawcache and Connect i o n infrastructure. Resolving a\nquery would be accomplished by iterating over all intervals and variables in the plan database and for each, applying the filter to test for inclusion or exclusion. This\nwould result in a worst-case time-complexity given by\n( N , + Ni)* N, * C, where N,, is the number of vari-\n\n.\nables, Ni is the number of intervals, N,is the number\nof conditions in the filter, and C, is the average cost of\nevaluating a condition.\nSince the points of greatest cost are in the evaluation of conditions, we seek to reduce the execution of\ncondition tests. This is accomplished in a numnber of\nways:\n1. The last set of filtered flaws are cached in each\nFlawquery.\n2. The current set of flaws in the plan database are\ncached in the Flawcache.\n\n3. Each cache is maintained through notifications of\nchanges.\n4. Conditions may be ordered to fail fast, based on the\ncharacteristcis of each problem.\n5. The FlawQuery is updated only when the planner\nconsults it for the latest set of flaws. Thus, the\nqueries are only run on the set of Aaws that were\nadded since the last query.\nThe resulting worst-case cost of a query is approximated by: N+ * N, * C, where N+ is the number of\nflaws inserted into the flaw cache since the last query.4\nThe approximation omits the cost of caching events\nduring synchronization of the Flawcache and the PlanDatabase. This is reasonable since the costs of caching\nare much less than the cost of evaluating the conditions\nover all insertions. Notice that we do not need to worry\nabout flaws that are removed from the cache, since they\naren\xe2\x80\x99t returned t o the planner in any case.\n\nRelated Work\nA wide variety of agent architectures have been designed to support both planning and execution. We\nwill not describe all aspects of these systems here. We\nwill describe how these systems characterize the boundary between planning and execution, and compare it to\nthe approach we have described here.\nMany integrated planning and plan execution frameworks define a fixed boundary between their components. These systems also use different modeling languages, in some cases with different semantics, and thus\nhave potential problems with model synchronization.\nFinally, these systems do not have a crisp declarative\ncharacterization of the boundary between the components. Examples of integrated planning and plan execution systems in this category are 0-Plan (TDK94),\n3T (BFG+97), and Propice-Plan (DI99).\nCypress (WMLW95) is a planning and plan execution framework designed for a variety of applications,\nincluding military operations. Cypress is a loosely coupled integration of the SIPE planner, the PRS reactive\nexeciitinn ~ y ~ t e m , Gister-CL s y s t e ~ f ~ reacning\naqd\nr\n3\nIn practice only Some of the conditions will be executed\nsince we discard the flaw after the first condition fails.\n4\nN+ << (N, Nu)\n+ since there are relatively few flaw\ninsertions resulting from each planner commitment.\n\nunder uncertainty. Cypress enables human intervention\nduring planning and plan execution. Cypress uses the\nACT representation to modei both pianning and execution. The boundary between SIPE and PRS is flexible,\nas PRS can invoke SIPE to handle run-time plan failures. However, there is no facility in Cypress to describe\nthe boundary between the planner and plan execution\nin a declarative way.\nThe Remote Agent (RA) (MNP+98; JMM+OO) is an\nagent architecture for spacecraft control that was used\nin a 2-day experiment of an autonomous probe. The RA\nconsisted of a planner, a plan execution system, and a\nmode identification and reconfiguration system. The\nRA planner built plans that were temporally flexible so\nthat the plan execution system could decide on-the-fly\nwhich tasks to start and end (MMT98). This represented a significant advance at the time; however, other\napplications using the RA could not use any other divide between planning and execution. Furthermore, the\nthree components of the system used different modeling\nlanguages with different semantics, requiring considerable effort to ensure model synchronization.\nIDEA (MDFf02; DLM03) is an agent architecture\ndesigned to overcome shortcomings in the RA approach\nto agent modeling. IDEA provides a simple virtual\nmachine that supports plan execution, consisting of a\nmodel, plan database, plan runner, and reactive planner. The job of the reactive planner component of an\nIDEA agent is to ensure that a \xe2\x80\x9clocally executable\xe2\x80\x99\xe2\x80\x99 plan\nis returned. Thus, a crucial task is t o define the scope\nof the Reactive Planner\xe2\x80\x99s job. The PIF is a natural way\nto focus on those parts of the model that must be addressed by the Reactive Planner. IDEA also supports\nmany planners operating on the same plan database,\nand thus the same model. PIFs are a natural way\nto define the scope of these various planners in order\nto ensure that planners do not step on each others\xe2\x80\x99\ntoes. IDEA also supports multi-agent architectures using inter-agent communication. The original notion of\nIDEA is to separate models for each agent; these models are intended to be written in the same language and\nshare components. Partial plans serve as the medium\nby which planners communicate with the executive, as\nwell as the medium by which IDEA agents communicate with each other. However, the PIF can (in principle) be used to simply divide up the model amongst\nthe agents in a similar manner t o the way it divides up\nmodels amongst planners; the crucial problem to solve\nis dividing plan databases efficiently among the IDEA\nagents.\n\nConclusions and Future Work\nWe have described plan identification functions as a way\nof circumscribing the planning problem that must be\nsoived in order to creace an executa& pian. FiFs na-;e\nthe advantage of enabling a single model to characterize both the planning problem and the plan execution\nproblem. They also enable easy characterization of the\nboundary between planning and plan execution, even\n\nin cases where different models for planning and execution are used. They also provide considerable flexibility, as they allow the boundary betFeen planning and\nexecution to be adjusted. We have described the implementation of the PIF framework of EUROPA, and\nshown how it can be used to implement many PIFs for\ndifferent type of plan execution systems.\nWe have implicitly assumed that a single model of\nsystem behavior can be written, so that PIFs can be\nused to separate the part of system behavior that pertains to the execution system. The IDEA project\n(MDF+02) is pursuing this notion, but it remains to\nbe seen how the concepts extend to more sophisticated\nplanning and control architectures.\nWe have described one way of using PIFs to divide a\nmodel amongst many planners. This approach does not\naddress important architectural issues of mutli-agent\naccess to a shared plan representation. It also doesn't\naddress the issue of how to structure the plan representations used by planners and executives. The efficient\nimplementation of PIFs may be impacted by this architecture.\nNote that while the plan that is passed to the executive may define a set of plan completions, there is\nno reason to assume that the executive chooses one of\nthese completions, and in fact no way to characterize\nthe actions of the executive in a declarative way.\nPIFs can be used for more than just separating planning from the execution system. One can also imagine\npartitioning the planning problem into many different\nproblems using a collection of PIF functions.\n\nReferences\nR. Bonasso, R. Firby, E. Gat, D. Kortenkamp,\nD. Miller, and M. Slack. Experienences with an architecture for intelligent, reactive agents. Journal of\nExperimental and Theoretical Artificial Ingelligence,\n9(2), 1997.\n0. Despouys and F. Ingrand. Propice-plan: Towards a\nunified framework for planning and execution. In Proceedings of the 5th European Conference on Planning,\n1999.\nM. Dias, S. Lemai, and N. Muscettola. A real-time\nrover executive based on model-based reactive planning. In Proceedings of the International Conference\non Robotics and Automation, 2003.\nR. Dechter, I. Meiri, and J. Pearl. Temporal constraint\nnetworks. Artificial Intelligence, 49:61-94, 1991.\nJ. Frank and A. J6nsson. Constraint based attribute\nand interval planning. Journal of Constraints, To Appear, 2003.\nA. Fukunaga, G. Rabideau, S. Chien, and D. Yan. TOward an application framework for automated planning and scheduling. In Proceedings of the 15th International Joint Conference on Artificial Intelligence,\n1997.\n\nA. Jhsson, P. Morris, N. Muscettola, K. Rajm, and\nB. Smith. Planning in interplanetary space: Theory\nand practice. In Proceedings of the Fifih International Conference on Artificial Intelligence Planning\nand Scheduling, 2000.\nN. Muscettola, G. Dorais, C. Fry, R. Levinson, and\nC. Plaunt. Idea: Planning at the core of autonomous\nreactive agents. In Proceedings of the 3d International\nNASA Workshop Planning and Scheduling for Space,\n2002.\nN. Muscettola and P. Morris. Execution of temporal plans with uncertainty. In Proceedings of the 1Ph\nNational Conference on Artificial Intelligence, 2001.\nP. Morris, N. Muscettola, and I. Tsamardinos. Reformulating temporal plans for efficient execution. In\nProceedings of the 15th National Conference on Artificial Intelligence, 1998.\nN. Muscettola, P. Morris, and T. Vidal. Dynamic control of plans with temporal uncertainty. In Proceedings\nof the 17th International Joint Conference on Artificial Intelligence, 2001.\nN. Muscettola, P. Nayak, B. Pell, , and B. Williams.\nRemote agent: To boldly go where no ai system has\ngone before. Artificial Intelligence, 103(1-2), 1998.\nD. Smith, J . Frank, and A. J/'onsson. Bridging the\ngap between planning and scheduling. Knowledge Engineering Review, 15(1), 2000.\nA. Tate, B. Drabble, and R. Kirby. 0-plan2: An open\narchitecture for command, planning and control. Intelligent Scheduling, 1994.\nD. E. Williins, K. L. Myers, J . D. Lowrance, and L. P.\nWesley. Planning and reacting in uncertain and dynamic environments. Journal of Experimental and\nTheoretical Artificial Ingelligence, 7( 1), 1995.\n\n"