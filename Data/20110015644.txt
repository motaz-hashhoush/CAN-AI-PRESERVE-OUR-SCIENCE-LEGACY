b'Use of Spacecraft Command Language for Advanced\nCommand and Control Applications\nTikiela L. Mims 1\nApplication Simulation & Support Software, Kennedy Space Center, FL, 32899\nThe purpose of this work is to evaluate the use of SCL in building and monitoring command\nand control applications in order to determine its fitness for space operations.\nApproximately 24,325 lines of PCG2 code was converted to SCL yielding a 90% reduction in\nthe number of lines of code as many of the functions and scripts utilized in SCL could be\nported and reused. Automated standalone testing, simulating the actual production\nenvironment, was performed in order to generalize and gauge the relative time it takes for\nSCL to update and write a given display. The use of SCL rules, functions, and scripts\nallowed the creation of several test cases permitting the detection of the amount of time it\ntakes update a given set of measurements given the change in a globally existing CUI or\nCUI. It took the SCL system an average 926.09 ticks to update the entire display of 323\nmeasurements.\n\nNomenclature\nCUI\nPCG2\nSCL\n\n= Constellation Unique Identifier\n= Personal Computer Ground Operations Aerospace Language 2\n= Spacecraft Command Language\n\nI. Introduction\n\nT\n\nhe advancement and transmission of technology has spun a revolution in the average American home. With the\nevolution of time, it has engendered an age in which the widespread possession and use of the device we call the\npersonal computer has become the norm. Clearly, what was once available to a selected few is now utilized by\nmany. Perhaps this helps to explain the recent rise in the production and development of computers and computer\nlanguages.\nThere are in fact several benefits to this increase, one in particular being that companies are able to choose from\na wide array of languages the one they feel best fits their needs, and perhaps this helps to explain why domainspecific languages have seemed to persist over time, languages that give system engineers the opportunity to\nimplement code in the creation of their own systems,. This is mainly due to the fact that many companies seek to\nadopt languages that they feel will not only fit there needs, but have potentials to evolve. Spacecraft Command\nLanguage (SCL) developed by Interface Control Systems, Inc. is a good example of a domain-specific language\nwhich has seemed to fit a company\xe2\x80\x99s needs while being given the opportunity to evolve.\nFor NASA, the expert system has seemed to meet the company\xe2\x80\x99s objective of reducing operational costs while\noffering a reliable medium through which the building and monitoring of command and control applications can be\nautomated readily. To further expound on its use, SCL has been utilized in several missions and programs, including\nthe Clementine mission, and the Far Ultraviolet Spectroscopic Explorer (FUSE) Program, all of which have\ncontributed to the evolution and advancement of the present day SCL system; a system which creates an\nenvironment which is characterized by simplicity, rapidity, and portability.\n\n1\n\nApplication Simulation & Support Software Intern, NE-C1, Kennedy Space Center, and Columbus State\nUniversity\n\n1. spawn DPSPowerStatusCRT with V73S2001E1, V73S2002E1 now\n2. set confirmation_msg to "OFF"\n3. execute RampUp every 60 ticks\nFigure 1.0. SCL Grammar Examples. The first statement gives an example of SCL\xe2\x80\x99s \xe2\x80\x9cspawn\xe2\x80\x9d function,\nwhich in this example, executes the function DPSPowerStatusCRT with the given parameters. The second\nstatement sets the given variable to a string literal \xe2\x80\x9cOFF.\xe2\x80\x9d The third statement an example of SCL execute\nfunction. In this example, the function RampUp is executed every 60 ticks or every second.\n\nII. Simplicity\nIn its capabilities in building and monitoring command and control applications, SCL creates an environment\nwhich is marked by simplicity. This simplicity becomes evident in its basic language and ability to eliminate the\nneed for complex control procedures.\nA. Easy for the Nonprogrammer\nThe SCL grammar is very basic. Ideally, it is this basic language which helps to eliminate the need for skilled\nprogrammers. Definitively, ICS created a language that is in effect human-readable which makes it easier to\nunderstand the logic in any given SCL program. Many of its SCL\xe2\x80\x99s command, for instance, encompass English\nverbs and prepositions, including commands like \xe2\x80\x9cset,\xe2\x80\x9d \xe2\x80\x9cexecute,\xe2\x80\x9d and \xe2\x80\x9cspawn.\xe2\x80\x9d Fig 1.0 gives an example of three\nsimple SCL commands which include the use of English verbs and prepositions.\nIdeally, SCL\xe2\x80\x99s simplistic grammar and language creates an environment where SCL script, rules, and functions\ncan be easily reused and understood in the creation of other applications; moreover, because of its simplistic\napproach, SCL quintessentially reduces the amount of resources and engineers needed to create and develop\napplications.\nB. Minimal Complexity\nIn addition to eradicating the need for skilled programmers, SCL\xe2\x80\x99s streamlined approach also reduces the need\nfor creating complex control procedures. Definitively, the SCL language includes basic, fundamental programming\nconstructs including those like If-Then-Else, repeats loops and case and assignment statements. Additionally, SCL\nsupports only one data structure, the single-dimensional array; nevertheless, it minimizes the need to implement\ncomplex data structures like Linked Lists, Stacks, ArrayLists, and Priority Queues, common in many conventional\nlanguages like Java and C++ in the creation of control algorithms; in fact, control algorithms can be implemented\nthrough the creation of simple scripts, rules, and constraints. A simple SCL rule can be utilized to detect any\ndeviations or failures in a system imitating the process of monitoring. In response to these triggers, the creation of\nsimple SCL scripts can be scheduled to execute given a set of criteria. This minimization of complexity can also be\nseen in the porting of SCL to new environments. According to Interface Control Systems, Inc. (ICS) in order to\ntransport the RTE to a new environment interface routines must be implemented in order to ensure connection to the\nnew environment. This, according to ICS, requires the producing of simple interface routines that are in fact, limited\nin scope. 2 In retrospect, the single data structured language minimizes the need to create complex control algorithms\ncreating a more simplistic development environment.\n\nIII. Rapidity\nApart from creating an environment that exhibits a high level of simplicity, the SCL software system and\nlanguage also yields a high level of rapidity in developing and monitoring command and control applications. At my\n2\n\nwww.interface.control.com\n\ndesktop, I was able to examine SCL\xe2\x80\x99s performance by detecting the amount of time it takes to write and update a\ngiven display application. This application included over 20,000 lines of embedded PCG2 code which needed to be\nconverted to SCL in order to measure the reliability of the SCL system. Fig. 2.0 gives a snapshot of the actual\ndisplay application.\nA. Code Reduction\nThe conversion of the existing PCG2 code to SCL required the creation of several SCL scripts, functions, and\nsubroutines, and the building of an SCL database housing over 1,400 CUI\xe2\x80\x99s, or sensors. Markedly, the conversion\nfrom PCG2 to SCL saw a significant reduction in the number of lines of code. In fact, it only took SCL only 2,443\nlines of code to rewrite the PCG2 application, primarily because SCL permits the use of parameters, functions, and\nsubroutines. To make a more legitimate comparison, it takes Ground Operations Aerospace Language (GOAL), a\nlanguage that also allows the implementation of functions and subroutines, approximately 6,439 lines of code to\nwrite the PCG2 application. Thus, when compared to GOAL, SCL yields a 62% reduction in the number of lines of\ncode. Therefore, SCL creates an environment in which less time is spent in the coding phase of the software\ndevelopment cycle which ultimately speeds the process of development.\n\nFigure 2.0. PCG2 Display Application. This PCG2 display contains over 1,400 CUI\xe2\x80\x99s, all of which contribute\nin defining a particular measurement. Each column of the display contains measurements. For instance, the first\ncolumn labeled \xe2\x80\x9cGPC STAT\xe2\x80\x9d contains 5 measurements. The entire display houses 323 updatable\nmeasurements.\n\nB. High speed outputs\nIn addition to converting over 20,000 lines of PCG2 code to SCL, my job also included measuring SCL\xe2\x80\x99s\nperformance in observing how fast the system performs under a particular workload. After developing a few test\ncase scenarios in the early stages of SCL performance testing, I was able to create of a number of SCL rules and\nscripts which allowed me to simulate an automated testing environment. The implementation of SCL rules allowed\n\nme to detect whether or not there were any changes in a given CUI defined in the SCL database while the execution\nof the command-based SCL scripts allowed me to automate directives to the SCL\xe2\x80\x99s Real-Time-Engine (RTE)\nwhenever there was a change detected in a given CUI in the SCL database.\nMy test cases included the following: estimating the amount of time it would take SCL to update a single\nmeasurement of the display given any CUI, determining how long it would take SCL to update a given set of\nmeasurements of the display given the change in a globally existing CUI, and detecting the amount of time it would\ntake to update the entire display. In operating on a 2.33GHz Intel Processor System with 1.96GB of RAM, the SCL\nsystem was able to conduct relatively fast updates. It took the system on the average of about 2.5 ticks or 41.6\nmilliseconds to update a single measurement, and SCL will yield even faster speeds when the tests are conducted in\nthe actual production environment.\nWhen a globally existing CUI was changed, the average amount of time that SCL took to run 2,194 lines of\ncode to update the display was about 625.45 ticks or 10.42 seconds. Additionally in updating and rewriting the entire\ndisplay application, I found that it takes SCL on the average\nrule Detect_Second_Change\nabout 926.09 ticks or 15.43 seconds to execute the 2,443\nsubsystem none\nlines of SCL code. Fig. 2.1 and Fig, 2.2 illustrate examples\ncategory pwr\nof a compiled SCL rule and script which demonstrates the\npriority 21\nprecept of command and control. For instance, in Fig. 2.1 if\nactivation yes\nthere is any change in the value of SGPCFIDA2 in the SCL\ncontinuous yes\ndatabase, the premise for the rule evaluates to true, and\nSCL\xe2\x80\x99s \xe2\x80\x9cmessage\xe2\x80\x9d command outputs the current beginning\nif change (SGPCFIDA2) then\ntime in ticks; next, the execution of script UpdateTwo and\nexecutes its embedded three functions; afterwards, the\nmsg "The beginning time is " & ticks\nending time is outputted time in ticks, and the difference of\nthe beginning time and the ending time can be utilized\nspawn UpdateTwo now\nestimating the amount of time it takes SCL to execute the\ngiven functions.\nend if\nC. Rapidity Interpretation\nThrough my conversions and tests I was able to measure\nthe capabilities of creating and writing command and\nFigure 2.1. SCL Rule. This rule detects\ncontrol applications. Clearly, when compared to other\nwhether or not the value of the field of the\ncommand and control languages like PCG2 and GOAL,\nthe given CUI, SGPCFIDA2, has been changed.\nSCL is the frontrunner in terms of code reduction.\nIf so, the beginning time is outputted in ticks and\nPerformance testing allowed me to further detect the\nthe script, UpdateTwo, is called and executed.\ncapabilities of SCL as I was able to determine whether or\nnot the SCL software system will be able to meet\nperformance criteria for space and ground operations. Definitively, the use of SCL rules, scripts, and constraints can\nbe utilized to simulate command and control systems as rules can be used to monitor events, scripts to issue\ncommands, and constraints to enforce system constraints. In retrospect, SCL\xe2\x80\x99s rapidity in the creation, development,\nand writing of applications proves that is nevertheless an ideal solution for aerospace operations as this cuts costs\nand time.\nend Detect_Second_Change\n\nscript UpdateTwo\nspawn BFSDataDispMajMode with SGPCAREA2, V98U2408C1 now\nspawn BFSDataDispMajMode with SGPCAREA2, V98J2299C1 now\nspawn BFSDataDispMajMode with SGPCAREA2, V98J2258C1 now\nmsg "Ending time for Update for UpdateTwo is " & ticks\nend UpdateTwo\nFigure 2.2. SCL Script. This illustration gives an example of a simple\nSCL Script which executes the three \xe2\x80\x9cspawn\xe2\x80\x9d directives when the rule in\nFigure 2.1 detects a change in the value of the database mnemonic\nSGPCFIDA2\n\nIV. Portability\nIn addition to producing and providing a high level of rapidity and simplicity, the SCL software system and\nlanguage also produces a high, but safe level of portability \xe2\x80\x93 that is, SCL components can be easily transported\nacross several different environments while being able to adapt readily to those environments.\nA. RTE and Development Environment\nSCL\xe2\x80\x99s Real-Time Engine (RTE) and development environment are designed specifically to be portable to a wide\narray of PC\xe2\x80\x99s and workstations. In fact, these segments are being utilized for both ground and space operations at\nNASA. According to Interface Control Systems, the RTE is the piece of the SCL software that is \xe2\x80\x9cwritten in C to\nallow ease of porting to a specific hardware platform (ground or space).\xe2\x80\x9d\nB. Code Reuse\nIn demonstrating a high level of portability the SCL system also promotes a high level of reuse. For instance,\nseveral SCL programs have been reused across the space, air, and naval industries including the SCL flight software\nof the Advanced System Controller Project which was reused in the building of the flight software for the 1994\nClementine program, and the Far Ultraviolet Spectroscopic Explorer (FUSE) satellite in which its SCL components\nwere reused amongst many of its control systems. Additionally, SCL\xe2\x80\x99s portable and reusable features have been\nutilized for an assortment of aerospace applications including ground equipment software, attitude control\nsubsystems, and satellite simulation. In rewriting the PCG2 display, I was able to reuse many of the scripts and\nfunctions in the creation of others. This essentially reduced the amount of time it took me to finish the project.\nNonetheless, the reusable and portable features of SCL ultimately reduce the amount of development time to\nimplement command and control application while reducing the costs needed for maintenance.\n\nV. Conclusion\nThere is no doubt that SCL can be utilized to build and monitor advanced command and control systems and\napplications. It proves to be a system that is both consistent and steadfast in its ability to automate the detection of\nanomalies in spacecraft data. More specifically, SCL script, subroutines, functions, constraints, and rules, give\nnonprogrammers the opportunity to test their own systems in an autonomous environment characterized by\nsimplicity, rapidity, and portability. Hence, as Brian Buckley states in \xe2\x80\x9cSCL: An Off-The-Shelf System for Space\nControl\xe2\x80\x9d, \xe2\x80\x9cthe flexibility of the architecture and the open systems aspect of the SCL software gives the system broad\nappeal.\xe2\x80\x9d These features ultimately suggest the reliability and feasibility of SCL in the use of advanced command and\ncontrol applications; however, like any other software system, there exists areas for improvement, areas which will\nmanifest only through careful research and further testing. One thing is for sure though, if it continues to evolve and\nreaches it fullest potential the SCL software system could possibly revolutionize exploration in the Constellation\nProgram.\n\nAcknowledgments\nThe author would like to thank everyone on the NE-C1 team who assisted in the SCL learning experience.\n\nReferences\n3\n\nGaasbeck, Van Jim, Posner, Allan, Buckley, Brian, \xe2\x80\x9cDistributed Space-Segment Control Using SCL,\xe2\x80\x9d AAAI Press\nwww.interfacecontrol.com/marketing/pdf/flair.pdf [cited 11 December 2008].\n4\nBuckley, Brian, \xe2\x80\x9cSCL: An Off-The-Shelf System for Space Control\xe2\x80\x9d NASA, Nov. 1994.\n\n'