b'A Module Language for Typing by Contracts\nYann Glouche\xe2\x88\x97\nJean-Pierre Talpin\nPaul Le Guernic\nThierry Gautier\nINRIA, Unit\xc2\xb4 de Recherche Rennes-Bretagne-Atlantique, Campus de Beaulieu, Rennes, France\ne\nAbstract\nAssume-guarantee reasoning is a popular and expressive paradigm for modular and compositional speci\xef\xac\x81cation of programs. It is becoming a fundamental concept in some computer-aided\ndesign tools for embedded system design. In this paper, we elaborate foundations for contract-based\nembedded system design by proposing a general-purpose module language based on a Boolean algebra allowing to de\xef\xac\x81ne contracts. In this framework, contracts are used to negociate the correctness\nof assumptions made on the de\xef\xac\x81nition of a component at the point where it is used and provides\nguarantees to its environment. We illustrate this presentation with the speci\xef\xac\x81cation of a simpli\xef\xac\x81ed\n4-stroke engine model.\n\n1\n\nIntroduction\n\nMethodological common sense for the design of large embedded architectures advises the validation of\nspeci\xef\xac\x81cations as early as possible, and further advocates for an iterative validation of each re\xef\xac\x81nement or\nmodi\xef\xac\x81cation made to any component of the initial speci\xef\xac\x81cation, until the implementation of the system\nis \xef\xac\x81nalized. As an example, in a cooperative industrial environment, designers often use and assemble\ncomponents which have been developed by different suppliers. These components have to be provided\nwith conditions of use and need to offer pre-validated guarantees on their function or service. The conditions of use and the service guarantee de\xef\xac\x81ne a notion of contract. Design by contract, as advocated\nin [23], is now a common programming concept used in general-purpose languages such as C++ or\nJava. Assertion-based contracts express program invariants, pre and post conditions, as Boolean type\nexpressions that have to be true for the contract being validated. We adopt the paradigm of contract to\nde\xef\xac\x81ne a component-based validation process in the context of an embedded software modeling framework. It consists of an algebraic framework, based on two simple concepts, enabling logical reasoning\non contracts [11]. First, the assumptions and guarantees of a component are de\xef\xac\x81ned as devices called\n\xef\xac\x81lters: assumptions \xef\xac\x81lter the behaviors a component accepts and guarantees \xef\xac\x81lter the behaviors a component provides. Filters form a Boolean algebra and contracts de\xef\xac\x81ne a Heyting algebra. This yields a\nrich framework to abstract, re\xef\xac\x81ne, combine and normalize contracts. In this paper, we put this algebra to\nwork for the de\xef\xac\x81nition of a general purpose module system whose typing paradigm is based on the notion\nof contract. The type of a module is a contract holding assumptions made and guarantees offered by its\nbehaviors. It allows to associate a module with an interface which can be used in varieties of scenarios\nsuch as checking the composability of modules or ef\xef\xac\x81ciently supporting modular compilation.\nPlan We start with a highlight on some key features of our module system by considering the speci\xef\xac\x81cation of a simpli\xef\xac\x81ed engine controler, Section 2. This example is used through the article to illustrate\nour approach. We give a short outline of our contract algebra, Section 3, and demonstrate its capabilities\nfor logical and compositional reasoning on the assumptions and guarantees of component-based embedded systems. Our main contribution, section 4, is to use this algebra as a foundation for the de\xef\xac\x81nition\nof a strongly-typed module system: contracts are used to type components with behavioral properties.\nSection 5 demonstrates the use of our module system by considering the introductory example and by\nillustrating the re\xef\xac\x81nement mechanism of the language. We review related works, Section 6, before concluding, Section 7.\n\xe2\x88\x97 Partially\n\nfunded by the EADS Foundation.\n\xcb\x98 \xcb\x98\nE. Denney, D. Giannakopoulou, C.S. Pasareanu (eds.); The First NASA Formal Methods Symposium, pp. 86-95\n\n86\n\nA module language for typing by contracts\n\n2\n\nGlouche, Talpin, Guernic, Gautier\n\nAn example\n\nWe illustrate our approach by considering a simpli\xef\xac\x81ed automotive application presented in [4]. We\nde\xef\xac\x81ne contracts to characterize properties of a four-stroke engine controller. In this speci\xef\xac\x81cation, the\ncyclic behavior of the engine is rendered by four successive phases: Intake, Combustion, Compression,\nand Exhaust. These phases are driven by a camshaft whose angle is measured in degrees. This unit of\nmeasure de\xef\xac\x81nes a discrete and symbolic time sampling in the system. The angle of the camshaft marks\nan occurrence of a clock tick (the\ncam) at which sensors are sampled\nand a reaction is triggered. For example, at 90\xe2\x97\xa6 , the intake valve is closed\nand a transition to compressin mode\nis triggered.\nIn the module language, a speci\xef\xac\x81cation is designated by the keyword contract. It de\xef\xac\x81nes a set of input and output variables subject to a contract. The interface de\xef\xac\x81nes the way the environment and the\ncomponent interact through its variables. In addition, it embeds properties that are modeled by the composition of contracts. For instance, the speci\xef\xac\x81cation of the intake mode of the engine controller could be\nde\xef\xac\x81ned by the assumption 0 <= (cam mod 360)< 90 and the guarantee intake. An implementation of\nthe interface, designated by the keyword process, contains a compatible implementation of the contract\nassigning true to the signal intake when 0 <= (cam mod 360)< 90.\nmodule type IntakeType =\ncontract\ninput integer cam;\noutput event intake;\nassume 0 <= (cam mod 360)< 90\nguarantee intake\nend;\n\nModule IntakeMode : IntakeType =\nprocess\ninput integer cam;\noutput event intake;\nintake := true when cam mod 360<90\nend;\n\nThe speci\xef\xac\x81cation of the properties we consider for the engine consists of four contracts. Each contract\nspeci\xef\xac\x81es a phase of the engine. It is associated to a position of the camshaft and triggers an event.\nInstead of specifying four separate contracts, we de\xef\xac\x81ne them as four instances of a generic contract.\nTo this end, we de\xef\xac\x81ne an encapsulation mechanism to generically represent a class of interfaces or\nimplementations sharing a common pattern of behavior up to that of the parameter. In the example of\nthe engine, for instance, we have used a functor to parameterize it with respect to its angle position.\nmodule type phase =\nmodule type engine = contract\nfunctor (integer min, integer max)\ninput integer cam ; output event intake,\ncontract\ncompression, combustion, exhaust;\ninput integer cam ;\nphase (0, 90) (cam, intake)\noutput event trigger;\nand phase (90, 180) (cam, compression)\nassume min <= (cam mod 360) < max and phase (180, 270) (cam, combustion)\nguarantee trigger\nand phase (270, 360) (cam, exhaust)\nend;\nend;\nThe generic contract, called phase, is parameterized with a trigger and with camshaft angle bounds.\n\nWhen the camshaft is within the speci\xef\xac\x81ed angles, the engine controller activates the speci\xef\xac\x81ed trigger.\nThe contract of the engine is de\xef\xac\x81ned by the composition \xe2\x80\x9cand\xe2\x80\x9d of four applications of the generic phase\ncontract. Each application de\xef\xac\x81nes a particular phase of the engine with its appropriate triggers and\nangles. The composition de\xef\xac\x81nes the greatest lower-bound of all four contracts. Each application of the\nphase functor produces a contract which is composed with the other ones in order to produce the expected\ncontract. A component is hence viewed as a pair M : I consisting of an implementation M that is typed\nby (or viewed as) an interface I of satis\xef\xac\x81able contract. The semantics of the speci\xef\xac\x81cation I, written [[I]],\nis a set of processes (in the sense of section 3) whose traces satisfy the contracts associated with I. The\nsemantics [[M]] of the module M is the singleton containing the process [[IntakeMode]].\n87\n\nA module language for typing by contracts\n\n3\n\nGlouche, Talpin, Guernic, Gautier\n\nAn algebra of contracts\n\nA contract is viewed as a pair of logical devices that \xef\xac\x81lter processes: the assumption A \xef\xac\x81lters processes to\nselect (accept or conversely reject) those of which that are to be asserted (accepted or conversely rejected)\nby the guarantee G. A process p ful\xef\xac\x81ls (A,G) requirements (satis\xef\xac\x81es (A,G)) if either it is rejected by A (it\nis then out of the scope of (A,G) contract), or it is accepted by A and by G. We have chosen to represent a\n\xef\xac\x81ltering device (such as A or G) by a process-\xef\xac\x81lter which is the set of processes that it \xe2\x80\x9caccepts\xe2\x80\x9d (i.e., that\nit contains). We give more details of the algebra of contracts, including examples, additional properties\nand formal proofs in a technical report [11]. In the remainder, we only de\xef\xac\x81ne the mathematical objects\nthat are relevant to the presentation of our module system. They consist of two relations in the contract\nalgebra, noted for re\xef\xac\x81nement and \xe2\x87\x93 for composition. In fact, our module system can be seen as a\ndomain-speci\xef\xac\x81c language that syntactically re\xef\xac\x82ects the structure of our contract algebra.\nFor X a nonempty \xef\xac\x81nite set of variables, a behavior is a function b : X \xe2\x86\x92 D where D is a set of\nvalues (that may be traces), and a process p is a nonempty set of behaviors de\xef\xac\x81ned on X. We denote\nby \xe2\x84\xa6 = {0} the unique process de\xef\xac\x81ned on the empty set of variables: it has a single behavior that is\n/\nthe empty behavior. The set of processes is noted P; it is extented to P by adding the empty \xe2\x80\x9cprocess\xe2\x80\x9d\nnoted = 0. A process-\xef\xac\x81lter R is the set of processes that satisfy a given property on a set of variables\n/\nX; notice that if a process p is in R so are all processes de\xef\xac\x81ned on supersets of X, whose sub-behaviors\nrestricted to X are behaviors in p; moreover if a process p is in R, so are all nonempty subsets of p. By\nconvention, { } is a process-\xef\xac\x81lter. We de\xef\xac\x81ne an order relation on the set of process-\xef\xac\x81lters \xce\xa6 extended\nby { } and establish that (\xce\xa6, ) is a lattice. Also, (\xce\xa6, ) is a Boolean algebra with P as 1, { } as\n0. The complementary of R is noted R. The conjunction R S of two process-\xef\xac\x81lters R and S is the\ngreatest process-\xef\xac\x81lter T = R S that accepts all processes whose behaviors are at once behaviors in\nsome process accepted by R and behaviors in some process accepted by S. The process-\xef\xac\x81lter disjunction\nR S of two process-\xef\xac\x81lters R and S is the smallest process-\xef\xac\x81lter T = R S that accepts all processes\nwhose behaviors are at once behaviors in some process accepted by R or behaviors in some process\naccepted by S. A contract C = (A,G) is a pair of process-\xef\xac\x81lters and C = \xce\xa6\xc3\x97\xce\xa6 is the set of contracts.\nThe re\xef\xac\x81nement relation ( ) is a partial order on contracts. (C, ) is a distributive lattice of supremum\n({ },P ) and in\xef\xac\x81mum (P ,{ }): it is a Heyting algebra. We de\xef\xac\x81ne the nominal contract p of a process\np as the contract that assumes any behavior and guarantees all the possible behaviors of p. Two contracts\nC1 and C2 have a greatest lower bound C1 \xe2\x87\x93 C2 and a least upper bound C1 \xe2\x87\x91 C2 . The greatest lower\nbound C = (A,G) of two contracts C1 = (A1 ,G1 ) and C2 = (A2 ,G2 ) is de\xef\xac\x81ned by: A = A1 A2 and\nG = ((A1 A2 G1 ) (A1 A2 G2 ) (G1 G2 )).\n\n4\n\nA module language for typing by contracts\n\nIn this section, we de\xef\xac\x81ne a module language to implement our contract algebra and apply it to the\nvalidation of component-based systems. For the peculiarity of our applications, it is instantiated to\nthe context of the synchronous language Signal, yet could equally be used in the context of related\nprogramming languages manipulating processes or agents. Its basic principle is to separate the interface,\nwhich declares properties of a program using contracts, and implementation, which de\xef\xac\x81nes an executable\nspeci\xef\xac\x81cation satisfying it.\n\n4.1\n\nSyntax\n\nWe de\xef\xac\x81ne the formal syntax of our module language. Its grammar is parameterized by the syntax of\nprograms, noted p or q, which belong to the target speci\xef\xac\x81cation or programming language. Names\nare noted x or y. Types t are used to declare parameters and variables in the interface of contracts.\n88\n\nA module language for typing by contracts\n\nGlouche, Talpin, Guernic, Gautier\n\nAssumptions and guarantees are described by expressions p and q of the target language. An expression\nexp manipulates contracts and modules to parameterize, apply, reference and compose them.\nx, y\np, q\nb, c ::= event | boolean | short | integer | . . .\nt ::= b | input b | output b | x | t \xc3\x97 t\ndec ::= t x [, dec]\nde f ::= module [type] x = exp\n| module x [: t] = exp\n| de f ; de f\n\n4.2\n\nname\nprocess\ndatatype\ntype\ndeclaration\nde\xef\xac\x81nition\n\nag ::= [assume p] guarantee q;\n| ag and ag | x(y\xe2\x88\x97 )\nexp ::= contract dec; ag end\n| process dec; p end\n| functor (dec) exp\n| exp and exp\n| x (exp\xe2\x88\x97 )\n| let de f in exp\n\ncontract\nprocess\ncontract\nprocess\nfunctor\ncomposition\napplication\nscoping\n\nA type system for contracts and processes\n\nWe de\xef\xac\x81ne a type system for contracts and processes in the module language. In the syntax of the module\nlanguage, contracts and processes are associated with names x . These names can be used to type formal\nparameters in a functor and become type declarations. Hence, in the type system, type names that stand\nfor a contract or a process are associated with a module type T . A base module type is a tagged pair\n\xcf\x84(I,C). The tag \xcf\x84 is \xcf\x80 for the type of a process and \xce\xb3 for the type of a contract. The set I consists of pairs\nx : t that declare the types t for its input and output variables x. The contract C is a pair of predicates\n(p, q) that represent its assumptions p and guarantees q. The type of a functor \xce\x9b(x : S).T consists of the\nname x and of the types S and T of its formal parameter and result. The role of the typing hypothesis \xce\x93\nis to hold an association x : T of names to types (we write \xce\x93(x) the type of name x in \xce\x93). The role of the\ntyping constraints \xce\xa3 is to register inferred re\xef\xac\x81nement relations of the form C D.\nS, T ::= t | \xcf\x84(I,C) | S\xc3\x97T | \xce\x9b(x : S).T (type) \xcf\x84 ::= \xce\xb3 | \xcf\x80 (kind) \xce\x93 ::= 0 |\xce\x93\xe2\x88\xaax : T\n/\n\n4.3\n\n\xce\xa3 ::= 0 |\xce\xa3\xe2\x88\xaaC\n/\n\nD (context)\n\nContract re\xef\xac\x81nement\n\nWe wish to de\xef\xac\x81ne a subtyping relation on types t to extend the re\xef\xac\x81nement relation of the contract algebra\nto the type algebra. In that aim, we wish to apply the subtyping principle S \xe2\x89\xa4 T to mean that the semantic\nobjects denoted by S are contained in the semantic objects denoted by T (S re\xef\xac\x81nes T ). Hence, a module\nof type T can safely be replaced or substituted by a module of type S. For example, consider a process P\nwith one long input x and two short outputs a, b, and a process Q with two integer inputs x, y and one\ninteger output, such that P re\xef\xac\x81nes\nQ.Then the type of a module M enx:long\xe2\x86\x92\n\xe2\x86\x92a:short\nx:integer \xe2\x86\x92\n\xe2\x86\x92a:integer\ncapuslating P is a subtype of a modP\nQ\n\xe2\x89\xa4\n\xe2\x86\x92b:short\ny:integer \xe2\x86\x92\nule N encapsulating Q. M can replace N.\n\n4.4\n\nSubtyping as re\xef\xac\x81nement\n\nAccordingly, we say that s is a subtype of t under the hypothesis \xce\xa3, written \xce\xa3 \xe2\x8a\x83 s \xe2\x89\xa4 t iff \xce\xa3 contains (or\nimplies) the relation s \xe2\x89\xa4 t. The inductive de\xef\xac\x81nition of the subtyping relation \xe2\x89\xa4 starts with the subtyping\naxioms for datatypes. Then, it is elaborated with algebraic rules, the rules for declarations and, \xef\xac\x81nally,\none rule for each kind of module type. In particular, a module type S = \xcf\x84(I,C) is a subtype of T = \xcf\x84(J, D),\nwritten \xce\xa3 \xe2\x8a\x83 S \xe2\x89\xa4 T , iff the inputs in J subtype those in I, if the outputs in I subtype those in J, and if the\ncontract C re\xef\xac\x81nes D. In the rule for functors, we write V [y/x] for substituting the name x by y in V (we\nassume that y does not occur in V ).\n89\n\nA module language for typing by contracts\n\nT \xe2\x89\xa4T\n\nevent \xe2\x89\xa4 boolean\n\n\xce\xa3\xe2\x8a\x83b\xe2\x89\xa4c\n\xce\xa3 \xe2\x8a\x83 input c \xe2\x89\xa4 input b\n\nGlouche, Talpin, Guernic, Gautier\n\xce\xa3 \xe2\x8a\x83 I \xe2\x89\xa4 J x \xe2\x88\x88 vars(I)\n\xce\xa3 \xe2\x8a\x83 I \xe2\x89\xa4 (x : input b) \xe2\x88\xaa J\n\nshort \xe2\x89\xa4 integer \xe2\x89\xa4 long\n\n\xce\xa3\xe2\x8a\x83b\xe2\x89\xa4c\n\xce\xa3 \xe2\x8a\x83 output b \xe2\x89\xa4 output c\n\n\xce\xa3\xe2\x8a\x83S \xe2\x89\xa4T \xce\xa3\xe2\x8a\x83T \xe2\x89\xa4U\n\xce\xa3\xe2\x8a\x83S \xe2\x89\xa4U\n\n\xcf\x84 \xe2\x89\xa4\xce\xb3\n\xcf\x80 \xe2\x89\xa4\xcf\x84\n\n\xce\xa3\xe2\x8a\x83I\xe2\x89\xa4J \xce\xa3\xe2\x8a\x83S\xe2\x89\xa4T\n\xce\xa3 \xe2\x8a\x83 (x : S) \xe2\x88\xaa I \xe2\x89\xa4 (x : T ) \xe2\x88\xaa J\n\n\xce\xa3 \xe2\x8a\x83 I \xe2\x89\xa4 J x \xe2\x88\x88 vars(J)\n\xce\xa3 \xe2\x8a\x83 (x : output b) \xe2\x88\xaa I \xe2\x89\xa4 J\n\n\xce\xa3 \xe2\x8a\x83 I \xe2\x89\xa4 J (C D) \xe2\x88\x88 \xce\xa3 \xcf\x84 \xe2\x89\xa4 \xcf\x84\n\xce\xa3 \xe2\x8a\x83 \xcf\x84(I,C) \xe2\x89\xa4 \xcf\x84 (J, D)\n\n\xce\xa3\xe2\x8a\x83S \xe2\x89\xa4U T \xe2\x89\xa4V\n\xce\xa3 \xe2\x8a\x83 S \xc3\x97 T \xe2\x89\xa4 U \xc3\x97V\n\n\xce\xa3 \xe2\x8a\x83 U \xe2\x89\xa4 S \xce\xa3 \xe2\x8a\x83 T \xe2\x89\xa4 V [x/y]\n\xce\xa3 \xe2\x8a\x83 \xce\x9b(x : S).T \xe2\x89\xa4 \xce\x9b(y : U).V\n\nAlternatively, we can interpret the relation \xce\xa3 \xe2\x8a\x83 C D as a mean to register the re\xef\xac\x81nement constraint\nbetween C and D in \xce\xa3. It corresponds to a proof obligation in the target language whose meaning is\nde\xef\xac\x81ned by the semantic relation [[C]] [[D]] in the contract algebra, and whose validity may for instance\nbe proved by model checking. The set \xce\xa3 of re\xef\xac\x81nement relations C D is obtained by the structural\ndecomposition of subtyping relations of the form s \xe2\x89\xa4 t into either elementary axioms, e.g. event \xe2\x89\xa4\nboolean, or proof obligations C D.\n\n4.5 Greatest-lower and lowest-upper bounds\nJust as the subtyping relation, which implements and extends the re\xef\xac\x81nement relation of the contract\nalgebra in the typing algebra, the operations that de\xef\xac\x81ne the greatest lower bound and least upper bound\nof two contracts are extended to module type by induction on the structure of types. The intersection and\nunion operators are extended to combine the set of input and output declarations of a module. The side\ncondition (\xe2\x88\x97) is that x \xe2\x88\x88 dom(J).\n(I \xe2\x88\xaa (x : S)) (J \xe2\x88\xaa (x : T ))=(I\n\xcf\x84(I,C) \xcf\x84(J, D)=\xcf\x84(I J,C \xe2\x87\x93 D)\n(I \xe2\x88\xaa (x : S)) (J \xe2\x88\xaa (x : T ))=(I\nS \xc3\x97 T U \xc3\x97V =(S U) \xc3\x97 (T V )\n(I \xe2\x88\xaa (x : input b)) J=(I\n\xce\x9b(x : S).T \xce\x9b(y : U).V =\xce\x9b(x : (S U)).(T V [y/x])\n\xcf\x84(I,C) \xcf\x84(J, D)=\xcf\x84(I J,C \xe2\x87\x91 D)\n(I \xe2\x88\xaa (x : output b)) J=(I\nS \xc3\x97 T U \xc3\x97V =(S U) \xc3\x97 (T V )\n(I \xe2\x88\xaa (x : input b)) J=(I\n\xce\x9b(x : S).T \xce\x9b(y : U).V =\xce\x9b(x : (S U)).(T V [y/x])\n(I \xe2\x88\xaa (x : output b)) J=(I\n\n4.6\n\nJ) \xe2\x88\xaa (x : S T )\nJ) \xe2\x88\xaa (x : S T )\nJ)(\xe2\x88\x97) 0 J = 0\n/\n/\nJ) \xe2\x88\xaa (x : output b)(\xe2\x88\x97)\nJ) \xe2\x88\xaa (x : input b)(\xe2\x88\x97)\nJ)(\xe2\x88\x97) 0 J = J\n/\n\nType inference in the module language\n\nOur aim is to check the correctness of program construction. Hence, type inference shall produce a\nconsistent type assignment to contract and process names in the module language and generate a proof\nobligation in the form of an observer function [12] (used for describing some properties) in the target\nprogramming language. The type inference system is de\xef\xac\x81ned by the sequent \xce\x93/\xce\xa3 exp where \xce\x93 is the\ntyping environment, \xce\xa3 the typing constraints and exp is an expression of the module language. It embeds\nthe type system of the target language: we assume that the relation \xce\x93 p tells that p is well-typed in\nthe target language under the hypothesis \xce\x93. The sequent establishes a structural correspondence between\nexpressions and types. It is de\xef\xac\x81ned by induction on the structure of expressions in a similar manner as\nthat proposed for Standard ML in [17]. The operator \xcf\x84 \xc2\xb7 T promotes the type T to the kind \xcf\x84. It is de\xef\xac\x81ned\nby \xcf\x84 \xc2\xb7 (\xcf\x84 (I,C)) = \xcf\x84 \xc2\xb7 (I,C) and by \xcf\x84 \xc2\xb7 (\xce\x9b(x : S).T ) = \xce\x9b(x : S).(\xcf\x84 \xc2\xb7 T ). It is used to check that the de\xef\xac\x81nition\nof a module type is a contract and to promote the type of a module.\n\xce\x93/\xce\xa3 s : S \xce\x93/\xce\xa3 t : T\n\xce\x93/\xce\xa3 s \xc3\x97 t : S \xc3\x97 T\n\n\xce\x93/\xce\xa3 s : S \xce\x93/\xce\xa3 t : T\n\xce\x93/\xce\xa3 \xce\x9b(x : s).t : \xce\x9b(x : S).T\n\n\xce\x93/\xce\xa3 t : T\n\xce\x93/\xce\xa3 dec : I \xce\x93/\xce\xa3 dec : J\n\xce\x93/\xce\xa3 t x : (x : T )\n\xce\x93/\xce\xa3 dec, dec : I \xe2\x88\xaa J\n\n\xce\x93/\xce\xa3 ag : C \xce\x93/\xce\xa3 ag : D \xce\x93/\xce\xa3 x : \xce\xb3(x1 : T1 ..xn : Tn ,C) (\xce\x93(yi ) \xe2\x89\xa4 Ti )n\n\xce\x93/\xce\xa3 p \xce\x93/\xce\xa3 q\ni=1\n\xce\x93/\xce\xa3 assume p guarantee q : (p, q)\n\xce\x93/\xce\xa3 ag and ag : C \xe2\x87\x93 D\n\xce\x93/\xce\xa3 x(y1..n ) : C[yi /xi ]n\ni=1\n\xce\x93/\xce\xa3 dec : I \xce\x93 \xe2\x88\xaa I ag : C\n\xce\x93/\xce\xa3 dec : I \xce\x93 \xe2\x88\xaa I p\n\xce\x93/\xce\xa3 exp : S \xce\x93/\xce\xa3 exp : T\n\xce\x93/\xce\xa3 contract dec; ag end : \xce\xb3(I,C) \xce\x93/\xce\xa3 process dec; p end : \xcf\x80(I, ((), p)) \xce\x93/\xce\xa3 (exp and exp ) : S T\n\xce\x93(x) = T\n\xce\x93/\xce\xa3 x : T\n\xce\x93/\xce\xa3\n\n\xce\x93/\xce\xa3 dec : I \xce\x93 \xe2\x88\xaa I/\xce\xa3 exp : T\n\xce\x93/\xce\xa3 functor (dec) exp end : \xce\x9bI.T\n\n\xce\x93/\xce\xa3\n\nx : \xce\x9b(z : S).T \xce\x93/\xce\xa3 y : U \xce\xa3 \xe2\x8a\x82 U \xe2\x89\xa4 S\n\xce\x93/\xce\xa3 x(y) : T [y/z]\n\n\xce\x93/\xce\xa3 exp : T \xce\xb3 \xc2\xb7 T \xe2\x89\xa4 T\n\xce\x93/\xce\xa3 exp : S \xce\x93/\xce\xa3 t : T \xce\xa3 \xe2\x8a\x82 S \xe2\x89\xa4 T\nmodule type x = exp : (x : T ) \xce\x93/\xce\xa3 module x : t = exp : (x : \xcf\x80 \xc2\xb7 T )\n\n90\n\n\xce\x93/\xce\xa3\n\nde f : I \xce\x93 \xe2\x88\xaa I/\xce\xa3 exp : T\n\xce\x93/\xce\xa3 let de f in exp : T\n\nA module language for typing by contracts\n\n4.7\n\nGlouche, Talpin, Guernic, Gautier\n\nCorrectness\n\nThe correctness of our module system is stated by showing that a program is well-typed if the constraints\nimplied by \xce\x93/\xce\xa3 are consistent. We say that the environment \xcf\x81 is well-typed with \xce\x93/\xce\xa3, written \xcf\x81 : \xce\x93/\xce\xa3,\niff all de\xef\xac\x81nitions in \xcf\x81 are well-typed with \xce\x93 under the constraints \xce\xa3. Notice that, in this implementation\nof the type system, the generated constraints \xce\xa3 de\xef\xac\x81ne the proof obligations that are needed for checking\nthat the speci\xef\xac\x81cation exp is well-typed. To establish this theorem we de\xef\xac\x81ne the semantics [[exp]]\xcf\x81 of a\nterm exp in the module system by induction on the structure of exp. It is a set of processes p of the model\nof computation that satisfy their speci\xef\xac\x81cations.\nexp : T then [[exp]]\xcf\x81 \xe2\x8a\x86 [[T ]]\xcf\x81 .\n\nTheorem 1. If \xcf\x81 : \xce\x93/\xce\xa3 for a satis\xef\xac\x81able \xce\xa3 and \xce\x93/\xce\xa3\n\nProof sketch The proof of Theorem 1 is by induction on the structure of expressions exp (just as for a\nregular type system). For each syntactic category in the grammar of exp, it considers a satis\xef\xac\x81able set of\nconstraints \xce\xa3, a well-typed environment \xcf\x81 : \xce\x93/\xce\xa3 and assumes a proof tree for \xce\x93/\xce\xa3 exp : T . Induction\nhypotheses are made to assert that the sub-expressions expi\xe2\x88\x881..n of exp satisfy the expected sub-goals\n[[expi ]]\xcf\x81 \xe2\x8a\x86 [[Ti ]]\xcf\x81 in order to deduce that [[exp]]\xcf\x81 \xe2\x8a\x86 [[T ]]\xcf\x81 by de\xef\xac\x81nition of the denotational semantics.\n\n5\n\nDiscussion\n\nWe illustrate the distinctive features of our contract algebra by reconsidering the speci\xef\xac\x81cation of the\nfour-stroke engine and its translation into observers in the target language of our choice: the multiclocked synchronous (or polychronous) data-\xef\xac\x82ow language Signal [7]. The separation of environmental\nassumptions and system guarantees is facilitated by the (unpaired) possibility to naturally express the\ncomplementary of a process-\xef\xac\x81lter. Had we used automata to model AIntake , as in most of the related work,\nit would probably have been more dif\xef\xac\x81cult to model the engine not being in the intake mode: this would\nhave required the de\xef\xac\x81nition of the complementary of an automaton and, most importantly, this could\nnot have been done compositionaly. In our algebra, the complementary of the intake property is simply\nde\xef\xac\x81ned by AIntake = cam modulo 360\xe2\x97\xa6 \xe2\x89\xa5 90. In general, the generic structure of observers speci\xef\xac\x81ed in\ncontracts will \xef\xac\x81nd a direct instance and compositional translation into the synchronous multi-clocked\nmodel of computation of Signal [16]. Indeed, a subtlety of the Signal language is that an observer not\nonly talks about the value, true or false, of a signal, but also about its status, present or absent. Thanks to\nits encoding in three-valuated logic, an event (e.g. intake is present and true) can directly be associated\nwith its complementary (e.g. intake is absent or false) without separating the status (the clock) and the\nvalue (the stream). Hence, the signal Aintake is present and true iff cam signal is present and its value is\nbetween 0 and 89 degrees.\nAintake = true when (0 \xe2\x89\xa4 cam modulo 360 < 90)\nGintake = (true when intake) de f ault f alse\nThe complementary of these assumptions is simply de\xef\xac\x81ned to be true iff the cam is absent or out of\nbounds: AIntake = ( f alse when Aintake ) de f ault true. Notice that, for a trace of the assumptions Aintake ,\nthe set of possible traces corresponding to AIntake is in\xef\xac\x81nite (and dense) since it is not de\xef\xac\x81ned on the\nsame clock as Aintake .\nAIntake = 1 0 1 0 1 0 1 0 1 and AIntake = 0\n0\n0\n0\n0 or 0 1 1 1 0 1 1 0 1 1 0 1 0 1 . . .\nIt is also worth noticing that the clock of AIntake (its reference in time) need not be explicitly related to or\nordered with AIntake or GIntake : it implicitly and partially relates to the cam clock. Had we used a stricly\nsynchronous model of computation, as in [18], it would have been necessary to know the clock of the\nsystem in order to de\xef\xac\x81ne that of the complementary by a sample of it. Beside its Boolean structure, which\nallows for logical reasoning and normalization of contracts, our algebra supports the capability to compositionally re\xef\xac\x81ne contracts. For instance, consider a more precise model of the 4-stroke engine found\n91\n\nA module language for typing by contracts\n\nGlouche, Talpin, Guernic, Gautier\n\nin [4]. To additionally require the engine to reach the EC state (Exhaust closes) between 5 and 20 degrees,\nwhile in the intake mode, one will simply compose the initial contract with an additional constraint with\n: AEC = true when (5 <= cam modulo 360 < 21) and GEC = true when EC de f ault f alse. Similarly,\nevent OTDC (Overlap Top Dead Center) occurs at the beginning of the cycle. The instant tOT DC is a\ntime observation of this event and the occurrence of the event EC is constrained by {tOT DC + [5..20]},\nhence tOT DC + 5 \xe2\x89\xa4 tEC \xe2\x89\xa4 tOT DC + 20. We shall re\xef\xac\x81ne the speci\xef\xac\x81cation of the engine to incorporate these\nadditional constraints. This is done as follows:\nmodule type better_engine = engine\nand contract\ninput integer CAM ;\noutput event EC, IC, EO, IO;\nphase(5,20)(CAM,EC)\nand phase(130,150)(CAM,IC)\nand phase(210,225)(CAM,EO)\nand phase(344,350)(CAM,IO)\nend;\n\nIt is needless to say that a sophisticated solver, based for instance on Pressburger arithmetics, shall help\nus to verify the consistency of the above engine map. Nonetheless, an implementation of the above engine speci\xef\xac\x81cation, for the purpose of simulation, can straightforwardly be derived. As a by-product, it\nde\xef\xac\x81nes an observer which may be used as a proof obligation against an effective implementation of the\nengine controller to verify that it implements the expected engine map. Alternatively, it may be used as a\nmedium to synthesize a controller enforcing the satisfaction of the speci\xef\xac\x81ed property on the implementation of the model. In Signal, process phase consists of one equation that is executed when its output\ntrigger is needed (its clock is active). If the signal cam is present and within the speci\xef\xac\x81ed bounds\nmin-max, then trigger is present. Otherwise, cam is absent or simply out of bounds, the trigger is\nabsent. The signals cam and trigger are respectively the input and output of the process whereas the\nnames min-max are functor parameters of the process.\nprocess phase = {integer min, max;} (? integer cam; ! event trigger;)\n(| trigger := when min<=(cam mod 360)<max |);\n\nIn the process engine, four instances of the phase equation are de\xef\xac\x81ned to specify the output signals\nthat are relevant to a speci\xef\xac\x81c phase of the engine. Notice that these signals are not, a priori, synchronized one with the other: they are concurrent. This is done to favor a compositional speci\xef\xac\x81cation of\nthe system. Re\xef\xac\x81nement precisely allows to iteratively build a sequentially executable speci\xef\xac\x81cation by,\ne.g., synchronizing the signals OTD, FBD, ITD and SBD. This choice in favor of compositional modeling (polychrony) versus executability (synchrony) allows us to handle the additional speci\xef\xac\x81cation of the\nbetter engine in a compositional manner, showing that the Signal language and our module system share\nthe same concurrent/compositional design philosophy.\nprocess engine =\n(? integer CAM;\n(| OTD := phase\n| FBD := phase\n| ITD := phase\n| SBD := phase\n|);\n\n! event OTD, FBD, ...\n{ 0, 90} (CAM)\n{ 90, 180} (CAM)\n{180, 270} (CAM)\n{270, 360} (CAM)\n\nprocess betterengine =\n(? boolean CAM ! event OTDC, FBDC, ITDC, ...\n(| (OTDC, FBDC, ITDC, SBDC) := engine (CAM)\n| EC := phase { 5, 20} (CAM)\n| IC := phase {130, 150} (CAM)\n| EO := phase {210, 225} (CAM)\n| IO := phase {344, 350} (CAM) |);\n\nContracts can be used to express exclusion properties. For instance, when the engine is in the intake\nmode, one should not start compression. We have Aexcl =OT DC and Gexcl =\xc2\xacFBDC.\nmodule type exclude = contract output event intake, compression;\nassume intake guarantee (not compression default intake)\nend;\n\nIn addition to the above safety properties, contracts can also be used to express liveness properties. For\n\n92\n\nA module language for typing by contracts\n\nGlouche, Talpin, Guernic, Gautier\n\ninstance, consider the protocol for starting the engine. A battery is used to initiate its rotation. When\nthe engine has successfully started, the battery can be turned off. We de\xef\xac\x81ne a contract to guarantee that\nwhen the ignit button is pushed, the starter eventually stops.\nmodule type StarterOff = contract input event ignit; output boolean starter;\nassume ignit guarantee eventually not starter\nend;\n\n6\n\nImplementation\n\nThe module system described in this paper, embedding data-\xef\xac\x82ow equations de\xef\xac\x81ned in syntax, has been\nimplemented in Java. It produces a proof tree that consists of 1/ an elaborated Signal program, that\nhierarchically renders the structure of the system described in the original module expressions, 2/ a static\ntype assignment, that is sound and complete with respect to the module type inference system, 3/ a proof\nobligation consisting of re\xef\xac\x81nement constraints, that are compiled as an observer or a temporal property\nin Signal.\nThe property is then tended to S IGNAL\xe2\x80\x99s model-checker, Sigali [20], which allows to prove or disprove that it is satis\xef\xac\x81ed by the generated program. Satisfaction implies that the type assignment and\nproduced S IGNAL program are correct with the initially intended speci\xef\xac\x81cation. The generated property\nmay however be used for other purposes. One is to use the controller synthesis services of Sigali [19] to\nautomatically generate a S IGNAL program that enforces the property on the generated program. Another,\nin the case of in\xef\xac\x81nite state system (e.g. on numbers) would be to generate defensive simulation code in\norder to produce a trace if the property is violated.\n\n7\n\nRelated work\n\nThe use of contracts has been advocated for a long time in computer science [21, 13] and, more recently,\nhas been successfully applied in object-oriented software engineering [22]. In object-oriented programming, the basic idea of design-by-contract is to consider the services provided by a class as a contract\nbetween the class and its caller. The contract is composed of two parts: requirements made by the class\nupon its caller and promises made by the class to its caller. The assumption speci\xef\xac\x81es hypothesis which\nhas to be satis\xef\xac\x81ed by the component in order to provide the guarantee.\nIn the context of software engineering, the notion of assertion-based contract has been adapted for\na wide variety of languages and formalisms but the central notion of time and/or trace needed for reactive system design is not always taken into account. For instance, extensions of OCL with linear or\nbranching-time temporal logics have been proposed in [25, 10], focusing on the expressivity of the proposed constraint language (the way constraints may talk about the internals of classes and objects), and\nconsidering a \xef\xac\x81xed \xe2\x80\x9csequence of states\xe2\x80\x9d. This is a serious limitation for concurrent system design, as this\nsequence becomes an interleaving of that of individual objects.\nIn the theory of interface automata [1], the notion of interface offers bene\xef\xac\x81ts similar to our notion of\ncontracts and for the purpose of checking interface compatibility between reactive modules. In that context, it is irrelevant to separate the assumptions from guarantees and only one contract needs to be and is\nassociated with a module Separation and multiple views become of importance in a more general-purpose\nsoftware engineering context. Separation allows more \xef\xac\x82exibility in \xef\xac\x81nding (contra-variant) compatibility\nrelations between components. Multiple views allow better isolation between modules and hence favor\ncompositionality. In our contract algebra as in interface automata, a contract can be expressed with only\none \xef\xac\x81lter. To this end, the \xef\xac\x81ltering equivalence relation (that de\xef\xac\x81nes the equivalence class of contracts\nthat accept the same set of processes) may be used to express a contract with only one guarantee \xef\xac\x81lter\nand with its hypothesis \xef\xac\x81lter accepting all the processes (or, conversely, with only one hypothesis \xef\xac\x81lter\n93\n\nA module language for typing by contracts\n\nGlouche, Talpin, Guernic, Gautier\n\nand a guarantee \xef\xac\x81lter that accepts no process).\nIn the context of the EC project Speeds [6], a model of assume-guarantee contracts is proposed which\nextends the notion of interface automata with modalities and multiple views. This consists of labelling\ntransitions that may be \xef\xac\x81red and other that must. By contrast to our domain-theoretical approach, the\nSpeeds approach starts from an abstracted notion of modules whose only structure is a partial order of\nre\xef\xac\x81nement. The proposed approach also leaves the role of variables in contracts unspeci\xef\xac\x81ed, at the cost\nof some algebraic relations such as inclusion.\nIn [18], a notion of synchronous contracts is proposed for the programming language L USTRE. In\nthis approach, contracts are executable speci\xef\xac\x81cations (synchronous observers) timely paced by a clock\n(the clock of the system). This yields an approach which is satisfactory to verify safety properties of\nindividual modules (which have a clock) but can hardly scale to the modeling of globally asynchronous\narchitectures (which have multiple clocks).\nIn [8], a compositonal notion of re\xef\xac\x81nement is proposed for a stream-processing data-\xef\xac\x82ow language.\nThe proposed type system allows reasoning on properties of programs abstracted by input-output types\nand causality graphs. In a similar way as Broy et al., we aim at using our module system to associate\nprograms with compilation contracts, consisting of the necessary (and suf\xef\xac\x81cient) synchronization and\nscheduling relations for modular code generation.\nThe system Jass [5] is somewhat closer to our motivations and solution. It proposes a notion of trace,\nand a language to talk about traces. However, it seems that it evolves mainly towards debugging and\ndefensive code generation. For embedded systems, we prefer to use contracts for validating composition\nand hope to use formal tools once we have a dedicated language for contracts. Like in JML [15], the\nnotion of agent with inputs/outputs does not exist in JASS, the language is based on class invariants, and\npre/post-conditions associated with methods.\nAnother example is the language Synergy [9], that combines two paradigms: object-oriented modeling for robust and \xef\xac\x82exible design, and synchronous execution for precise modeling of reactive behavior.\nIn [14], a method of encapsulation based on the object-oriented paradigm and behavioral inheritance for\nthe description of synchronous models is proposed. [24] describes an ML-like model for decomposing\ncomplex synchronous structures in parameterizable modules.\nOur main contribution is to de\xef\xac\x81ne a type system starting from a domain theoretical algebra for\nassume-guarantee reasoning consisting of a Boolean algebra of process-\xef\xac\x81lters and a Heyting algebra\nof contracts. This yields a rich structure which is\n1/ generic, in the way it can be implemented or instantiated to speci\xef\xac\x81c models of computation;\n2/ \xef\xac\x82exible, in the way it can help structuring and normalizing expressions;\n3/ complete, in the sense that all combinations of propositions can be expressed within the model.\nFinally, a temporal logic that is consistent with our model, such as for instance the ATL (Alternatingtime Temporal Logic [3]) can directly be used to express assumptions about the context of a process and\nguarantees provided by that process.\n\n8\n\nConclusion\n\nStarting from an abstract characterization of behaviors as functions from variables to a domain of values\n(Booleans, integers, series, sets of tagged values, continuous functions), we introduced the notion of\nprocess-\xef\xac\x81lters to formally characterize the logical device that \xef\xac\x81lters behaviors from process much like\nthe assumption and guarantee of a contract do. In our model, a process p ful\xef\xac\x81ls its requirements (or\nsatis\xef\xac\x81es) (A,G) if either it is rejected by A (i.e., if A represents assumptions on the environment, they\nare not satis\xef\xac\x81ed for p) or it is accepted by G. The structure of process-\xef\xac\x81lters is a Boolean algebra and\nallows for reasoning on contracts with great \xef\xac\x82exibility to abstract, re\xef\xac\x81ne and combine them. In addition\n94\n\nA module language for typing by contracts\n\nGlouche, Talpin, Guernic, Gautier\n\nto that, and unlike the related work, the negation of a contract can formally be expressed from within\nthe model. Moreover, contracts are not limited to expressing safety properties, as is the case in most\nrelated frameworks, but encompass the expression of liveness properties. This is all again due to the\ncentral notion of process-\xef\xac\x81lter. We introduced a module system based on the paradigm of contract for a\nsynchronous multi-clocked formalism, S IGNAL, and applied it to the speci\xef\xac\x81cation of a component-based\ndesign process. The paradigm we are putting forward is to regard a contract as the behavioral type of\na component and to use it for the elaboration of the functional architecture of a system together with a\nproof obligation that validates the correctness of assumptions and guarantees made while constructing\nthat architecture.\n\nReferences\n[1] Alfaro L. and Henzinger T. A. Interface automata. In ESEC / SIGSOFT FSE, pp. 109\xe2\x80\x93120, 2001.\n[2] Alpern, B., Schneider, F. Proving boolean combinations of deterministic properties. In Proceedings of the Second Symposium on Logic in Computer Science. IEEE Press, 1987.\n[3] Alur, R., Henzinger, T., and Kupferman, O. Alternating-time Temporal Logic. In Journal of the ACM, v. 49. ACM Press,\n2002.\n[4] Andr\xc2\xb4 C., Mallet F., and Peraldi-Frati M-A. A multiform time approach to real-time system modeling; application to an\ne\nautomotive system. In International Symposium on Industrial Embedded Systems, pp. 234\xe2\x80\x93241, 2007.\n[5] Bartetzko D., Fischer C., Mueller M., and Wehrheim H. Jass - Java with assertions. In Havelund, K., Rosu, G. eds :\nRuntime Veri\xef\xac\x81cation, Volume 55 of ENTCS(1):91\xe2\x80\x93108, 2001.\n[6] Benveniste A., Caillaud B., and Passerone R. A generic model of contracts for embedded systems. In INRIA RR n. 6214,\n2007.\n[7] Benveniste A., Le Guernic P., and Jacquemot C. Synchronous programming with events and relation: the SIGNAL language and its semantics. In Science of Computer Programming, volume v.16, 1991.\n[8] Broy, M. Compositional re\xef\xac\x81nement of interactive systems. Journal of the ACM, v. 44. ACM Press, 1997.\n[9] Budde R., Poign\xc2\xb4 A., and Sylla K.-H. Synergy - an object-oriented synchronous language. In Havelund, K., Rosu, G. eds:\ne\nRuntime Veri\xef\xac\x81cation, Volume 153 of Electronic Notes in Theoretical Computer Science(1):99\xe2\x80\x93115, 2006.\n[10] Flake S. and Mueller W. An OCL extension for realtime constraints. In Lecture Notes in Computer Science 2263, pp.\n150\xe2\x80\x93171, 2001.\n[11] Glouche Y., Le Guernic P., Talpin J.-P., and Gautier T. A boolean algebra of contracts for logical assume-guarantee\nreasoning. Research Report RR 6570, INRIA, 2008.\n[12] Halbwachs N. and Raymond P. Validation of Synchronous Reactive Systems: From Formal Veri\xef\xac\x81cation to Automatic\nTesting. In Advances in Computing Science-Proceedings of the ASIAN\xe2\x80\x9999 conference, 1999.\n[13] Hoare C.A.R. An axiomatic basis for computer programing. In Communications of the ACM, pp. 576\xe2\x80\x93583, 1969.\n[14] Kerb\xc5\x93uf M. and Talpin J.-P. Encapsulation and behavioural inheritance in a synchronous model of computation for\nembedded system services adaptation. In Journal of languages, algebra and progr. Special issue on process algebra and\nsyst. arch. Elsevier, 2004.\n[15] Leavens G. T., Baker A. L., and Ruby C. JML: A notation for detailed design. In Kilov H., Rumpe B., and Simmonds I.,\neditors, Behavioral Speci\xef\xac\x81cations of Businesses and Systems, pp. 175\xe2\x80\x93188. Kluwer Academic Publishers, 1999.\n[16] Le Guernic P., Talpin J.-P., and Le Lann J.-C. Polychrony for system design. Journal for Circuits, Systems and Computers,\nSpecial Issue on Application Speci\xef\xac\x81c Hardware Design, 2003.\n[17] Leroy X. A modular module system. Journal of Functional Programming, v. 10(3). Cambridge Academic Press, 2000.\n[18] Maraninchi F. and Morel L. Logical-time contracts for reactive embedded components. In In 30th EUROMICRO Conference on Component-Based Software Engineering Track, ECBSE\xe2\x80\x9904, Rennes, France, 2004.\n[19] Marchand, H., Bournai, P., Le Borgne, M., Le Guernic, P. Synthesis of Discrete-Event Controllers based on the Signal\nEnvironment, Discrete Event Dynamic System: Theory and Applications, v. 10(4), 2000.\n[20] Marchand, H., Rutten, E., Le Borgne, M., Samaan, M. Formal Veri\xef\xac\x81cation of programs speci\xef\xac\x81ed with Signal: Application\nto a Power Transformer Station Controller. Science of Computer Programming, v. 41(1). Elsevier, 2001.\n[21] Martin A. and Lamport L. Composing speci\xef\xac\x81cations. In ACM Trans. ProgramLang. Syst. 15, pp. 73\xe2\x80\x93132, 1993.\n[22] Meyer B. Object-Oriented Software Construction, Second Edition. ISE Inc., Santa Barbara, 1997.\n[23] Mitchell R. and McKim J. Design by Contract, by Example, Addison-Wesley, 2002.\n[24] Nowak D., Talpin J.-P., Gautier T., and Le Guernic P. An ML-like module system for the synchronous language SIGNAL.\nIn European Conference on Parallel Processing (EUROPAR\xe2\x80\x9997), August 1997.\n[25] Ziemann P. and Gogolla M. An extension of OCL with temporal logic. In Critical Systems Development with UMLProceedings of the UML\xe2\x80\x9902 workshop, 2002.\n\n95\n\n'